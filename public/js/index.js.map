{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/sortablejs/Sortable.js","src/js/index.js","src/js/modules/search.mjs","src/js/modules/togglePreferences.mjs","src/js/modules/unreadAnnouncements.mjs","src/js/modules/utils.mjs","src/js/web-components/announcements.mjs","src/js/web-components/course-overview.mjs","src/js/web-components/schedule.mjs","src/js/web-components/study-progress.mjs","src/js/web-components/urgent-announcement.mjs"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7nHA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEA,IAAM,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAuB,MAAvB,EAA+B,EAA/B,CAAkC,WAAlC,EAAb,C,CAEA;;AACA,IAAI,IAAI,KAAK,WAAb,EAA0B;AACtB,EAAA,KAAK,CAAC,aAAN,CAAoB,KAAK,CAAC,cAAN,EAApB;AACH;;AAED,IAAI,IAAI,KAAK,SAAb,EAAwB;AACpB;AACH;;AAED,IAAI,IAAI,KAAK,wBAAb,EAAuC;AACnC,MAAM,gBAAgB,GAAG,QAAQ,CAAC,cAAT,CAAwB,eAAxB,CAAzB;AACA,EAAA,gBAAgB,CAAC,MAAjB;AACA,EAAA,QAAQ,CAAC,aAAT,CAAuB,cAAvB,EAAuC,MAAvC,CAA8C,QAAQ,CAAC,aAAT,CAAuB,sBAAvB,CAA9C;AACA,6CAAuB,IAAvB;AACH,C,CAGD;;;AACA,IAAI,SAAS,CAAC,MAAd,EAAsB;AAClB;AACA,MAAM,MAAM,GAAG,EAAE,EAAjB,CAFkB,CAIlB;;AACA,EAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,IAApB,EALkB,CAOlB;;A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","file":"index.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**!\n * Sortable 1.10.2\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Sortable = factory());\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var version = \"1.10.2\";\n\n  function userAgent(pattern) {\n    if (typeof window !== 'undefined' && window.navigator) {\n      return !!\n      /*@__PURE__*/\n      navigator.userAgent.match(pattern);\n    }\n  }\n\n  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\n  var Edge = userAgent(/Edge/i);\n  var FireFox = userAgent(/firefox/i);\n  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\n  var IOS = userAgent(/iP(ad|od|hone)/i);\n  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\n  var captureMode = {\n    capture: false,\n    passive: false\n  };\n\n  function on(el, event, fn) {\n    el.addEventListener(event, fn, !IE11OrLess && captureMode);\n  }\n\n  function off(el, event, fn) {\n    el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n  }\n\n  function matches(\n  /**HTMLElement*/\n  el,\n  /**String*/\n  selector) {\n    if (!selector) return;\n    selector[0] === '>' && (selector = selector.substring(1));\n\n    if (el) {\n      try {\n        if (el.matches) {\n          return el.matches(selector);\n        } else if (el.msMatchesSelector) {\n          return el.msMatchesSelector(selector);\n        } else if (el.webkitMatchesSelector) {\n          return el.webkitMatchesSelector(selector);\n        }\n      } catch (_) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  function getParentOrHost(el) {\n    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n  }\n\n  function closest(\n  /**HTMLElement*/\n  el,\n  /**String*/\n  selector,\n  /**HTMLElement*/\n  ctx, includeCTX) {\n    if (el) {\n      ctx = ctx || document;\n\n      do {\n        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n          return el;\n        }\n\n        if (el === ctx) break;\n        /* jshint boss:true */\n      } while (el = getParentOrHost(el));\n    }\n\n    return null;\n  }\n\n  var R_SPACE = /\\s+/g;\n\n  function toggleClass(el, name, state) {\n    if (el && name) {\n      if (el.classList) {\n        el.classList[state ? 'add' : 'remove'](name);\n      } else {\n        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n      }\n    }\n  }\n\n  function css(el, prop, val) {\n    var style = el && el.style;\n\n    if (style) {\n      if (val === void 0) {\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n          val = document.defaultView.getComputedStyle(el, '');\n        } else if (el.currentStyle) {\n          val = el.currentStyle;\n        }\n\n        return prop === void 0 ? val : val[prop];\n      } else {\n        if (!(prop in style) && prop.indexOf('webkit') === -1) {\n          prop = '-webkit-' + prop;\n        }\n\n        style[prop] = val + (typeof val === 'string' ? '' : 'px');\n      }\n    }\n  }\n\n  function matrix(el, selfOnly) {\n    var appliedTransforms = '';\n\n    if (typeof el === 'string') {\n      appliedTransforms = el;\n    } else {\n      do {\n        var transform = css(el, 'transform');\n\n        if (transform && transform !== 'none') {\n          appliedTransforms = transform + ' ' + appliedTransforms;\n        }\n        /* jshint boss:true */\n\n      } while (!selfOnly && (el = el.parentNode));\n    }\n\n    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n    /*jshint -W056 */\n\n    return matrixFn && new matrixFn(appliedTransforms);\n  }\n\n  function find(ctx, tagName, iterator) {\n    if (ctx) {\n      var list = ctx.getElementsByTagName(tagName),\n          i = 0,\n          n = list.length;\n\n      if (iterator) {\n        for (; i < n; i++) {\n          iterator(list[i], i);\n        }\n      }\n\n      return list;\n    }\n\n    return [];\n  }\n\n  function getWindowScrollingElement() {\n    var scrollingElement = document.scrollingElement;\n\n    if (scrollingElement) {\n      return scrollingElement;\n    } else {\n      return document.documentElement;\n    }\n  }\n  /**\r\n   * Returns the \"bounding client rect\" of given element\r\n   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\r\n   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\r\n   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\r\n   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\r\n   * @param  {[HTMLElement]} container              The parent the element will be placed in\r\n   * @return {Object}                               The boundingClientRect of el, with specified adjustments\r\n   */\n\n\n  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n    if (!el.getBoundingClientRect && el !== window) return;\n    var elRect, top, left, bottom, right, height, width;\n\n    if (el !== window && el !== getWindowScrollingElement()) {\n      elRect = el.getBoundingClientRect();\n      top = elRect.top;\n      left = elRect.left;\n      bottom = elRect.bottom;\n      right = elRect.right;\n      height = elRect.height;\n      width = elRect.width;\n    } else {\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      height = window.innerHeight;\n      width = window.innerWidth;\n    }\n\n    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n      // Adjust for translate()\n      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n      // Not needed on <= IE11\n\n      if (!IE11OrLess) {\n        do {\n          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n            top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n            left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n            bottom = top + elRect.height;\n            right = left + elRect.width;\n            break;\n          }\n          /* jshint boss:true */\n\n        } while (container = container.parentNode);\n      }\n    }\n\n    if (undoScale && el !== window) {\n      // Adjust for scale()\n      var elMatrix = matrix(container || el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d;\n\n      if (elMatrix) {\n        top /= scaleY;\n        left /= scaleX;\n        width /= scaleX;\n        height /= scaleY;\n        bottom = top + height;\n        right = left + width;\n      }\n    }\n\n    return {\n      top: top,\n      left: left,\n      bottom: bottom,\n      right: right,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Checks if a side of an element is scrolled past a side of its parents\r\n   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\r\n   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\r\n   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\r\n   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n   */\n\n\n  function isScrolledPast(el, elSide, parentSide) {\n    var parent = getParentAutoScrollElement(el, true),\n        elSideVal = getRect(el)[elSide];\n    /* jshint boss:true */\n\n    while (parent) {\n      var parentSideVal = getRect(parent)[parentSide],\n          visible = void 0;\n\n      if (parentSide === 'top' || parentSide === 'left') {\n        visible = elSideVal >= parentSideVal;\n      } else {\n        visible = elSideVal <= parentSideVal;\n      }\n\n      if (!visible) return parent;\n      if (parent === getWindowScrollingElement()) break;\n      parent = getParentAutoScrollElement(parent, false);\n    }\n\n    return false;\n  }\n  /**\r\n   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n   * and non-draggable elements\r\n   * @param  {HTMLElement} el       The parent element\r\n   * @param  {Number} childNum      The index of the child\r\n   * @param  {Object} options       Parent Sortable's options\r\n   * @return {HTMLElement}          The child at index childNum, or null if not found\r\n   */\n\n\n  function getChild(el, childNum, options) {\n    var currentChild = 0,\n        i = 0,\n        children = el.children;\n\n    while (i < children.length) {\n      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {\n        if (currentChild === childNum) {\n          return children[i];\n        }\n\n        currentChild++;\n      }\n\n      i++;\n    }\n\n    return null;\n  }\n  /**\r\n   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n   * @param  {HTMLElement} el       Parent element\r\n   * @param  {selector} selector    Any other elements that should be ignored\r\n   * @return {HTMLElement}          The last child, ignoring ghostEl\r\n   */\n\n\n  function lastChild(el, selector) {\n    var last = el.lastElementChild;\n\n    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n      last = last.previousElementSibling;\n    }\n\n    return last || null;\n  }\n  /**\r\n   * Returns the index of an element within its parent for a selected set of\r\n   * elements\r\n   * @param  {HTMLElement} el\r\n   * @param  {selector} selector\r\n   * @return {number}\r\n   */\n\n\n  function index(el, selector) {\n    var index = 0;\n\n    if (!el || !el.parentNode) {\n      return -1;\n    }\n    /* jshint boss:true */\n\n\n    while (el = el.previousElementSibling) {\n      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n        index++;\n      }\n    }\n\n    return index;\n  }\n  /**\r\n   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\r\n   * The value is returned in real pixels.\r\n   * @param  {HTMLElement} el\r\n   * @return {Array}             Offsets in the format of [left, top]\r\n   */\n\n\n  function getRelativeScrollOffset(el) {\n    var offsetLeft = 0,\n        offsetTop = 0,\n        winScroller = getWindowScrollingElement();\n\n    if (el) {\n      do {\n        var elMatrix = matrix(el),\n            scaleX = elMatrix.a,\n            scaleY = elMatrix.d;\n        offsetLeft += el.scrollLeft * scaleX;\n        offsetTop += el.scrollTop * scaleY;\n      } while (el !== winScroller && (el = el.parentNode));\n    }\n\n    return [offsetLeft, offsetTop];\n  }\n  /**\r\n   * Returns the index of the object within the given array\r\n   * @param  {Array} arr   Array that may or may not hold the object\r\n   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\r\n   * @return {Number}      The index of the object in the array, or -1\r\n   */\n\n\n  function indexOfObject(arr, obj) {\n    for (var i in arr) {\n      if (!arr.hasOwnProperty(i)) continue;\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n      }\n    }\n\n    return -1;\n  }\n\n  function getParentAutoScrollElement(el, includeSelf) {\n    // skip to window\n    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n    var elem = el;\n    var gotSelf = false;\n\n    do {\n      // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n        var elemCSS = css(elem);\n\n        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n          if (gotSelf || includeSelf) return elem;\n          gotSelf = true;\n        }\n      }\n      /* jshint boss:true */\n\n    } while (elem = elem.parentNode);\n\n    return getWindowScrollingElement();\n  }\n\n  function extend(dst, src) {\n    if (dst && src) {\n      for (var key in src) {\n        if (src.hasOwnProperty(key)) {\n          dst[key] = src[key];\n        }\n      }\n    }\n\n    return dst;\n  }\n\n  function isRectEqual(rect1, rect2) {\n    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n  }\n\n  var _throttleTimeout;\n\n  function throttle(callback, ms) {\n    return function () {\n      if (!_throttleTimeout) {\n        var args = arguments,\n            _this = this;\n\n        if (args.length === 1) {\n          callback.call(_this, args[0]);\n        } else {\n          callback.apply(_this, args);\n        }\n\n        _throttleTimeout = setTimeout(function () {\n          _throttleTimeout = void 0;\n        }, ms);\n      }\n    };\n  }\n\n  function cancelThrottle() {\n    clearTimeout(_throttleTimeout);\n    _throttleTimeout = void 0;\n  }\n\n  function scrollBy(el, x, y) {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n\n  function clone(el) {\n    var Polymer = window.Polymer;\n    var $ = window.jQuery || window.Zepto;\n\n    if (Polymer && Polymer.dom) {\n      return Polymer.dom(el).cloneNode(true);\n    } else if ($) {\n      return $(el).clone(true)[0];\n    } else {\n      return el.cloneNode(true);\n    }\n  }\n\n  function setRect(el, rect) {\n    css(el, 'position', 'absolute');\n    css(el, 'top', rect.top);\n    css(el, 'left', rect.left);\n    css(el, 'width', rect.width);\n    css(el, 'height', rect.height);\n  }\n\n  function unsetRect(el) {\n    css(el, 'position', '');\n    css(el, 'top', '');\n    css(el, 'left', '');\n    css(el, 'width', '');\n    css(el, 'height', '');\n  }\n\n  var expando = 'Sortable' + new Date().getTime();\n\n  function AnimationStateManager() {\n    var animationStates = [],\n        animationCallbackId;\n    return {\n      captureAnimationState: function captureAnimationState() {\n        animationStates = [];\n        if (!this.options.animation) return;\n        var children = [].slice.call(this.el.children);\n        children.forEach(function (child) {\n          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n          animationStates.push({\n            target: child,\n            rect: getRect(child)\n          });\n\n          var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n          if (child.thisAnimationDuration) {\n            var childMatrix = matrix(child, true);\n\n            if (childMatrix) {\n              fromRect.top -= childMatrix.f;\n              fromRect.left -= childMatrix.e;\n            }\n          }\n\n          child.fromRect = fromRect;\n        });\n      },\n      addAnimationState: function addAnimationState(state) {\n        animationStates.push(state);\n      },\n      removeAnimationState: function removeAnimationState(target) {\n        animationStates.splice(indexOfObject(animationStates, {\n          target: target\n        }), 1);\n      },\n      animateAll: function animateAll(callback) {\n        var _this = this;\n\n        if (!this.options.animation) {\n          clearTimeout(animationCallbackId);\n          if (typeof callback === 'function') callback();\n          return;\n        }\n\n        var animating = false,\n            animationTime = 0;\n        animationStates.forEach(function (state) {\n          var time = 0,\n              target = state.target,\n              fromRect = target.fromRect,\n              toRect = getRect(target),\n              prevFromRect = target.prevFromRect,\n              prevToRect = target.prevToRect,\n              animatingRect = state.rect,\n              targetMatrix = matrix(target, true);\n\n          if (targetMatrix) {\n            // Compensate for current animation\n            toRect.top -= targetMatrix.f;\n            toRect.left -= targetMatrix.e;\n          }\n\n          target.toRect = toRect;\n\n          if (target.thisAnimationDuration) {\n            // Could also check if animatingRect is between fromRect and toRect\n            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n              // If returning to same place as started from animation and on same axis\n              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n            }\n          } // if fromRect != toRect: animate\n\n\n          if (!isRectEqual(toRect, fromRect)) {\n            target.prevFromRect = fromRect;\n            target.prevToRect = toRect;\n\n            if (!time) {\n              time = _this.options.animation;\n            }\n\n            _this.animate(target, animatingRect, toRect, time);\n          }\n\n          if (time) {\n            animating = true;\n            animationTime = Math.max(animationTime, time);\n            clearTimeout(target.animationResetTimer);\n            target.animationResetTimer = setTimeout(function () {\n              target.animationTime = 0;\n              target.prevFromRect = null;\n              target.fromRect = null;\n              target.prevToRect = null;\n              target.thisAnimationDuration = null;\n            }, time);\n            target.thisAnimationDuration = time;\n          }\n        });\n        clearTimeout(animationCallbackId);\n\n        if (!animating) {\n          if (typeof callback === 'function') callback();\n        } else {\n          animationCallbackId = setTimeout(function () {\n            if (typeof callback === 'function') callback();\n          }, animationTime);\n        }\n\n        animationStates = [];\n      },\n      animate: function animate(target, currentRect, toRect, duration) {\n        if (duration) {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          var elMatrix = matrix(this.el),\n              scaleX = elMatrix && elMatrix.a,\n              scaleY = elMatrix && elMatrix.d,\n              translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n              translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n          target.animatingX = !!translateX;\n          target.animatingY = !!translateY;\n          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n          repaint(target); // repaint\n\n          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n          css(target, 'transform', 'translate3d(0,0,0)');\n          typeof target.animated === 'number' && clearTimeout(target.animated);\n          target.animated = setTimeout(function () {\n            css(target, 'transition', '');\n            css(target, 'transform', '');\n            target.animated = false;\n            target.animatingX = false;\n            target.animatingY = false;\n          }, duration);\n        }\n      }\n    };\n  }\n\n  function repaint(target) {\n    return target.offsetWidth;\n  }\n\n  function calculateRealTime(animatingRect, fromRect, toRect, options) {\n    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n  }\n\n  var plugins = [];\n  var defaults = {\n    initializeByDefault: true\n  };\n  var PluginManager = {\n    mount: function mount(plugin) {\n      // Set default static properties\n      for (var option in defaults) {\n        if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n          plugin[option] = defaults[option];\n        }\n      }\n\n      plugins.push(plugin);\n    },\n    pluginEvent: function pluginEvent(eventName, sortable, evt) {\n      var _this = this;\n\n      this.eventCanceled = false;\n\n      evt.cancel = function () {\n        _this.eventCanceled = true;\n      };\n\n      var eventNameGlobal = eventName + 'Global';\n      plugins.forEach(function (plugin) {\n        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n        if (sortable[plugin.pluginName][eventNameGlobal]) {\n          sortable[plugin.pluginName][eventNameGlobal](_objectSpread({\n            sortable: sortable\n          }, evt));\n        } // Only fire plugin event if plugin is enabled in this sortable,\n        // and plugin has event defined\n\n\n        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n          sortable[plugin.pluginName][eventName](_objectSpread({\n            sortable: sortable\n          }, evt));\n        }\n      });\n    },\n    initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n      plugins.forEach(function (plugin) {\n        var pluginName = plugin.pluginName;\n        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n        var initialized = new plugin(sortable, el, sortable.options);\n        initialized.sortable = sortable;\n        initialized.options = sortable.options;\n        sortable[pluginName] = initialized; // Add default options from plugin\n\n        _extends(defaults, initialized.defaults);\n      });\n\n      for (var option in sortable.options) {\n        if (!sortable.options.hasOwnProperty(option)) continue;\n        var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n        if (typeof modified !== 'undefined') {\n          sortable.options[option] = modified;\n        }\n      }\n    },\n    getEventProperties: function getEventProperties(name, sortable) {\n      var eventProperties = {};\n      plugins.forEach(function (plugin) {\n        if (typeof plugin.eventProperties !== 'function') return;\n\n        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n      });\n      return eventProperties;\n    },\n    modifyOption: function modifyOption(sortable, name, value) {\n      var modifiedValue;\n      plugins.forEach(function (plugin) {\n        // Plugin must exist on the Sortable\n        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n        }\n      });\n      return modifiedValue;\n    }\n  };\n\n  function dispatchEvent(_ref) {\n    var sortable = _ref.sortable,\n        rootEl = _ref.rootEl,\n        name = _ref.name,\n        targetEl = _ref.targetEl,\n        cloneEl = _ref.cloneEl,\n        toEl = _ref.toEl,\n        fromEl = _ref.fromEl,\n        oldIndex = _ref.oldIndex,\n        newIndex = _ref.newIndex,\n        oldDraggableIndex = _ref.oldDraggableIndex,\n        newDraggableIndex = _ref.newDraggableIndex,\n        originalEvent = _ref.originalEvent,\n        putSortable = _ref.putSortable,\n        extraEventProperties = _ref.extraEventProperties;\n    sortable = sortable || rootEl && rootEl[expando];\n    if (!sortable) return;\n    var evt,\n        options = sortable.options,\n        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\n      evt = new CustomEvent(name, {\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    evt.to = toEl || rootEl;\n    evt.from = fromEl || rootEl;\n    evt.item = targetEl || rootEl;\n    evt.clone = cloneEl;\n    evt.oldIndex = oldIndex;\n    evt.newIndex = newIndex;\n    evt.oldDraggableIndex = oldDraggableIndex;\n    evt.newDraggableIndex = newDraggableIndex;\n    evt.originalEvent = originalEvent;\n    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n    var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));\n\n    for (var option in allEventProperties) {\n      evt[option] = allEventProperties[option];\n    }\n\n    if (rootEl) {\n      rootEl.dispatchEvent(evt);\n    }\n\n    if (options[onName]) {\n      options[onName].call(sortable, evt);\n    }\n  }\n\n  var pluginEvent = function pluginEvent(eventName, sortable) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        originalEvent = _ref.evt,\n        data = _objectWithoutProperties(_ref, [\"evt\"]);\n\n    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({\n      dragEl: dragEl,\n      parentEl: parentEl,\n      ghostEl: ghostEl,\n      rootEl: rootEl,\n      nextEl: nextEl,\n      lastDownEl: lastDownEl,\n      cloneEl: cloneEl,\n      cloneHidden: cloneHidden,\n      dragStarted: moved,\n      putSortable: putSortable,\n      activeSortable: Sortable.active,\n      originalEvent: originalEvent,\n      oldIndex: oldIndex,\n      oldDraggableIndex: oldDraggableIndex,\n      newIndex: newIndex,\n      newDraggableIndex: newDraggableIndex,\n      hideGhostForTarget: _hideGhostForTarget,\n      unhideGhostForTarget: _unhideGhostForTarget,\n      cloneNowHidden: function cloneNowHidden() {\n        cloneHidden = true;\n      },\n      cloneNowShown: function cloneNowShown() {\n        cloneHidden = false;\n      },\n      dispatchSortableEvent: function dispatchSortableEvent(name) {\n        _dispatchEvent({\n          sortable: sortable,\n          name: name,\n          originalEvent: originalEvent\n        });\n      }\n    }, data));\n  };\n\n  function _dispatchEvent(info) {\n    dispatchEvent(_objectSpread({\n      putSortable: putSortable,\n      cloneEl: cloneEl,\n      targetEl: dragEl,\n      rootEl: rootEl,\n      oldIndex: oldIndex,\n      oldDraggableIndex: oldDraggableIndex,\n      newIndex: newIndex,\n      newDraggableIndex: newDraggableIndex\n    }, info));\n  }\n\n  var dragEl,\n      parentEl,\n      ghostEl,\n      rootEl,\n      nextEl,\n      lastDownEl,\n      cloneEl,\n      cloneHidden,\n      oldIndex,\n      newIndex,\n      oldDraggableIndex,\n      newDraggableIndex,\n      activeGroup,\n      putSortable,\n      awaitingDragStarted = false,\n      ignoreNextClick = false,\n      sortables = [],\n      tapEvt,\n      touchEvt,\n      lastDx,\n      lastDy,\n      tapDistanceLeft,\n      tapDistanceTop,\n      moved,\n      lastTarget,\n      lastDirection,\n      pastFirstInvertThresh = false,\n      isCircumstantialInvert = false,\n      targetMoveDistance,\n      // For positioning ghost absolutely\n  ghostRelativeParent,\n      ghostRelativeParentInitialScroll = [],\n      // (left, top)\n  _silent = false,\n      savedInputChecked = [];\n  /** @const */\n\n  var documentExists = typeof document !== 'undefined',\n      PositionGhostAbsolutely = IOS,\n      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n      // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n      supportCssPointerEvents = function () {\n    if (!documentExists) return; // false when <= IE11\n\n    if (IE11OrLess) {\n      return false;\n    }\n\n    var el = document.createElement('x');\n    el.style.cssText = 'pointer-events:auto';\n    return el.style.pointerEvents === 'auto';\n  }(),\n      _detectDirection = function _detectDirection(el, options) {\n    var elCSS = css(el),\n        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n        child1 = getChild(el, 0, options),\n        child2 = getChild(el, 1, options),\n        firstChildCSS = child1 && css(child1),\n        secondChildCSS = child2 && css(child2),\n        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n    if (elCSS.display === 'flex') {\n      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n    }\n\n    if (elCSS.display === 'grid') {\n      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n    }\n\n    if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n      var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n    }\n\n    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n  },\n      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n        dragElOppLength = vertical ? dragRect.width : dragRect.height,\n        targetS1Opp = vertical ? targetRect.left : targetRect.top,\n        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n        targetOppLength = vertical ? targetRect.width : targetRect.height;\n    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n  },\n\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n    var ret;\n    sortables.some(function (sortable) {\n      if (lastChild(sortable)) return;\n      var rect = getRect(sortable),\n          threshold = sortable[expando].options.emptyInsertThreshold,\n          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return ret = sortable;\n      }\n    });\n    return ret;\n  },\n      _prepareGroup = function _prepareGroup(options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === 'clone') {\n          return value;\n        } else if (typeof value === 'function') {\n          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n        } else {\n          var otherGroup = (pull ? to : from).options.group.name;\n          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n        }\n      };\n    }\n\n    var group = {};\n    var originalGroup = options.group;\n\n    if (!originalGroup || _typeof(originalGroup) != 'object') {\n      originalGroup = {\n        name: originalGroup\n      };\n    }\n\n    group.name = originalGroup.name;\n    group.checkPull = toFn(originalGroup.pull, true);\n    group.checkPut = toFn(originalGroup.put);\n    group.revertClone = originalGroup.revertClone;\n    options.group = group;\n  },\n      _hideGhostForTarget = function _hideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', 'none');\n    }\n  },\n      _unhideGhostForTarget = function _unhideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', '');\n    }\n  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\n  if (documentExists) {\n    document.addEventListener('click', function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    }, true);\n  }\n\n  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n    if (dragEl) {\n      evt = evt.touches ? evt.touches[0] : evt;\n\n      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n      if (nearest) {\n        // Create imitation event\n        var event = {};\n\n        for (var i in evt) {\n          if (evt.hasOwnProperty(i)) {\n            event[i] = evt[i];\n          }\n        }\n\n        event.target = event.rootEl = nearest;\n        event.preventDefault = void 0;\n        event.stopPropagation = void 0;\n\n        nearest[expando]._onDragOver(event);\n      }\n    }\n  };\n\n  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n    if (dragEl) {\n      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n    }\n  };\n  /**\n   * @class  Sortable\n   * @param  {HTMLElement}  el\n   * @param  {Object}       [options]\n   */\n\n\n  function Sortable(el, options) {\n    if (!(el && el.nodeType && el.nodeType === 1)) {\n      throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n    }\n\n    this.el = el; // root element\n\n    this.options = options = _extends({}, options); // Export instance\n\n    el[expando] = this;\n    var defaults = {\n      group: null,\n      sort: true,\n      disabled: false,\n      store: null,\n      handle: null,\n      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n      swapThreshold: 1,\n      // percentage; 0 <= x <= 1\n      invertSwap: false,\n      // invert always\n      invertedSwapThreshold: null,\n      // will be set to same as swapThreshold if default\n      removeCloneOnHide: true,\n      direction: function direction() {\n        return _detectDirection(el, this.options);\n      },\n      ghostClass: 'sortable-ghost',\n      chosenClass: 'sortable-chosen',\n      dragClass: 'sortable-drag',\n      ignore: 'a, img',\n      filter: null,\n      preventOnFilter: true,\n      animation: 0,\n      easing: null,\n      setData: function setData(dataTransfer, dragEl) {\n        dataTransfer.setData('Text', dragEl.textContent);\n      },\n      dropBubble: false,\n      dragoverBubble: false,\n      dataIdAttr: 'data-id',\n      delay: 0,\n      delayOnTouchOnly: false,\n      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n      forceFallback: false,\n      fallbackClass: 'sortable-fallback',\n      fallbackOnBody: false,\n      fallbackTolerance: 0,\n      fallbackOffset: {\n        x: 0,\n        y: 0\n      },\n      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,\n      emptyInsertThreshold: 5\n    };\n    PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n    for (var name in defaults) {\n      !(name in options) && (options[name] = defaults[name]);\n    }\n\n    _prepareGroup(options); // Bind all private methods\n\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    } // Setup drag mode\n\n\n    this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n    if (this.nativeDraggable) {\n      // Touch start threshold cannot be greater than the native dragstart threshold\n      this.options.touchStartThreshold = 1;\n    } // Bind events\n\n\n    if (options.supportPointer) {\n      on(el, 'pointerdown', this._onTapStart);\n    } else {\n      on(el, 'mousedown', this._onTapStart);\n      on(el, 'touchstart', this._onTapStart);\n    }\n\n    if (this.nativeDraggable) {\n      on(el, 'dragover', this);\n      on(el, 'dragenter', this);\n    }\n\n    sortables.push(this.el); // Restore sorting\n\n    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n    _extends(this, AnimationStateManager());\n  }\n\n  Sortable.prototype =\n  /** @lends Sortable.prototype */\n  {\n    constructor: Sortable,\n    _isOutsideThisEl: function _isOutsideThisEl(target) {\n      if (!this.el.contains(target) && target !== this.el) {\n        lastTarget = null;\n      }\n    },\n    _getDirection: function _getDirection(evt, target) {\n      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n    },\n    _onTapStart: function _onTapStart(\n    /** Event|TouchEvent */\n    evt) {\n      if (!evt.cancelable) return;\n\n      var _this = this,\n          el = this.el,\n          options = this.options,\n          preventOnFilter = options.preventOnFilter,\n          type = evt.type,\n          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n          target = (touch || evt).target,\n          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n          filter = options.filter;\n\n      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n      if (dragEl) {\n        return;\n      }\n\n      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n        return; // only left button and enabled\n      } // cancel dnd if original target is content editable\n\n\n      if (originalTarget.isContentEditable) {\n        return;\n      }\n\n      target = closest(target, options.draggable, el, false);\n\n      if (target && target.animated) {\n        return;\n      }\n\n      if (lastDownEl === target) {\n        // Ignoring duplicate `down`\n        return;\n      } // Get the index of the dragged element within its parent\n\n\n      oldIndex = index(target);\n      oldDraggableIndex = index(target, options.draggable); // Check filter\n\n      if (typeof filter === 'function') {\n        if (filter.call(this, evt, target, this)) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: originalTarget,\n            name: 'filter',\n            targetEl: target,\n            toEl: el,\n            fromEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          preventOnFilter && evt.cancelable && evt.preventDefault();\n          return; // cancel dnd\n        }\n      } else if (filter) {\n        filter = filter.split(',').some(function (criteria) {\n          criteria = closest(originalTarget, criteria.trim(), el, false);\n\n          if (criteria) {\n            _dispatchEvent({\n              sortable: _this,\n              rootEl: criteria,\n              name: 'filter',\n              targetEl: target,\n              fromEl: el,\n              toEl: el\n            });\n\n            pluginEvent('filter', _this, {\n              evt: evt\n            });\n            return true;\n          }\n        });\n\n        if (filter) {\n          preventOnFilter && evt.cancelable && evt.preventDefault();\n          return; // cancel dnd\n        }\n      }\n\n      if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n        return;\n      } // Prepare `dragstart`\n\n\n      this._prepareDragStart(evt, touch, target);\n    },\n    _prepareDragStart: function _prepareDragStart(\n    /** Event */\n    evt,\n    /** Touch */\n    touch,\n    /** HTMLElement */\n    target) {\n      var _this = this,\n          el = _this.el,\n          options = _this.options,\n          ownerDocument = el.ownerDocument,\n          dragStartFn;\n\n      if (target && !dragEl && target.parentNode === el) {\n        var dragRect = getRect(target);\n        rootEl = el;\n        dragEl = target;\n        parentEl = dragEl.parentNode;\n        nextEl = dragEl.nextSibling;\n        lastDownEl = target;\n        activeGroup = options.group;\n        Sortable.dragged = dragEl;\n        tapEvt = {\n          target: dragEl,\n          clientX: (touch || evt).clientX,\n          clientY: (touch || evt).clientY\n        };\n        tapDistanceLeft = tapEvt.clientX - dragRect.left;\n        tapDistanceTop = tapEvt.clientY - dragRect.top;\n        this._lastX = (touch || evt).clientX;\n        this._lastY = (touch || evt).clientY;\n        dragEl.style['will-change'] = 'all';\n\n        dragStartFn = function dragStartFn() {\n          pluginEvent('delayEnded', _this, {\n            evt: evt\n          });\n\n          if (Sortable.eventCanceled) {\n            _this._onDrop();\n\n            return;\n          } // Delayed drag has been triggered\n          // we can re-enable the events: touchmove/mousemove\n\n\n          _this._disableDelayedDragEvents();\n\n          if (!FireFox && _this.nativeDraggable) {\n            dragEl.draggable = true;\n          } // Bind the events: dragstart/dragend\n\n\n          _this._triggerDragStart(evt, touch); // Drag start event\n\n\n          _dispatchEvent({\n            sortable: _this,\n            name: 'choose',\n            originalEvent: evt\n          }); // Chosen item\n\n\n          toggleClass(dragEl, options.chosenClass, true);\n        }; // Disable \"draggable\"\n\n\n        options.ignore.split(',').forEach(function (criteria) {\n          find(dragEl, criteria.trim(), _disableDraggable);\n        });\n        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'mouseup', _this._onDrop);\n        on(ownerDocument, 'touchend', _this._onDrop);\n        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n        if (FireFox && this.nativeDraggable) {\n          this.options.touchStartThreshold = 4;\n          dragEl.draggable = true;\n        }\n\n        pluginEvent('delayStart', this, {\n          evt: evt\n        }); // Delay is impossible for native DnD in Edge or IE\n\n        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n          if (Sortable.eventCanceled) {\n            this._onDrop();\n\n            return;\n          } // If the user moves the pointer or let go the click or touch\n          // before the delay has been reached:\n          // disable the delayed drag\n\n\n          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n        } else {\n          dragStartFn();\n        }\n      }\n    },\n    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n    /** TouchEvent|PointerEvent **/\n    e) {\n      var touch = e.touches ? e.touches[0] : e;\n\n      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n        this._disableDelayedDrag();\n      }\n    },\n    _disableDelayedDrag: function _disableDelayedDrag() {\n      dragEl && _disableDraggable(dragEl);\n      clearTimeout(this._dragStartTimer);\n\n      this._disableDelayedDragEvents();\n    },\n    _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n      var ownerDocument = this.el.ownerDocument;\n      off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n      off(ownerDocument, 'touchend', this._disableDelayedDrag);\n      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n    },\n    _triggerDragStart: function _triggerDragStart(\n    /** Event */\n    evt,\n    /** Touch */\n    touch) {\n      touch = touch || evt.pointerType == 'touch' && evt;\n\n      if (!this.nativeDraggable || touch) {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._onTouchMove);\n        } else if (touch) {\n          on(document, 'touchmove', this._onTouchMove);\n        } else {\n          on(document, 'mousemove', this._onTouchMove);\n        }\n      } else {\n        on(dragEl, 'dragend', this);\n        on(rootEl, 'dragstart', this._onDragStart);\n      }\n\n      try {\n        if (document.selection) {\n          // Timeout neccessary for IE9\n          _nextTick(function () {\n            document.selection.empty();\n          });\n        } else {\n          window.getSelection().removeAllRanges();\n        }\n      } catch (err) {}\n    },\n    _dragStarted: function _dragStarted(fallback, evt) {\n\n      awaitingDragStarted = false;\n\n      if (rootEl && dragEl) {\n        pluginEvent('dragStarted', this, {\n          evt: evt\n        });\n\n        if (this.nativeDraggable) {\n          on(document, 'dragover', _checkOutsideTargetEl);\n        }\n\n        var options = this.options; // Apply effect\n\n        !fallback && toggleClass(dragEl, options.dragClass, false);\n        toggleClass(dragEl, options.ghostClass, true);\n        Sortable.active = this;\n        fallback && this._appendGhost(); // Drag start event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'start',\n          originalEvent: evt\n        });\n      } else {\n        this._nulling();\n      }\n    },\n    _emulateDragOver: function _emulateDragOver() {\n      if (touchEvt) {\n        this._lastX = touchEvt.clientX;\n        this._lastY = touchEvt.clientY;\n\n        _hideGhostForTarget();\n\n        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        var parent = target;\n\n        while (target && target.shadowRoot) {\n          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n          if (target === parent) break;\n          parent = target;\n        }\n\n        dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n        if (parent) {\n          do {\n            if (parent[expando]) {\n              var inserted = void 0;\n              inserted = parent[expando]._onDragOver({\n                clientX: touchEvt.clientX,\n                clientY: touchEvt.clientY,\n                target: target,\n                rootEl: parent\n              });\n\n              if (inserted && !this.options.dragoverBubble) {\n                break;\n              }\n            }\n\n            target = parent; // store last element\n          }\n          /* jshint boss:true */\n          while (parent = parent.parentNode);\n        }\n\n        _unhideGhostForTarget();\n      }\n    },\n    _onTouchMove: function _onTouchMove(\n    /**TouchEvent*/\n    evt) {\n      if (tapEvt) {\n        var options = this.options,\n            fallbackTolerance = options.fallbackTolerance,\n            fallbackOffset = options.fallbackOffset,\n            touch = evt.touches ? evt.touches[0] : evt,\n            ghostMatrix = ghostEl && matrix(ghostEl, true),\n            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n        if (!Sortable.active && !awaitingDragStarted) {\n          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n            return;\n          }\n\n          this._onDragStart(evt, true);\n        }\n\n        if (ghostEl) {\n          if (ghostMatrix) {\n            ghostMatrix.e += dx - (lastDx || 0);\n            ghostMatrix.f += dy - (lastDy || 0);\n          } else {\n            ghostMatrix = {\n              a: 1,\n              b: 0,\n              c: 0,\n              d: 1,\n              e: dx,\n              f: dy\n            };\n          }\n\n          var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n          css(ghostEl, 'webkitTransform', cssMatrix);\n          css(ghostEl, 'mozTransform', cssMatrix);\n          css(ghostEl, 'msTransform', cssMatrix);\n          css(ghostEl, 'transform', cssMatrix);\n          lastDx = dx;\n          lastDy = dy;\n          touchEvt = touch;\n        }\n\n        evt.cancelable && evt.preventDefault();\n      }\n    },\n    _appendGhost: function _appendGhost() {\n      // Bug if using scale(): https://stackoverflow.com/questions/2637058\n      // Not being adjusted for\n      if (!ghostEl) {\n        var container = this.options.fallbackOnBody ? document.body : rootEl,\n            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n            options = this.options; // Position absolutely\n\n        if (PositionGhostAbsolutely) {\n          // Get relatively positioned parent\n          ghostRelativeParent = container;\n\n          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n            ghostRelativeParent = ghostRelativeParent.parentNode;\n          }\n\n          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n            rect.top += ghostRelativeParent.scrollTop;\n            rect.left += ghostRelativeParent.scrollLeft;\n          } else {\n            ghostRelativeParent = getWindowScrollingElement();\n          }\n\n          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n        }\n\n        ghostEl = dragEl.cloneNode(true);\n        toggleClass(ghostEl, options.ghostClass, false);\n        toggleClass(ghostEl, options.fallbackClass, true);\n        toggleClass(ghostEl, options.dragClass, true);\n        css(ghostEl, 'transition', '');\n        css(ghostEl, 'transform', '');\n        css(ghostEl, 'box-sizing', 'border-box');\n        css(ghostEl, 'margin', 0);\n        css(ghostEl, 'top', rect.top);\n        css(ghostEl, 'left', rect.left);\n        css(ghostEl, 'width', rect.width);\n        css(ghostEl, 'height', rect.height);\n        css(ghostEl, 'opacity', '0.8');\n        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n        css(ghostEl, 'zIndex', '100000');\n        css(ghostEl, 'pointerEvents', 'none');\n        Sortable.ghost = ghostEl;\n        container.appendChild(ghostEl); // Set transform-origin\n\n        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n      }\n    },\n    _onDragStart: function _onDragStart(\n    /**Event*/\n    evt,\n    /**boolean*/\n    fallback) {\n      var _this = this;\n\n      var dataTransfer = evt.dataTransfer;\n      var options = _this.options;\n      pluginEvent('dragStart', this, {\n        evt: evt\n      });\n\n      if (Sortable.eventCanceled) {\n        this._onDrop();\n\n        return;\n      }\n\n      pluginEvent('setupClone', this);\n\n      if (!Sortable.eventCanceled) {\n        cloneEl = clone(dragEl);\n        cloneEl.draggable = false;\n        cloneEl.style['will-change'] = '';\n\n        this._hideClone();\n\n        toggleClass(cloneEl, this.options.chosenClass, false);\n        Sortable.clone = cloneEl;\n      } // #1143: IFrame support workaround\n\n\n      _this.cloneId = _nextTick(function () {\n        pluginEvent('clone', _this);\n        if (Sortable.eventCanceled) return;\n\n        if (!_this.options.removeCloneOnHide) {\n          rootEl.insertBefore(cloneEl, dragEl);\n        }\n\n        _this._hideClone();\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'clone'\n        });\n      });\n      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n      if (fallback) {\n        ignoreNextClick = true;\n        _this._loopId = setInterval(_this._emulateDragOver, 50);\n      } else {\n        // Undo what was set in _prepareDragStart before drag started\n        off(document, 'mouseup', _this._onDrop);\n        off(document, 'touchend', _this._onDrop);\n        off(document, 'touchcancel', _this._onDrop);\n\n        if (dataTransfer) {\n          dataTransfer.effectAllowed = 'move';\n          options.setData && options.setData.call(_this, dataTransfer, dragEl);\n        }\n\n        on(document, 'drop', _this); // #1276 fix:\n\n        css(dragEl, 'transform', 'translateZ(0)');\n      }\n\n      awaitingDragStarted = true;\n      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n      on(document, 'selectstart', _this);\n      moved = true;\n\n      if (Safari) {\n        css(document.body, 'user-select', 'none');\n      }\n    },\n    // Returns true - if no further action is needed (either inserted or another condition)\n    _onDragOver: function _onDragOver(\n    /**Event*/\n    evt) {\n      var el = this.el,\n          target = evt.target,\n          dragRect,\n          targetRect,\n          revert,\n          options = this.options,\n          group = options.group,\n          activeSortable = Sortable.active,\n          isOwner = activeGroup === group,\n          canSort = options.sort,\n          fromSortable = putSortable || activeSortable,\n          vertical,\n          _this = this,\n          completedFired = false;\n\n      if (_silent) return;\n\n      function dragOverEvent(name, extra) {\n        pluginEvent(name, _this, _objectSpread({\n          evt: evt,\n          isOwner: isOwner,\n          axis: vertical ? 'vertical' : 'horizontal',\n          revert: revert,\n          dragRect: dragRect,\n          targetRect: targetRect,\n          canSort: canSort,\n          fromSortable: fromSortable,\n          target: target,\n          completed: completed,\n          onMove: function onMove(target, after) {\n            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n          },\n          changed: changed\n        }, extra));\n      } // Capture animation state\n\n\n      function capture() {\n        dragOverEvent('dragOverAnimationCapture');\n\n        _this.captureAnimationState();\n\n        if (_this !== fromSortable) {\n          fromSortable.captureAnimationState();\n        }\n      } // Return invocation when dragEl is inserted (or completed)\n\n\n      function completed(insertion) {\n        dragOverEvent('dragOverCompleted', {\n          insertion: insertion\n        });\n\n        if (insertion) {\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n          if (isOwner) {\n            activeSortable._hideClone();\n          } else {\n            activeSortable._showClone(_this);\n          }\n\n          if (_this !== fromSortable) {\n            // Set ghost class to new sortable's ghost class\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n            toggleClass(dragEl, options.ghostClass, true);\n          }\n\n          if (putSortable !== _this && _this !== Sortable.active) {\n            putSortable = _this;\n          } else if (_this === Sortable.active && putSortable) {\n            putSortable = null;\n          } // Animation\n\n\n          if (fromSortable === _this) {\n            _this._ignoreWhileAnimating = target;\n          }\n\n          _this.animateAll(function () {\n            dragOverEvent('dragOverAnimationComplete');\n            _this._ignoreWhileAnimating = null;\n          });\n\n          if (_this !== fromSortable) {\n            fromSortable.animateAll();\n            fromSortable._ignoreWhileAnimating = null;\n          }\n        } // Null lastTarget if it is not inside a previously swapped element\n\n\n        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n          lastTarget = null;\n        } // no bubbling and not fallback\n\n\n        if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n          !insertion && nearestEmptyInsertDetectEvent(evt);\n        }\n\n        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n        return completedFired = true;\n      } // Call when dragEl has been inserted\n\n\n      function changed() {\n        newIndex = index(dragEl);\n        newDraggableIndex = index(dragEl, options.draggable);\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'change',\n          toEl: el,\n          newIndex: newIndex,\n          newDraggableIndex: newDraggableIndex,\n          originalEvent: evt\n        });\n      }\n\n      if (evt.preventDefault !== void 0) {\n        evt.cancelable && evt.preventDefault();\n      }\n\n      target = closest(target, options.draggable, el, true);\n      dragOverEvent('dragOver');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n        return completed(false);\n      }\n\n      ignoreNextClick = false;\n\n      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n        vertical = this._getDirection(evt, target) === 'vertical';\n        dragRect = getRect(dragEl);\n        dragOverEvent('dragOverValid');\n        if (Sortable.eventCanceled) return completedFired;\n\n        if (revert) {\n          parentEl = rootEl; // actualization\n\n          capture();\n\n          this._hideClone();\n\n          dragOverEvent('revert');\n\n          if (!Sortable.eventCanceled) {\n            if (nextEl) {\n              rootEl.insertBefore(dragEl, nextEl);\n            } else {\n              rootEl.appendChild(dragEl);\n            }\n          }\n\n          return completed(true);\n        }\n\n        var elLastChild = lastChild(el, options.draggable);\n\n        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n          // If already at end of list: Do not insert\n          if (elLastChild === dragEl) {\n            return completed(false);\n          } // assign target only if condition is true\n\n\n          if (elLastChild && el === evt.target) {\n            target = elLastChild;\n          }\n\n          if (target) {\n            targetRect = getRect(target);\n          }\n\n          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n            capture();\n            el.appendChild(dragEl);\n            parentEl = el; // actualization\n\n            changed();\n            return completed(true);\n          }\n        } else if (target.parentNode === el) {\n          targetRect = getRect(target);\n          var direction = 0,\n              targetBeforeFirstSwap,\n              differentLevel = dragEl.parentNode !== el,\n              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n              side1 = vertical ? 'top' : 'left',\n              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n          if (lastTarget !== target) {\n            targetBeforeFirstSwap = targetRect[side1];\n            pastFirstInvertThresh = false;\n            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n          }\n\n          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n          var sibling;\n\n          if (direction !== 0) {\n            // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n            var dragIndex = index(dragEl);\n\n            do {\n              dragIndex -= direction;\n              sibling = parentEl.children[dragIndex];\n            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n          } // If dragEl is already beside target: Do not insert\n\n\n          if (direction === 0 || sibling === target) {\n            return completed(false);\n          }\n\n          lastTarget = target;\n          lastDirection = direction;\n          var nextSibling = target.nextElementSibling,\n              after = false;\n          after = direction === 1;\n\n          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n          if (moveVector !== false) {\n            if (moveVector === 1 || moveVector === -1) {\n              after = moveVector === 1;\n            }\n\n            _silent = true;\n            setTimeout(_unsilent, 30);\n            capture();\n\n            if (after && !nextSibling) {\n              el.appendChild(dragEl);\n            } else {\n              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n            } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n            if (scrolledPastTop) {\n              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n            }\n\n            parentEl = dragEl.parentNode; // actualization\n            // must be done before animation\n\n            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n            }\n\n            changed();\n            return completed(true);\n          }\n        }\n\n        if (el.contains(dragEl)) {\n          return completed(false);\n        }\n      }\n\n      return false;\n    },\n    _ignoreWhileAnimating: null,\n    _offMoveEvents: function _offMoveEvents() {\n      off(document, 'mousemove', this._onTouchMove);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'pointermove', this._onTouchMove);\n      off(document, 'dragover', nearestEmptyInsertDetectEvent);\n      off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n      off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n    },\n    _offUpEvents: function _offUpEvents() {\n      var ownerDocument = this.el.ownerDocument;\n      off(ownerDocument, 'mouseup', this._onDrop);\n      off(ownerDocument, 'touchend', this._onDrop);\n      off(ownerDocument, 'pointerup', this._onDrop);\n      off(ownerDocument, 'touchcancel', this._onDrop);\n      off(document, 'selectstart', this);\n    },\n    _onDrop: function _onDrop(\n    /**Event*/\n    evt) {\n      var el = this.el,\n          options = this.options; // Get the index of the dragged element within its parent\n\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      pluginEvent('drop', this, {\n        evt: evt\n      });\n      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      if (Sortable.eventCanceled) {\n        this._nulling();\n\n        return;\n      }\n\n      awaitingDragStarted = false;\n      isCircumstantialInvert = false;\n      pastFirstInvertThresh = false;\n      clearInterval(this._loopId);\n      clearTimeout(this._dragStartTimer);\n\n      _cancelNextTick(this.cloneId);\n\n      _cancelNextTick(this._dragStartId); // Unbind events\n\n\n      if (this.nativeDraggable) {\n        off(document, 'drop', this);\n        off(el, 'dragstart', this._onDragStart);\n      }\n\n      this._offMoveEvents();\n\n      this._offUpEvents();\n\n      if (Safari) {\n        css(document.body, 'user-select', '');\n      }\n\n      css(dragEl, 'transform', '');\n\n      if (evt) {\n        if (moved) {\n          evt.cancelable && evt.preventDefault();\n          !options.dropBubble && evt.stopPropagation();\n        }\n\n        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n          // Remove clone(s)\n          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n        }\n\n        if (dragEl) {\n          if (this.nativeDraggable) {\n            off(dragEl, 'dragend', this);\n          }\n\n          _disableDraggable(dragEl);\n\n          dragEl.style['will-change'] = ''; // Remove classes\n          // ghostClass is added in dragStarted\n\n          if (moved && !awaitingDragStarted) {\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n          }\n\n          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'unchoose',\n            toEl: parentEl,\n            newIndex: null,\n            newDraggableIndex: null,\n            originalEvent: evt\n          });\n\n          if (rootEl !== parentEl) {\n            if (newIndex >= 0) {\n              // Add event\n              _dispatchEvent({\n                rootEl: parentEl,\n                name: 'add',\n                toEl: parentEl,\n                fromEl: rootEl,\n                originalEvent: evt\n              }); // Remove event\n\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'remove',\n                toEl: parentEl,\n                originalEvent: evt\n              }); // drag from one list and drop into another\n\n\n              _dispatchEvent({\n                rootEl: parentEl,\n                name: 'sort',\n                toEl: parentEl,\n                fromEl: rootEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n\n            putSortable && putSortable.save();\n          } else {\n            if (newIndex !== oldIndex) {\n              if (newIndex >= 0) {\n                // drag & drop within the same list\n                _dispatchEvent({\n                  sortable: this,\n                  name: 'update',\n                  toEl: parentEl,\n                  originalEvent: evt\n                });\n\n                _dispatchEvent({\n                  sortable: this,\n                  name: 'sort',\n                  toEl: parentEl,\n                  originalEvent: evt\n                });\n              }\n            }\n          }\n\n          if (Sortable.active) {\n            /* jshint eqnull:true */\n            if (newIndex == null || newIndex === -1) {\n              newIndex = oldIndex;\n              newDraggableIndex = oldDraggableIndex;\n            }\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'end',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // Save sorting\n\n\n            this.save();\n          }\n        }\n      }\n\n      this._nulling();\n    },\n    _nulling: function _nulling() {\n      pluginEvent('nulling', this);\n      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n      savedInputChecked.forEach(function (el) {\n        el.checked = true;\n      });\n      savedInputChecked.length = lastDx = lastDy = 0;\n    },\n    handleEvent: function handleEvent(\n    /**Event*/\n    evt) {\n      switch (evt.type) {\n        case 'drop':\n        case 'dragend':\n          this._onDrop(evt);\n\n          break;\n\n        case 'dragenter':\n        case 'dragover':\n          if (dragEl) {\n            this._onDragOver(evt);\n\n            _globalDragOver(evt);\n          }\n\n          break;\n\n        case 'selectstart':\n          evt.preventDefault();\n          break;\n      }\n    },\n\n    /**\n     * Serializes the item into an array of string.\n     * @returns {String[]}\n     */\n    toArray: function toArray() {\n      var order = [],\n          el,\n          children = this.el.children,\n          i = 0,\n          n = children.length,\n          options = this.options;\n\n      for (; i < n; i++) {\n        el = children[i];\n\n        if (closest(el, options.draggable, this.el, false)) {\n          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n        }\n      }\n\n      return order;\n    },\n\n    /**\n     * Sorts the elements according to the array.\n     * @param  {String[]}  order  order of the items\n     */\n    sort: function sort(order) {\n      var items = {},\n          rootEl = this.el;\n      this.toArray().forEach(function (id, i) {\n        var el = rootEl.children[i];\n\n        if (closest(el, this.options.draggable, rootEl, false)) {\n          items[id] = el;\n        }\n      }, this);\n      order.forEach(function (id) {\n        if (items[id]) {\n          rootEl.removeChild(items[id]);\n          rootEl.appendChild(items[id]);\n        }\n      });\n    },\n\n    /**\n     * Save the current sorting\n     */\n    save: function save() {\n      var store = this.options.store;\n      store && store.set && store.set(this);\n    },\n\n    /**\n     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n     * @param   {HTMLElement}  el\n     * @param   {String}       [selector]  default: `options.draggable`\n     * @returns {HTMLElement|null}\n     */\n    closest: function closest$1(el, selector) {\n      return closest(el, selector || this.options.draggable, this.el, false);\n    },\n\n    /**\n     * Set/get option\n     * @param   {string} name\n     * @param   {*}      [value]\n     * @returns {*}\n     */\n    option: function option(name, value) {\n      var options = this.options;\n\n      if (value === void 0) {\n        return options[name];\n      } else {\n        var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n        if (typeof modifiedValue !== 'undefined') {\n          options[name] = modifiedValue;\n        } else {\n          options[name] = value;\n        }\n\n        if (name === 'group') {\n          _prepareGroup(options);\n        }\n      }\n    },\n\n    /**\n     * Destroy\n     */\n    destroy: function destroy() {\n      pluginEvent('destroy', this);\n      var el = this.el;\n      el[expando] = null;\n      off(el, 'mousedown', this._onTapStart);\n      off(el, 'touchstart', this._onTapStart);\n      off(el, 'pointerdown', this._onTapStart);\n\n      if (this.nativeDraggable) {\n        off(el, 'dragover', this);\n        off(el, 'dragenter', this);\n      } // Remove draggable attributes\n\n\n      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n        el.removeAttribute('draggable');\n      });\n\n      this._onDrop();\n\n      this._disableDelayedDragEvents();\n\n      sortables.splice(sortables.indexOf(this.el), 1);\n      this.el = el = null;\n    },\n    _hideClone: function _hideClone() {\n      if (!cloneHidden) {\n        pluginEvent('hideClone', this);\n        if (Sortable.eventCanceled) return;\n        css(cloneEl, 'display', 'none');\n\n        if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n          cloneEl.parentNode.removeChild(cloneEl);\n        }\n\n        cloneHidden = true;\n      }\n    },\n    _showClone: function _showClone(putSortable) {\n      if (putSortable.lastPutMode !== 'clone') {\n        this._hideClone();\n\n        return;\n      }\n\n      if (cloneHidden) {\n        pluginEvent('showClone', this);\n        if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n        if (rootEl.contains(dragEl) && !this.options.group.revertClone) {\n          rootEl.insertBefore(cloneEl, dragEl);\n        } else if (nextEl) {\n          rootEl.insertBefore(cloneEl, nextEl);\n        } else {\n          rootEl.appendChild(cloneEl);\n        }\n\n        if (this.options.group.revertClone) {\n          this.animate(dragEl, cloneEl);\n        }\n\n        css(cloneEl, 'display', '');\n        cloneHidden = false;\n      }\n    }\n  };\n\n  function _globalDragOver(\n  /**Event*/\n  evt) {\n    if (evt.dataTransfer) {\n      evt.dataTransfer.dropEffect = 'move';\n    }\n\n    evt.cancelable && evt.preventDefault();\n  }\n\n  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n    var evt,\n        sortable = fromEl[expando],\n        onMoveFn = sortable.options.onMove,\n        retVal; // Support for new CustomEvent feature\n\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\n      evt = new CustomEvent('move', {\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      evt = document.createEvent('Event');\n      evt.initEvent('move', true, true);\n    }\n\n    evt.to = toEl;\n    evt.from = fromEl;\n    evt.dragged = dragEl;\n    evt.draggedRect = dragRect;\n    evt.related = targetEl || toEl;\n    evt.relatedRect = targetRect || getRect(toEl);\n    evt.willInsertAfter = willInsertAfter;\n    evt.originalEvent = originalEvent;\n    fromEl.dispatchEvent(evt);\n\n    if (onMoveFn) {\n      retVal = onMoveFn.call(sortable, evt, originalEvent);\n    }\n\n    return retVal;\n  }\n\n  function _disableDraggable(el) {\n    el.draggable = false;\n  }\n\n  function _unsilent() {\n    _silent = false;\n  }\n\n  function _ghostIsLast(evt, vertical, sortable) {\n    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n    var spacer = 10;\n    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n  }\n\n  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n        targetLength = vertical ? targetRect.height : targetRect.width,\n        targetS1 = vertical ? targetRect.top : targetRect.left,\n        targetS2 = vertical ? targetRect.bottom : targetRect.right,\n        invert = false;\n\n    if (!invertSwap) {\n      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n        // check if past first invert threshold on side opposite of lastDirection\n        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n          // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n          pastFirstInvertThresh = true;\n        }\n\n        if (!pastFirstInvertThresh) {\n          // dragEl shadow (target move distance shadow)\n          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n          : mouseOnAxis > targetS2 - targetMoveDistance) {\n            return -lastDirection;\n          }\n        } else {\n          invert = true;\n        }\n      } else {\n        // Regular\n        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n          return _getInsertDirection(target);\n        }\n      }\n    }\n\n    invert = invert || invertSwap;\n\n    if (invert) {\n      // Invert of regular\n      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * Gets the direction dragEl must be swapped relative to target in order to make it\n   * seem that dragEl has been \"inserted\" into that element's position\n   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n   * @return {Number}                   Direction dragEl must be swapped\n   */\n\n\n  function _getInsertDirection(target) {\n    if (index(dragEl) < index(target)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * Generate id\n   * @param   {HTMLElement} el\n   * @returns {String}\n   * @private\n   */\n\n\n  function _generateId(el) {\n    var str = el.tagName + el.className + el.src + el.href + el.textContent,\n        i = str.length,\n        sum = 0;\n\n    while (i--) {\n      sum += str.charCodeAt(i);\n    }\n\n    return sum.toString(36);\n  }\n\n  function _saveInputCheckedState(root) {\n    savedInputChecked.length = 0;\n    var inputs = root.getElementsByTagName('input');\n    var idx = inputs.length;\n\n    while (idx--) {\n      var el = inputs[idx];\n      el.checked && savedInputChecked.push(el);\n    }\n  }\n\n  function _nextTick(fn) {\n    return setTimeout(fn, 0);\n  }\n\n  function _cancelNextTick(id) {\n    return clearTimeout(id);\n  } // Fixed #973:\n\n\n  if (documentExists) {\n    on(document, 'touchmove', function (evt) {\n      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n        evt.preventDefault();\n      }\n    });\n  } // Export utils\n\n\n  Sortable.utils = {\n    on: on,\n    off: off,\n    css: css,\n    find: find,\n    is: function is(el, selector) {\n      return !!closest(el, selector, el, false);\n    },\n    extend: extend,\n    throttle: throttle,\n    closest: closest,\n    toggleClass: toggleClass,\n    clone: clone,\n    index: index,\n    nextTick: _nextTick,\n    cancelNextTick: _cancelNextTick,\n    detectDirection: _detectDirection,\n    getChild: getChild\n  };\n  /**\n   * Get the Sortable instance of an element\n   * @param  {HTMLElement} element The element\n   * @return {Sortable|undefined}         The instance of Sortable\n   */\n\n  Sortable.get = function (element) {\n    return element[expando];\n  };\n  /**\n   * Mount a plugin to Sortable\n   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n   */\n\n\n  Sortable.mount = function () {\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n\n    if (plugins[0].constructor === Array) plugins = plugins[0];\n    plugins.forEach(function (plugin) {\n      if (!plugin.prototype || !plugin.prototype.constructor) {\n        throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n      }\n\n      if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);\n      PluginManager.mount(plugin);\n    });\n  };\n  /**\n   * Create sortable instance\n   * @param {HTMLElement}  el\n   * @param {Object}      [options]\n   */\n\n\n  Sortable.create = function (el, options) {\n    return new Sortable(el, options);\n  }; // Export\n\n\n  Sortable.version = version;\n\n  var autoScrolls = [],\n      scrollEl,\n      scrollRootEl,\n      scrolling = false,\n      lastAutoScrollX,\n      lastAutoScrollY,\n      touchEvt$1,\n      pointerElemChangedInterval;\n\n  function AutoScrollPlugin() {\n    function AutoScroll() {\n      this.defaults = {\n        scroll: true,\n        scrollSensitivity: 30,\n        scrollSpeed: 10,\n        bubbleScroll: true\n      }; // Bind all private methods\n\n      for (var fn in this) {\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n          this[fn] = this[fn].bind(this);\n        }\n      }\n    }\n\n    AutoScroll.prototype = {\n      dragStarted: function dragStarted(_ref) {\n        var originalEvent = _ref.originalEvent;\n\n        if (this.sortable.nativeDraggable) {\n          on(document, 'dragover', this._handleAutoScroll);\n        } else {\n          if (this.options.supportPointer) {\n            on(document, 'pointermove', this._handleFallbackAutoScroll);\n          } else if (originalEvent.touches) {\n            on(document, 'touchmove', this._handleFallbackAutoScroll);\n          } else {\n            on(document, 'mousemove', this._handleFallbackAutoScroll);\n          }\n        }\n      },\n      dragOverCompleted: function dragOverCompleted(_ref2) {\n        var originalEvent = _ref2.originalEvent;\n\n        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n        if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n          this._handleAutoScroll(originalEvent);\n        }\n      },\n      drop: function drop() {\n        if (this.sortable.nativeDraggable) {\n          off(document, 'dragover', this._handleAutoScroll);\n        } else {\n          off(document, 'pointermove', this._handleFallbackAutoScroll);\n          off(document, 'touchmove', this._handleFallbackAutoScroll);\n          off(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n\n        clearPointerElemChangedInterval();\n        clearAutoScrolls();\n        cancelThrottle();\n      },\n      nulling: function nulling() {\n        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n        autoScrolls.length = 0;\n      },\n      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n        this._handleAutoScroll(evt, true);\n      },\n      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n        var _this = this;\n\n        var x = (evt.touches ? evt.touches[0] : evt).clientX,\n            y = (evt.touches ? evt.touches[0] : evt).clientY,\n            elem = document.elementFromPoint(x, y);\n        touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n        // Edge's autoscroll seems too conditional,\n        // MACOS Safari does not have autoscroll,\n        // Firefox and Chrome are good\n\n        if (fallback || Edge || IE11OrLess || Safari) {\n          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n          var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n            pointerElemChangedInterval = setInterval(function () {\n              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n              if (newElem !== ogElemScroller) {\n                ogElemScroller = newElem;\n                clearAutoScrolls();\n              }\n\n              autoScroll(evt, _this.options, newElem, fallback);\n            }, 10);\n            lastAutoScrollX = x;\n            lastAutoScrollY = y;\n          }\n        } else {\n          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n            clearAutoScrolls();\n            return;\n          }\n\n          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n        }\n      }\n    };\n    return _extends(AutoScroll, {\n      pluginName: 'scroll',\n      initializeByDefault: true\n    });\n  }\n\n  function clearAutoScrolls() {\n    autoScrolls.forEach(function (autoScroll) {\n      clearInterval(autoScroll.pid);\n    });\n    autoScrolls = [];\n  }\n\n  function clearPointerElemChangedInterval() {\n    clearInterval(pointerElemChangedInterval);\n  }\n\n  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n    if (!options.scroll) return;\n    var x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        sens = options.scrollSensitivity,\n        speed = options.scrollSpeed,\n        winScroller = getWindowScrollingElement();\n    var scrollThisInstance = false,\n        scrollCustomFn; // New scroll root, set scrollEl\n\n    if (scrollRootEl !== rootEl) {\n      scrollRootEl = rootEl;\n      clearAutoScrolls();\n      scrollEl = options.scroll;\n      scrollCustomFn = options.scrollFn;\n\n      if (scrollEl === true) {\n        scrollEl = getParentAutoScrollElement(rootEl, true);\n      }\n    }\n\n    var layersOut = 0;\n    var currentParent = scrollEl;\n\n    do {\n      var el = currentParent,\n          rect = getRect(el),\n          top = rect.top,\n          bottom = rect.bottom,\n          left = rect.left,\n          right = rect.right,\n          width = rect.width,\n          height = rect.height,\n          canScrollX = void 0,\n          canScrollY = void 0,\n          scrollWidth = el.scrollWidth,\n          scrollHeight = el.scrollHeight,\n          elCSS = css(el),\n          scrollPosX = el.scrollLeft,\n          scrollPosY = el.scrollTop;\n\n      if (el === winScroller) {\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n      } else {\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n      }\n\n      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n      if (!autoScrolls[layersOut]) {\n        for (var i = 0; i <= layersOut; i++) {\n          if (!autoScrolls[i]) {\n            autoScrolls[i] = {};\n          }\n        }\n      }\n\n      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n        autoScrolls[layersOut].el = el;\n        autoScrolls[layersOut].vx = vx;\n        autoScrolls[layersOut].vy = vy;\n        clearInterval(autoScrolls[layersOut].pid);\n\n        if (vx != 0 || vy != 0) {\n          scrollThisInstance = true;\n          /* jshint loopfunc:true */\n\n          autoScrolls[layersOut].pid = setInterval(function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n            }\n\n            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n            if (typeof scrollCustomFn === 'function') {\n              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({\n            layer: layersOut\n          }), 24);\n        }\n      }\n\n      layersOut++;\n    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n  }, 30);\n\n  var drop = function drop(_ref) {\n    var originalEvent = _ref.originalEvent,\n        putSortable = _ref.putSortable,\n        dragEl = _ref.dragEl,\n        activeSortable = _ref.activeSortable,\n        dispatchSortableEvent = _ref.dispatchSortableEvent,\n        hideGhostForTarget = _ref.hideGhostForTarget,\n        unhideGhostForTarget = _ref.unhideGhostForTarget;\n    if (!originalEvent) return;\n    var toSortable = putSortable || activeSortable;\n    hideGhostForTarget();\n    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n    var target = document.elementFromPoint(touch.clientX, touch.clientY);\n    unhideGhostForTarget();\n\n    if (toSortable && !toSortable.el.contains(target)) {\n      dispatchSortableEvent('spill');\n      this.onSpill({\n        dragEl: dragEl,\n        putSortable: putSortable\n      });\n    }\n  };\n\n  function Revert() {}\n\n  Revert.prototype = {\n    startIndex: null,\n    dragStart: function dragStart(_ref2) {\n      var oldDraggableIndex = _ref2.oldDraggableIndex;\n      this.startIndex = oldDraggableIndex;\n    },\n    onSpill: function onSpill(_ref3) {\n      var dragEl = _ref3.dragEl,\n          putSortable = _ref3.putSortable;\n      this.sortable.captureAnimationState();\n\n      if (putSortable) {\n        putSortable.captureAnimationState();\n      }\n\n      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n      if (nextSibling) {\n        this.sortable.el.insertBefore(dragEl, nextSibling);\n      } else {\n        this.sortable.el.appendChild(dragEl);\n      }\n\n      this.sortable.animateAll();\n\n      if (putSortable) {\n        putSortable.animateAll();\n      }\n    },\n    drop: drop\n  };\n\n  _extends(Revert, {\n    pluginName: 'revertOnSpill'\n  });\n\n  function Remove() {}\n\n  Remove.prototype = {\n    onSpill: function onSpill(_ref4) {\n      var dragEl = _ref4.dragEl,\n          putSortable = _ref4.putSortable;\n      var parentSortable = putSortable || this.sortable;\n      parentSortable.captureAnimationState();\n      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n      parentSortable.animateAll();\n    },\n    drop: drop\n  };\n\n  _extends(Remove, {\n    pluginName: 'removeOnSpill'\n  });\n\n  var lastSwapEl;\n\n  function SwapPlugin() {\n    function Swap() {\n      this.defaults = {\n        swapClass: 'sortable-swap-highlight'\n      };\n    }\n\n    Swap.prototype = {\n      dragStart: function dragStart(_ref) {\n        var dragEl = _ref.dragEl;\n        lastSwapEl = dragEl;\n      },\n      dragOverValid: function dragOverValid(_ref2) {\n        var completed = _ref2.completed,\n            target = _ref2.target,\n            onMove = _ref2.onMove,\n            activeSortable = _ref2.activeSortable,\n            changed = _ref2.changed,\n            cancel = _ref2.cancel;\n        if (!activeSortable.options.swap) return;\n        var el = this.sortable.el,\n            options = this.options;\n\n        if (target && target !== el) {\n          var prevSwapEl = lastSwapEl;\n\n          if (onMove(target) !== false) {\n            toggleClass(target, options.swapClass, true);\n            lastSwapEl = target;\n          } else {\n            lastSwapEl = null;\n          }\n\n          if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n            toggleClass(prevSwapEl, options.swapClass, false);\n          }\n        }\n\n        changed();\n        completed(true);\n        cancel();\n      },\n      drop: function drop(_ref3) {\n        var activeSortable = _ref3.activeSortable,\n            putSortable = _ref3.putSortable,\n            dragEl = _ref3.dragEl;\n        var toSortable = putSortable || this.sortable;\n        var options = this.options;\n        lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n        if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n          if (dragEl !== lastSwapEl) {\n            toSortable.captureAnimationState();\n            if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n            swapNodes(dragEl, lastSwapEl);\n            toSortable.animateAll();\n            if (toSortable !== activeSortable) activeSortable.animateAll();\n          }\n        }\n      },\n      nulling: function nulling() {\n        lastSwapEl = null;\n      }\n    };\n    return _extends(Swap, {\n      pluginName: 'swap',\n      eventProperties: function eventProperties() {\n        return {\n          swapItem: lastSwapEl\n        };\n      }\n    });\n  }\n\n  function swapNodes(n1, n2) {\n    var p1 = n1.parentNode,\n        p2 = n2.parentNode,\n        i1,\n        i2;\n    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n    i1 = index(n1);\n    i2 = index(n2);\n\n    if (p1.isEqualNode(p2) && i1 < i2) {\n      i2++;\n    }\n\n    p1.insertBefore(n2, p1.children[i1]);\n    p2.insertBefore(n1, p2.children[i2]);\n  }\n\n  var multiDragElements = [],\n      multiDragClones = [],\n      lastMultiDragSelect,\n      // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n      initialFolding = false,\n      // Initial multi-drag fold when drag started\n  folding = false,\n      // Folding any other time\n  dragStarted = false,\n      dragEl$1,\n      clonesFromRect,\n      clonesHidden;\n\n  function MultiDragPlugin() {\n    function MultiDrag(sortable) {\n      // Bind all private methods\n      for (var fn in this) {\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n          this[fn] = this[fn].bind(this);\n        }\n      }\n\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n\n      on(document, 'keydown', this._checkKeyDown);\n      on(document, 'keyup', this._checkKeyUp);\n      this.defaults = {\n        selectedClass: 'sortable-selected',\n        multiDragKey: null,\n        setData: function setData(dataTransfer, dragEl) {\n          var data = '';\n\n          if (multiDragElements.length && multiDragSortable === sortable) {\n            multiDragElements.forEach(function (multiDragElement, i) {\n              data += (!i ? '' : ', ') + multiDragElement.textContent;\n            });\n          } else {\n            data = dragEl.textContent;\n          }\n\n          dataTransfer.setData('Text', data);\n        }\n      };\n    }\n\n    MultiDrag.prototype = {\n      multiDragKeyDown: false,\n      isMultiDrag: false,\n      delayStartGlobal: function delayStartGlobal(_ref) {\n        var dragged = _ref.dragEl;\n        dragEl$1 = dragged;\n      },\n      delayEnded: function delayEnded() {\n        this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n      },\n      setupClone: function setupClone(_ref2) {\n        var sortable = _ref2.sortable,\n            cancel = _ref2.cancel;\n        if (!this.isMultiDrag) return;\n\n        for (var i = 0; i < multiDragElements.length; i++) {\n          multiDragClones.push(clone(multiDragElements[i]));\n          multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n          multiDragClones[i].draggable = false;\n          multiDragClones[i].style['will-change'] = '';\n          toggleClass(multiDragClones[i], this.options.selectedClass, false);\n          multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n        }\n\n        sortable._hideClone();\n\n        cancel();\n      },\n      clone: function clone(_ref3) {\n        var sortable = _ref3.sortable,\n            rootEl = _ref3.rootEl,\n            dispatchSortableEvent = _ref3.dispatchSortableEvent,\n            cancel = _ref3.cancel;\n        if (!this.isMultiDrag) return;\n\n        if (!this.options.removeCloneOnHide) {\n          if (multiDragElements.length && multiDragSortable === sortable) {\n            insertMultiDragClones(true, rootEl);\n            dispatchSortableEvent('clone');\n            cancel();\n          }\n        }\n      },\n      showClone: function showClone(_ref4) {\n        var cloneNowShown = _ref4.cloneNowShown,\n            rootEl = _ref4.rootEl,\n            cancel = _ref4.cancel;\n        if (!this.isMultiDrag) return;\n        insertMultiDragClones(false, rootEl);\n        multiDragClones.forEach(function (clone) {\n          css(clone, 'display', '');\n        });\n        cloneNowShown();\n        clonesHidden = false;\n        cancel();\n      },\n      hideClone: function hideClone(_ref5) {\n        var _this = this;\n\n        var sortable = _ref5.sortable,\n            cloneNowHidden = _ref5.cloneNowHidden,\n            cancel = _ref5.cancel;\n        if (!this.isMultiDrag) return;\n        multiDragClones.forEach(function (clone) {\n          css(clone, 'display', 'none');\n\n          if (_this.options.removeCloneOnHide && clone.parentNode) {\n            clone.parentNode.removeChild(clone);\n          }\n        });\n        cloneNowHidden();\n        clonesHidden = true;\n        cancel();\n      },\n      dragStartGlobal: function dragStartGlobal(_ref6) {\n        var sortable = _ref6.sortable;\n\n        if (!this.isMultiDrag && multiDragSortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n        }\n\n        multiDragElements.forEach(function (multiDragElement) {\n          multiDragElement.sortableIndex = index(multiDragElement);\n        }); // Sort multi-drag elements\n\n        multiDragElements = multiDragElements.sort(function (a, b) {\n          return a.sortableIndex - b.sortableIndex;\n        });\n        dragStarted = true;\n      },\n      dragStarted: function dragStarted(_ref7) {\n        var _this2 = this;\n\n        var sortable = _ref7.sortable;\n        if (!this.isMultiDrag) return;\n\n        if (this.options.sort) {\n          // Capture rects,\n          // hide multi drag elements (by positioning them absolute),\n          // set multi drag elements rects to dragRect,\n          // show multi drag elements,\n          // animate to rects,\n          // unset rects & remove from DOM\n          sortable.captureAnimationState();\n\n          if (this.options.animation) {\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              css(multiDragElement, 'position', 'absolute');\n            });\n            var dragRect = getRect(dragEl$1, false, true, true);\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              setRect(multiDragElement, dragRect);\n            });\n            folding = true;\n            initialFolding = true;\n          }\n        }\n\n        sortable.animateAll(function () {\n          folding = false;\n          initialFolding = false;\n\n          if (_this2.options.animation) {\n            multiDragElements.forEach(function (multiDragElement) {\n              unsetRect(multiDragElement);\n            });\n          } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n          if (_this2.options.sort) {\n            removeMultiDragElements();\n          }\n        });\n      },\n      dragOver: function dragOver(_ref8) {\n        var target = _ref8.target,\n            completed = _ref8.completed,\n            cancel = _ref8.cancel;\n\n        if (folding && ~multiDragElements.indexOf(target)) {\n          completed(false);\n          cancel();\n        }\n      },\n      revert: function revert(_ref9) {\n        var fromSortable = _ref9.fromSortable,\n            rootEl = _ref9.rootEl,\n            sortable = _ref9.sortable,\n            dragRect = _ref9.dragRect;\n\n        if (multiDragElements.length > 1) {\n          // Setup unfold animation\n          multiDragElements.forEach(function (multiDragElement) {\n            sortable.addAnimationState({\n              target: multiDragElement,\n              rect: folding ? getRect(multiDragElement) : dragRect\n            });\n            unsetRect(multiDragElement);\n            multiDragElement.fromRect = dragRect;\n            fromSortable.removeAnimationState(multiDragElement);\n          });\n          folding = false;\n          insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n        }\n      },\n      dragOverCompleted: function dragOverCompleted(_ref10) {\n        var sortable = _ref10.sortable,\n            isOwner = _ref10.isOwner,\n            insertion = _ref10.insertion,\n            activeSortable = _ref10.activeSortable,\n            parentEl = _ref10.parentEl,\n            putSortable = _ref10.putSortable;\n        var options = this.options;\n\n        if (insertion) {\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n          if (isOwner) {\n            activeSortable._hideClone();\n          }\n\n          initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n          if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n            // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n            var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n              // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n              parentEl.appendChild(multiDragElement);\n            });\n            folding = true;\n          } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n          if (!isOwner) {\n            // Only remove if not folding (folding will remove them anyways)\n            if (!folding) {\n              removeMultiDragElements();\n            }\n\n            if (multiDragElements.length > 1) {\n              var clonesHiddenBefore = clonesHidden;\n\n              activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n              if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n                multiDragClones.forEach(function (clone) {\n                  activeSortable.addAnimationState({\n                    target: clone,\n                    rect: clonesFromRect\n                  });\n                  clone.fromRect = clonesFromRect;\n                  clone.thisAnimationDuration = null;\n                });\n              }\n            } else {\n              activeSortable._showClone(sortable);\n            }\n          }\n        }\n      },\n      dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n        var dragRect = _ref11.dragRect,\n            isOwner = _ref11.isOwner,\n            activeSortable = _ref11.activeSortable;\n        multiDragElements.forEach(function (multiDragElement) {\n          multiDragElement.thisAnimationDuration = null;\n        });\n\n        if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n          clonesFromRect = _extends({}, dragRect);\n          var dragMatrix = matrix(dragEl$1, true);\n          clonesFromRect.top -= dragMatrix.f;\n          clonesFromRect.left -= dragMatrix.e;\n        }\n      },\n      dragOverAnimationComplete: function dragOverAnimationComplete() {\n        if (folding) {\n          folding = false;\n          removeMultiDragElements();\n        }\n      },\n      drop: function drop(_ref12) {\n        var evt = _ref12.originalEvent,\n            rootEl = _ref12.rootEl,\n            parentEl = _ref12.parentEl,\n            sortable = _ref12.sortable,\n            dispatchSortableEvent = _ref12.dispatchSortableEvent,\n            oldIndex = _ref12.oldIndex,\n            putSortable = _ref12.putSortable;\n        var toSortable = putSortable || this.sortable;\n        if (!evt) return;\n        var options = this.options,\n            children = parentEl.children; // Multi-drag selection\n\n        if (!dragStarted) {\n          if (options.multiDragKey && !this.multiDragKeyDown) {\n            this._deselectMultiDrag();\n          }\n\n          toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n          if (!~multiDragElements.indexOf(dragEl$1)) {\n            multiDragElements.push(dragEl$1);\n            dispatchEvent({\n              sortable: sortable,\n              rootEl: rootEl,\n              name: 'select',\n              targetEl: dragEl$1,\n              originalEvt: evt\n            }); // Modifier activated, select from last to dragEl\n\n            if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n              var lastIndex = index(lastMultiDragSelect),\n                  currentIndex = index(dragEl$1);\n\n              if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n                // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n                // (but previous selection existed)\n                var n, i;\n\n                if (currentIndex > lastIndex) {\n                  i = lastIndex;\n                  n = currentIndex;\n                } else {\n                  i = currentIndex;\n                  n = lastIndex + 1;\n                }\n\n                for (; i < n; i++) {\n                  if (~multiDragElements.indexOf(children[i])) continue;\n                  toggleClass(children[i], options.selectedClass, true);\n                  multiDragElements.push(children[i]);\n                  dispatchEvent({\n                    sortable: sortable,\n                    rootEl: rootEl,\n                    name: 'select',\n                    targetEl: children[i],\n                    originalEvt: evt\n                  });\n                }\n              }\n            } else {\n              lastMultiDragSelect = dragEl$1;\n            }\n\n            multiDragSortable = toSortable;\n          } else {\n            multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n            lastMultiDragSelect = null;\n            dispatchEvent({\n              sortable: sortable,\n              rootEl: rootEl,\n              name: 'deselect',\n              targetEl: dragEl$1,\n              originalEvt: evt\n            });\n          }\n        } // Multi-drag drop\n\n\n        if (dragStarted && this.isMultiDrag) {\n          // Do not \"unfold\" after around dragEl if reverted\n          if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n            var dragRect = getRect(dragEl$1),\n                multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n            if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n            toSortable.captureAnimationState();\n\n            if (!initialFolding) {\n              if (options.animation) {\n                dragEl$1.fromRect = dragRect;\n                multiDragElements.forEach(function (multiDragElement) {\n                  multiDragElement.thisAnimationDuration = null;\n\n                  if (multiDragElement !== dragEl$1) {\n                    var rect = folding ? getRect(multiDragElement) : dragRect;\n                    multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                    toSortable.addAnimationState({\n                      target: multiDragElement,\n                      rect: rect\n                    });\n                  }\n                });\n              } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n              // properly they must all be removed\n\n\n              removeMultiDragElements();\n              multiDragElements.forEach(function (multiDragElement) {\n                if (children[multiDragIndex]) {\n                  parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n                } else {\n                  parentEl.appendChild(multiDragElement);\n                }\n\n                multiDragIndex++;\n              }); // If initial folding is done, the elements may have changed position because they are now\n              // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n              // must be fired here as Sortable will not.\n\n              if (oldIndex === index(dragEl$1)) {\n                var update = false;\n                multiDragElements.forEach(function (multiDragElement) {\n                  if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                    update = true;\n                    return;\n                  }\n                });\n\n                if (update) {\n                  dispatchSortableEvent('update');\n                }\n              }\n            } // Must be done after capturing individual rects (scroll bar)\n\n\n            multiDragElements.forEach(function (multiDragElement) {\n              unsetRect(multiDragElement);\n            });\n            toSortable.animateAll();\n          }\n\n          multiDragSortable = toSortable;\n        } // Remove clones if necessary\n\n\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n          multiDragClones.forEach(function (clone) {\n            clone.parentNode && clone.parentNode.removeChild(clone);\n          });\n        }\n      },\n      nullingGlobal: function nullingGlobal() {\n        this.isMultiDrag = dragStarted = false;\n        multiDragClones.length = 0;\n      },\n      destroyGlobal: function destroyGlobal() {\n        this._deselectMultiDrag();\n\n        off(document, 'pointerup', this._deselectMultiDrag);\n        off(document, 'mouseup', this._deselectMultiDrag);\n        off(document, 'touchend', this._deselectMultiDrag);\n        off(document, 'keydown', this._checkKeyDown);\n        off(document, 'keyup', this._checkKeyUp);\n      },\n      _deselectMultiDrag: function _deselectMultiDrag(evt) {\n        if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n        if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n        if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n        if (evt && evt.button !== 0) return;\n\n        while (multiDragElements.length) {\n          var el = multiDragElements[0];\n          toggleClass(el, this.options.selectedClass, false);\n          multiDragElements.shift();\n          dispatchEvent({\n            sortable: this.sortable,\n            rootEl: this.sortable.el,\n            name: 'deselect',\n            targetEl: el,\n            originalEvt: evt\n          });\n        }\n      },\n      _checkKeyDown: function _checkKeyDown(evt) {\n        if (evt.key === this.options.multiDragKey) {\n          this.multiDragKeyDown = true;\n        }\n      },\n      _checkKeyUp: function _checkKeyUp(evt) {\n        if (evt.key === this.options.multiDragKey) {\n          this.multiDragKeyDown = false;\n        }\n      }\n    };\n    return _extends(MultiDrag, {\n      // Static methods & properties\n      pluginName: 'multiDrag',\n      utils: {\n        /**\r\n         * Selects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be selected\r\n         */\n        select: function select(el) {\n          var sortable = el.parentNode[expando];\n          if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n          if (multiDragSortable && multiDragSortable !== sortable) {\n            multiDragSortable.multiDrag._deselectMultiDrag();\n\n            multiDragSortable = sortable;\n          }\n\n          toggleClass(el, sortable.options.selectedClass, true);\n          multiDragElements.push(el);\n        },\n\n        /**\r\n         * Deselects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be deselected\r\n         */\n        deselect: function deselect(el) {\n          var sortable = el.parentNode[expando],\n              index = multiDragElements.indexOf(el);\n          if (!sortable || !sortable.options.multiDrag || !~index) return;\n          toggleClass(el, sortable.options.selectedClass, false);\n          multiDragElements.splice(index, 1);\n        }\n      },\n      eventProperties: function eventProperties() {\n        var _this3 = this;\n\n        var oldIndicies = [],\n            newIndicies = [];\n        multiDragElements.forEach(function (multiDragElement) {\n          oldIndicies.push({\n            multiDragElement: multiDragElement,\n            index: multiDragElement.sortableIndex\n          }); // multiDragElements will already be sorted if folding\n\n          var newIndex;\n\n          if (folding && multiDragElement !== dragEl$1) {\n            newIndex = -1;\n          } else if (folding) {\n            newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n          } else {\n            newIndex = index(multiDragElement);\n          }\n\n          newIndicies.push({\n            multiDragElement: multiDragElement,\n            index: newIndex\n          });\n        });\n        return {\n          items: _toConsumableArray(multiDragElements),\n          clones: [].concat(multiDragClones),\n          oldIndicies: oldIndicies,\n          newIndicies: newIndicies\n        };\n      },\n      optionListeners: {\n        multiDragKey: function multiDragKey(key) {\n          key = key.toLowerCase();\n\n          if (key === 'ctrl') {\n            key = 'Control';\n          } else if (key.length > 1) {\n            key = key.charAt(0).toUpperCase() + key.substr(1);\n          }\n\n          return key;\n        }\n      }\n    });\n  }\n\n  function insertMultiDragElements(clonesInserted, rootEl) {\n    multiDragElements.forEach(function (multiDragElement, i) {\n      var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n      if (target) {\n        rootEl.insertBefore(multiDragElement, target);\n      } else {\n        rootEl.appendChild(multiDragElement);\n      }\n    });\n  }\n  /**\r\n   * Insert multi-drag clones\r\n   * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n   * @param  {HTMLElement} rootEl\r\n   */\n\n\n  function insertMultiDragClones(elementsInserted, rootEl) {\n    multiDragClones.forEach(function (clone, i) {\n      var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n      if (target) {\n        rootEl.insertBefore(clone, target);\n      } else {\n        rootEl.appendChild(clone);\n      }\n    });\n  }\n\n  function removeMultiDragElements() {\n    multiDragElements.forEach(function (multiDragElement) {\n      if (multiDragElement === dragEl$1) return;\n      multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n    });\n  }\n\n  Sortable.mount(new AutoScrollPlugin());\n  Sortable.mount(Remove, Revert);\n\n  Sortable.mount(new SwapPlugin());\n  Sortable.mount(new MultiDragPlugin());\n\n  return Sortable;\n\n}));\n","import * as utils from './modules/utils.mjs'\nimport * as search from './modules/search.mjs'\nimport togglePreferences from './modules/togglePreferences.mjs'\nimport urgentAnnouncement from './web-components/urgent-announcement.mjs'\nimport { WC_announcementsWidget } from './web-components/announcements.mjs'\nimport * as unreadAnnouncements from './modules/unreadAnnouncements.mjs'\n\nconst page = document.querySelector('main').id.toLowerCase()\n\n//init web components\nif (page === 'dashboard') {\n    utils.appendWidgets(utils.getPreferences())\n}\n\nif (page === 'account') {\n    togglePreferences()\n}\n\nif (page === 'announcements-overview') {\n    const announcementList = document.getElementById('announcements')\n    announcementList.remove()\n    document.querySelector('main section').append(document.createElement('announcements-widget'))\n    WC_announcementsWidget(page)\n}\n\n\n//check if browser is online\nif (navigator.onLine) {\n    //urgent announcements\n    const socket = io()\n\n    //subscribe to urgent-announcements\n    socket.emit('join', page)\n\n    //on urgent-announcement hook update interface (see WC_urgentAnnouncement)\n    socket.on('urgent-announcement', announcement => {\n        const urgentAnnouncement = document.querySelector('urgent-announcement')\n\n        if (utils.exists([urgentAnnouncement])) {\n            urgentAnnouncement.setAttribute('message', announcement.title)\n            urgentAnnouncement.setAttribute('uid', announcement.newsItemId)\n        }\n    })\n}\n\n\n\n\n//menu \nconst menuIcon = document.getElementById('menu-icon')\nconst menu = document.getElementById('menu')\n\nif (utils.exists([menuIcon, menu])) {\n\n    //toggle menu (on mobile)\n    menuIcon.addEventListener('click', () => {\n        menu.classList.toggle('hide')\n    })\n}\n\n\n\n\n//search \nconst searchBar = document.getElementById('search-bar')\nconst searchResetIcon = document.getElementById('search-reset')\nconst searchIcon = document.querySelector('#search-container input[type=submit]')\n\nif (utils.exists([searchBar, searchResetIcon, searchIcon])) {\n\n    //control search-reset icon \n    searchBar.addEventListener('focus', () => search.showReset())\n    searchBar.addEventListener('blur', () => search.hideReset())\n\n\n    //reset search input\n    searchResetIcon.addEventListener('click', e => search.reset(e))\n\n\n    //depending on search-query either give focus to searchbar or submit search-query\n    searchIcon.addEventListener('click', e => {\n        if (searchBar.value === \"\") {\n            search.focus(e)\n        }\n    })\n\n\n    //listen to keyboard input\n    document.addEventListener('keypress', e => {\n        switch (e.key) {\n            case \"/\":\n                search.focus(e) //give searchbar focus and hide search-reset icon\n                break\n        }\n    })\n}\n\n\n//unread announcement indicator in menu\nconst announcementMenuItem = document.querySelector('#menu-primary-links a:last-of-type')\n\nif (utils.exists([announcementMenuItem]) && utils.storageAvailable('localStorage')) {\n    unreadAnnouncements.indicate(announcementMenuItem)\n}","const searchBar = document.getElementById('search-bar')\nconst searchResetIcon = document.getElementById('search-reset')\n\nexport function focus(e) {\n    e.preventDefault()\n    searchBar.focus()\n}\n\nexport function showReset() {\n    searchResetIcon.classList.remove('hide')\n}\n\nexport function hideReset() {\n    if (searchBar.value === \"\") {\n        searchResetIcon.classList.add('hide')\n    }\n}\n\nexport function reset(e) {\n    searchBar.value = \"\"\n    focus(e)\n}","import { setLocalStorage, getLocalStorage } from '../modules/utils.mjs'\nimport Sortable from 'sortablejs'\n\nconst container = document.querySelector('#account form')\nexport default function togglePreferences() {\n    container.classList.remove('disabled')\n\n    setPreferences()\n    stateHandler()\n    dragHandler()\n}\n\nfunction setPreferences() {\n    const preferences = getLocalStorage('preferences')\n    if (preferences) {\n        container.textContent = ''\n        preferences.forEach(preference => container.append(createLabels(preference)))\n    } else {\n        setPreferencesObject()\n    }\n}\n\nfunction dragHandler() {\n    const preferencesContainer = document.querySelector('#preferences')\n\n    new Sortable(preferencesContainer, {\n        animation: 150,\n        onEnd: () => setPreferencesObject()\n    })\n}\n\n// Saving and changing preferences \nfunction setPreferencesObject() {\n    const inputs = [...document.querySelectorAll('#account form label')]\n    let preferences = []\n\n    inputs.forEach(label => {\n        // Data\n        const id = label.id\n        const text = label.textContent\n        const state = label.querySelector('input').checked\n\n        // Set LocalStorage\n        const object = { id: id, name: text, state: state }\n        preferences.push(object)\n        setLocalStorage('preferences', preferences)\n    })\n\n    return preferences\n}\n\nfunction stateHandler() {\n    const inputs = [...document.querySelectorAll('#account form label')]\n    const data = getLocalStorage('preferences')\n\n    inputs.forEach(label => {\n        updateState(data, label)\n\n        label.addEventListener('change', event => {\n            // Data\n            const id = label.id\n            const state = event.target.checked\n\n            // Change LocalStorage\n            const preference = data.find(preference => preference.id === id)\n            preference.state = state\n            setLocalStorage('preferences', data)\n\n            // Change state visualy\n            preference.state === false ? label.classList.add('off') : label.classList.remove('off')\n        })\n    })\n}\n\nfunction updateState(data, element) {\n    const preference = data.find(preference => preference.id === element.id)\n    preference.state === false ? element.classList.add('off') : element.classList.remove('off')\n}\n\n// Rearanging order\nfunction createLabels(preference) {\n    const label = document.createElement('label')\n    label.id = preference.id\n    label.draggable = true\n    preference.state ? label.className = 'on' : label.className = 'off'\n\n    const input = document.createElement('input')\n    input.type = 'checkbox'\n    input.checked = preference.state\n\n    label.append(input)\n    label.append(preference.name)\n\n    return label\n}","import * as utils from '../modules/utils.mjs'\n\nexport function indicate(item) {\n    getUnread()\n        .then(numberUnread => {\n            if (numberUnread > 0) {\n                item.classList.add('unread-indicator')\n                item.setAttribute('number-unread', numberUnread)\n            } else {\n                item.classList.remove('unread-indicator')\n            }\n        })\n}\n\n\nfunction getAnnouncements() {\n    const options = {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n    }\n\n    return fetch('/announcementslist', options).then(res => res.json())\n}\n\nfunction getUnread() {\n    const storedHistory = utils.getLocalStorage('read-history')\n    const numberUnread = getAnnouncements()\n        .then(json => {\n            const [announcements, categories] = json\n            return announcements\n        })\n        .then(announcements => {\n            let numberOfUnread = 0\n            if (storedHistory) {\n                announcements.forEach(announcement => {\n                    if (!storedHistory.includes(announcement.newsItemId)) {\n                        numberOfUnread++\n                    }\n                })\n            }\n            return numberOfUnread\n        })\n    return numberUnread\n}","import { WC_studyprogress } from '../web-components/study-progress.mjs'\nimport { WC_scheduleWidget } from '../web-components/schedule.mjs'\nimport { WC_courseoverview } from '../web-components/course-overview.mjs'\nimport { WC_announcementsWidget } from '../web-components/announcements.mjs'\n\nexport function exists([...variables]) {\n    const exists = variables.every(variable => variable != null)\n    return exists\n}\n\n\nexport function setLocalStorage(name, item) {\n    localStorage.setItem(name, JSON.stringify(item))\n}\n\n\nexport function getLocalStorage(item) {\n    return JSON.parse(localStorage.getItem(item))\n}\n\nexport function storageAvailable(type) { //source: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n    let storage\n    try {\n        storage = window[type]\n        let x = '__storage_test__'\n        storage.setItem(x, x)\n        storage.removeItem(x)\n        return true\n    } catch (e) {\n        return e instanceof DOMException && (\n                e.code === 22 ||\n                e.code === 1014 ||\n                e.name === 'QuotaExceededError' ||\n                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            (storage && storage.length !== 0)\n    }\n}\n\nexport function getPreferences() {\n    let widgetElements\n\n    if (storageAvailable('localStorage')) {\n        const preferences = getLocalStorage('preferences')\n        if (preferences) {\n            widgetElements = checker(preferences)\n        } else {\n            widgetElements = ['announcements-widget', 'study-progress', 'course-overview', 'schedule-widget']\n        }\n    } else {\n        widgetElements = ['announcements-widget', 'study-progress', 'course-overview', 'schedule-widget']\n    }\n\n    return widgetElements\n}\n\nexport function appendWidgets(widget) {\n    // Remove EJS templates\n    const domElements = ['announcements', 'study-progress', 'course-overview', 'schedule']\n    domElements.forEach(element => document.getElementById(element).remove())\n\n    // Adding widgets\n    widget.forEach(item => {\n        document.querySelector('main section').append(document.createElement(item))\n\n        if (item === 'study-progress') {\n            WC_studyprogress()\n        }\n        if (item === 'course-overview') {\n            WC_courseoverview()\n        }\n        if (item === 'schedule-widget') {\n            WC_scheduleWidget()\n        }\n        if (item === 'announcements-widget') {\n            WC_announcementsWidget('dashboard')\n        }\n    })\n}\n\nexport function checker(preferences) {\n    const widgetElements = []\n\n    // Announcements\n    preferences.forEach(preference => {\n        preference.id = parseInt(preference.id)\n\n        if (preference.state && preference.id === 0) {\n            widgetElements.push('announcements-widget')\n        }\n        if (preference.state && preference.id === 1) {\n            widgetElements.push('study-progress')\n        }\n        if (preference.state && preference.id === 2) {\n            widgetElements.push('course-overview')\n        }\n        if (preference.state && preference.id === 3) {\n            widgetElements.push('schedule-widget')\n        }\n    })\n\n    return widgetElements\n}","import * as utils from '../modules/utils.mjs'\n\nexport { init as WC_announcementsWidget }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\n*:focus {\n    outline: none;\n}\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\np {\n\tmargin: 0;\n}\n.announcements-container #announcement-legend {\n\tmargin-bottom: 20px;\n}\n.announcements-container #announcement-legend p {\n\tcolor: black;\n\tfont-size: 14px;\n\tdisplay: inline-block;\n\tmargin-right: 20px;\n}\n.announcements-container #announcement-legend p:last-of-type {\n\tmargin-right: 0;\n}\n.announcements-container #announcement-legend p::before {\n\tcontent: \"\";\n\theight: 15px;\n\tmargin-bottom: -2px;\n\twidth: 15px;\n\tmargin-right: 10px;\n\tdisplay: inline-block;\n}\n.announcements-container #announcement-legend p.Opleiding::before {\n\tbackground-color: #DC143C;\n}\n.announcements-container #announcement-legend p.Faculteit::before {\n\tbackground-color: #DCB614;\n}\n.announcements-container #announcement-legend p.HvA::before {\n\tbackground-color: #149EDC;\n}\n.announcements-container #announcement-legend p.Medezeggenschap::before {\n\tbackground-color: #14DC69;\n}\n.announcements-container a {\n\tmargin: 0 0 15px 0;\n\tdisplay: block;\n\tcolor: black;\n\ttext-decoration: none;\n}\n.announcements-container a:hover {\n\tbackground-color: #F2F2F2;\n}\n.announcements-container a:focus {\n\tbackground-color: #DDDDDD;\n}\n.announcements-container .announcement {\n\tmargin: 0;\n\tpadding: 5px 0 5px 10px;\n\tborder-left: 5px solid;\n}\n.announcements-container .announcement.Opleiding {\n\tborder-color: #DC143C;\n}\n.announcements-container .announcement.Faculteit {\n\tborder-color: #DCB614;\n}\n.announcements-container .announcement.HvA {\n\tborder-color: #149EDC;\n}\n.announcements-container .announcement.Medezeggenschap {\n\tborder-color: #14DC69;\n}\n.announcements-container .announcement p:first-of-type {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n.announcements-container .read .announcement p:first-of-type {\n    font-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n}\n.announcements-container .announcement p:last-of-type {\n\tcolor: #666666;\n\tfont-size: 14px;\n}    \n.allAnnouncements {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n\talign-items: center;\n}\n.allAnnouncements:hover,\n.allAnnouncements:focus {\n        text-decoration: underline;\n}\n.allAnnouncements img {\n        height: 12px;\n        margin-left: 20px;\n}\n</style>\n<div id=\"announcements\"></div>\n<h2>Mededelingen</h2>\n<div class=\"announcements-container\">\n\t<div id=\"announcement-legend\"></div>\n</div>\n<a class=\"allAnnouncements\" href=\"/announcements/\" target=\"_self\">Alle mededelingen\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>`\n\nfunction init(pageName) {\n    class announcementList extends HTMLElement {\n        constructor() {\n            super()\n\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.getData()\n                .then(json => {\n                    const [announcements, categories] = json\n                    this.createLegenda(categories)\n                    if (pageName === 'dashboard') {\n                        announcements.splice(5, announcements.length)\n                    }\n                    this.appendAnnouncements(announcements)\n                })\n            this.announcementContainer = this.shadowRoot.querySelector('.announcements-container')\n            this.announcementLegend = this.shadowRoot.querySelector('#announcement-legend')\n        }\n\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/announcementslist', options).then(res => res.json())\n        }\n\n        createLegenda(categories) {\n            categories.forEach(cat => {\n                this.announcementLegend.insertAdjacentHTML('beforeend', `<p class=\"${cat}\">${cat}</p>`)\n            })\n        }\n\n        appendAnnouncements(announcements) {\n            announcements.forEach(announcement => {\n                this.announcementContainer.insertAdjacentHTML('beforeend', `\n\t\t\t\t<a href=\"/announcements/${announcement.newsItemId}\" target=\"_self\" uid=\"${announcement.newsItemId}\">\n\t\t\t\t\t<div class=\"announcement ${announcement.tags[0]}\" id=\"${announcement.newsItemId}\">\n                \t\t<p>${announcement.title}</p>\n                \t\t<p>${announcement.publishDate} - ${announcement.tags[0]}</p>\n           \t\t\t</div>\n\t\t\t\t</a>`)\n\n                if (utils.storageAvailable('localStorage')) {\n                    const storedHistory = utils.getLocalStorage('read-history')\n                    this.readHistory = storedHistory ? storedHistory : []\n\n                    const link = this.announcementContainer.querySelector('a:last-of-type')\n\n                    if (this.readHistory.includes(link.getAttribute('uid'))) {\n                        link.classList.add('read')\n                    }\n                    link.addEventListener('click', () => this.store(link))\n                }\n            })\n        }\n\n        store(announcement) {\n            this.readHistory.push(announcement.getAttribute('uid'))\n            utils.setLocalStorage('read-history', this.readHistory)\n        }\n    }\n\n    window.customElements.define('announcements-widget', announcementList)\n}","export { init as WC_courseoverview }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\n\np {\n\tmargin: 0;\n}\n\n.navigator {\n    background-color: #DDDDDD;\n    padding: 5px 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color: #25167A;\n    font-size: 16px;\n}\n\n.navigator span  {\n    cursor: default;\n}\n\n.navigator img {\n    padding: 10px;\n}\n\n.navigator img:not(.disabled) {\n    cursor: pointer;\n}\n\n.navigator img.disabled {\n    pointer-events: none;\n    opacity: .5;\n}\n\n.course {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    grid-column-gap: 20px;\n    padding: 15px 20px;\n    border-bottom: 1px solid #DDDDDD;\n}\n\n.course p:first-of-type {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n    align-self: center;\n}\n\n.course ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    align-self: center;\n}\n\n.course ul li {\n    display: inline;\n}\n\n.course ul li:not(:last-of-type):after {\n    content: \", \";\n    white-space: pre;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n</style>\n\n<h2>Vakkenoverzicht</h2>\n\n<div class=\"navigator\">\n    <img src=\"/media/icons/arrow-left.svg\" alt=\"arrow-left\"></img>\n    <span></span>\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</div>\n\n<div id=\"course-overview\"></div>\n\n<a target=\"_blank\" href=\"https://sis.hva.nl/\">Volledig overzicht\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class CourseOverview extends HTMLElement {\n        constructor() {\n            // Setup\n            super()\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            // Variables\n            this.courseContainer = this.shadowRoot.querySelector('#course-overview')\n            this.courseMoment = this.shadowRoot.querySelector('.navigator span')\n            this.arrowPrevious = this.shadowRoot.querySelector('.navigator img:first-of-type')\n            this.arrowNext = this.shadowRoot.querySelector('.navigator img:last-of-type')\n            this.yearIndex = 2\n            this.quarterIndex = 3\n\n            // Data\n            this.data = this.getData().then(json => {\n                this.navigateHandler()\n\n                const data = json[this.yearIndex].quarters[this.quarterIndex].courses\n                this.updateCourseOverview(data)\n\n                this.data = json\n            })\n\n            // EventListeners\n            this.arrowPrevious.addEventListener('click', () => this.navigate('previous'))\n            this.arrowNext.addEventListener('click', () => this.navigate('next'))\n        }\n\n        updateNavigator() {\n            this.courseMoment.textContent = `Jaar ${this.yearIndex + 1} - Blok ${this.quarterIndex + 1}`\n        }\n\n        updateCourseOverview(courses) {\n            this.courseContainer.textContent = \"\"\n            this.updateNavigator()\n\n            courses.forEach(course => {\n                const div = document.createElement('div')\n                div.classList.add('course')\n\n                const courseName = document.createElement('p')\n                courseName.textContent = course.course\n                div.append(courseName)\n\n                const list = document.createElement('ul')\n                course.lecturers.forEach(lecturer => {\n                    const teacher = document.createElement('li')\n                    lecturer === \"\" ? teacher.textContent = 'Geen specifieke docent' : teacher.textContent = lecturer\n                    list.append(teacher)\n                })\n                div.append(list)\n\n                this.courseContainer.append(div)\n            })\n        }\n\n        navigate(direction) {\n            if (direction === 'previous') {\n                if (this.quarterIndex > 0) {\n                    this.quarterIndex--\n                } else if (this.quarterIndex === 0 && this.yearIndex > 0) {\n                    this.quarterIndex = 3\n                    this.yearIndex--\n                }\n            }\n\n            if (direction === 'next') {\n                if (this.quarterIndex < 3) {\n                    this.quarterIndex++\n                } else if (this.quarterIndex === 3 && this.yearIndex < 3) {\n                    this.quarterIndex = 0\n                    this.yearIndex++\n                }\n            }\n\n            this.navigateHandler()\n\n            const data = this.data[this.yearIndex].quarters[this.quarterIndex].courses\n            this.updateCourseOverview(data)\n        }\n\n        navigateHandler() {\n            this.yearIndex === 0 && this.quarterIndex === 0 ?\n                this.arrowPrevious.classList.add('disabled') : this.arrowPrevious.classList.remove('disabled')\n\n            this.yearIndex === 3 && this.quarterIndex === 3 ?\n                this.arrowNext.classList.add('disabled') : this.arrowNext.classList.remove('disabled')\n        }\n\n        // Helpers\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/courseoverview', options).then(res => res.json())\n        }\n    }\n\n    customElements.define('course-overview', CourseOverview)\n}","export { init as WC_scheduleWidget }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\n\np {\n\tmargin: 0;\n}\n\n.navigator {\n    background-color: #DDDDDD;\n    padding: 5px 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color: #25167A;\n    font-size: 16px;\n}\n\n.navigator span  {\n    cursor: default;\n}\n\n.navigator img {\n    padding: 10px;\n}\n\n.navigator img:not(.disabled) {\n    cursor: pointer;\n}\n\n.navigator img.disabled {\n    pointer-events: none;\n    opacity: .5;\n}\n\n.schedule-course {\n    display: grid;\n    grid-template-columns: auto 1fr;\n    grid-column-gap: 20px;\n    grid-row-gap: 5px;\n    padding: 15px 20px;\n    border-bottom: 1px solid #DDDDDD;\n}\n\n.schedule-course p:first-of-type,\n.schedule-course p:nth-of-type(3) {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n</style>\n<h2>Dagrooster</h2>\n<div class=\"navigator\">\n\t<img src=\"/media/icons/arrow-left.svg\" alt=\"arrow-left\" class=\"disabled\"></img>\n\t<span></span>\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</div>\n<div id=\"schedules-container\"></div>\n<a target=\"_blank\" href=\"https://rooster.hva.nl/schedule\">Volledig rooster\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class schedule extends HTMLElement {\n        constructor() {\n            super()\n\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.data = this.getData()\n                .then(json => {\n                    this.updateSchedule(json[0])\n                    this.data = json\n                })\n\n            this.navigator = this.shadowRoot.querySelector('.navigator')\n            this.arrowPrevious = this.navigator.querySelector('img:first-of-type')\n            this.arrowNext = this.navigator.querySelector('img:last-of-type')\n\n            this.arrowNext.addEventListener('click', () => this.navigate('next'))\n            this.arrowPrevious.addEventListener('click', () => this.navigate('previous'))\n            this.index = 0\n        }\n\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/schedule', options).then(res => res.json())\n        }\n\n        updateSchedule(data) {\n            const schedulesContainer = this.shadowRoot.getElementById('schedules-container')\n            schedulesContainer.textContent = \"\"\n\n            this.navigator.querySelector('span').textContent = `${data.day}-${data.month}-${data.year}`\n\n            data.schedules.forEach(schedule => {\n                const classRoom = schedule._embedded ? schedule._embedded.rooms[0].abbreviation : \"Geen lokaal\"\n\n                const div = document.createElement('div')\n                div.classList.add('schedule-course')\n                schedulesContainer.appendChild(div)\n\n                const time = document.createElement('p')\n                time.textContent = `${schedule.startDateTime.time} - ${schedule.endDateTime.time}`\n                div.appendChild(time)\n\n                const name = document.createElement('p')\n                name.textContent = schedule._links.courses[0].title\n                div.appendChild(name)\n\n                const room = document.createElement('p')\n                room.textContent = classRoom\n                div.appendChild(room)\n\n                const teacher = document.createElement('p')\n                teacher.textContent = schedule._links.lecturers[0].title\n                div.appendChild(teacher)\n            })\n        }\n\n        navigate(direction) {\n            direction === 'previous' ? this.index-- : this.index++\n\n            this.index === 0 ? this.arrowPrevious.classList.add('disabled') : this.arrowPrevious.classList.remove('disabled')\n            this.index === 4 ? this.arrowNext.classList.add('disabled') : this.arrowNext.classList.remove('disabled')\n\n            this.updateSchedule(this.data[this.index])\n        }\n    }\n\n    window.customElements.define('schedule-widget', schedule)\n}","export { init as WC_studyprogress }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n    font-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n    font-weight: lighter;\n    line-height: 1.1;\n}\n\np {\n    margin: 0;\n}\n\n#recent-results div {\n    display: grid;\n    grid-template-columns: auto 1fr auto;\n    grid-template-rows: 1fr auto;\n}\n\n#recent-results div:not(:last-of-type) {\n    margin-bottom: 15px;\n}\n\n#recent-results span {\n    display: block;\n    grid-column: 1 / 2;\n    grid-row: 1 / 3;\n    width: 5px;\n    height: 100%;\n}\n\nspan.success {\n    background-color: #25167A;\n}\n\nspan.failed {\n    background-color: #DDDDDD;\n}\n\n#recent-results p:nth-of-type(1) {\n    grid-column: 2 / 3;\n    padding: 4px 0px 0px 10px;\n}\n\n#recent-results p:nth-of-type(2) {\n    grid-row: 1 / 3;\n    grid-column: 3 / 4;\n    align-self: center;\n}\n\n#recent-results p:nth-of-type(3) {\n    padding: 0px 0px 4px 10px;\n    font-size: 14px;\n    color: #666666;\n}\n\n#recent-results p:nth-of-type(1),\n#recent-results p:nth-of-type(2) {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n\n}\n\n#recent-progress {\n    margin-top: 30px;\n}\n\n#recent-progress div {\n    display: grid;\n    grid-template-columns: auto 1fr auto;\n}\n\n#recent-progress div span {\n        display: block;\n        width: 5px;\n}\n\n#recent-progress p {\n    padding: 5px 0px;\n}\n\n#recent-progress p:first-of-type {\n    padding-left: 10px;\n}\n\n#recent-progress .current-year {\n    background-color: #DDDDDD;\n}\n\n#recent-progress .current-year span {\n    background-color: #25167A;\n}\n\n#recent-progress .current-year p {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n\n#recent-progress .current-year p:last-of-type {\n    padding-right: 10px;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n</style>\n\n<h2>Studieresultaten en -voortgang</h2>\n\n<div id=\"recent-results\"></div>\n<div id=\"recent-progress\"></div>\n\n<a target=\"_blank\" href=\"https://sis.hva.nl/\">Alle resultaten in SIS\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class StudyProgress extends HTMLElement {\n        constructor() {\n            // Setup\n            super()\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.getData().then(json => {\n                const [results, progress] = json\n\n                this.resultComponent(results)\n                this.progressComponent(progress)\n            })\n\n            this.resultsContainer = this.shadowRoot.querySelector('#recent-results')\n            this.progressContainer = this.shadowRoot.querySelector('#recent-progress')\n        }\n\n        progressComponent(results) {\n            results.forEach(result => {\n                const div = document.createElement('div')\n                if (result.currentYear) {\n                    div.classList.add('current-year')\n                }\n\n                const template = `\n                <span></span>\n                <p>Leerjaar ${result.studyYear}</p>\n                <p>${result.studypoints.achieved}/${result.studypoints.available} studiepunten</p>`\n\n                // InsertAdjacentHtml\n                // Template engine uitzoeken voor Webcomponents\n\n                div.innerHTML = template\n                this.progressContainer.append(div)\n            })\n        }\n\n\n        resultComponent(results) {\n            results.forEach(result => {\n                // Parent container\n                const div = document.createElement('div')\n\n                let indicator\n                if (typeof result.grade === 'number' && result.grade >= 5.5 || result.grade === 'V') {\n                    indicator = `<span class=\"success\"></span>`\n                } else if (typeof result.grade === 'number' && result.grade < 5.5 || result.grade === '-' || result.grade === 'GR') {\n                    indicator = `<span class=\"failed\"></span>`\n                }\n\n                const template = `\n                ${indicator}\n                <p>${result._links.course.title}</p>\n                <p>${result.grade}</p>\n                <p>${result.fullDate}</p>\n                `\n\n                div.innerHTML = template\n                this.resultsContainer.append(div)\n            })\n        }\n\n        // Helpers\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/studyprogress', options).then(res => res.json())\n        }\n    }\n\n    customElements.define('study-progress', StudyProgress)\n}","import * as utils from '../modules/utils.mjs'\n\nexport { template as WC_urgentAnnouncement }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\n    div {\n        display: grid;\n        grid-template-columns: 1fr 50px;\n        grid-template-rows: 50px;\n        align-items: center;\n        background-color: #ECE7FA;\n    }\n    div.hide {\n        position: absolute;\n        left: -9999px;\n    }\n    p {\n        margin: 0;\n        padding-left: 30px;\n        color: black;\n        justify-self: start;\n    }\n    @media only screen and (max-width: 425px) {\n        p {\n            padding-left: 10px;\n        }\n    }\n    img {\n        padding-right: 20px;\n        grid-column: 2 / 3;\n        justify-self: end;\n        cursor: pointer;\n    }\n</style>\n<div class=\"hide\">\n    <p></p>\n    <img src=\"./media/icons/notification-exit.svg\" alt=\"hide notification\">\n</div>`\n\n\n\nclass urgentAnnouncement extends HTMLElement {\n\n    constructor() {\n        super()\n\n        this.attachShadow({ mode: 'open' })\n        this.shadowRoot.appendChild(template.content.cloneNode(true))\n        this.shadowRoot.querySelector('p').textContent = this.getAttribute('message')\n        this.shadowRoot.querySelector('img').addEventListener('click', () => {\n            this.hide()\n            this.store()\n        })\n    }\n\n    static get observedAttributes() {\n        return ['uid']\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue != newValue && newValue != \"\") {\n            const uid = this.getAttribute('uid')\n            if (utils.storageAvailable('localStorage')) {\n                const storedHistory = utils.getLocalStorage('read-history')\n                if (storedHistory) {\n                    if (!storedHistory.includes(uid)) {\n                        this.updateContent()\n                        this.show()\n                    }\n                } else {\n                    this.updateContent()\n                    this.show()\n                }\n            }\n        }\n    }\n\n    updateContent() {\n        this.shadowRoot.querySelector('p').textContent = this.getAttribute('message')\n    }\n\n    show() {\n        this.shadowRoot.querySelector('div').classList.remove('hide')\n        document.querySelector('main').classList.add('showsNotification')\n    }\n\n    hide() {\n        this.shadowRoot.querySelector('div').classList.add('hide')\n        document.querySelector('main').classList.remove('showsNotification')\n    }\n\n    store() {\n        if (utils.storageAvailable('localStorage')) {\n            const storedHistory = utils.getLocalStorage('read-history')\n            const readHistory = storedHistory ? storedHistory : []\n\n            readHistory.push(this.getAttribute('uid'))\n            utils.setLocalStorage('read-history', readHistory)\n        }\n    }\n}\n\nwindow.customElements.define('urgent-announcement', urgentAnnouncement)"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc29ydGFibGVqcy9Tb3J0YWJsZS5qcyIsInNyYy9qcy9pbmRleC5qcyIsInNyYy9qcy9tb2R1bGVzL3NlYXJjaC5tanMiLCJzcmMvanMvbW9kdWxlcy90b2dnbGVQcmVmZXJlbmNlcy5tanMiLCJzcmMvanMvbW9kdWxlcy91bnJlYWRBbm5vdW5jZW1lbnRzLm1qcyIsInNyYy9qcy9tb2R1bGVzL3V0aWxzLm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9hbm5vdW5jZW1lbnRzLm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9jb3Vyc2Utb3ZlcnZpZXcubWpzIiwic3JjL2pzL3dlYi1jb21wb25lbnRzL3NjaGVkdWxlLm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9zdHVkeS1wcm9ncmVzcy5tanMiLCJzcmMvanMvd2ViLWNvbXBvbmVudHMvdXJnZW50LWFubm91bmNlbWVudC5tanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3bkhBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLElBQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLE1BQXZCLEVBQStCLEVBQS9CLENBQWtDLFdBQWxDLEVBQWIsQyxDQUVBOztBQUNBLElBQUksSUFBSSxLQUFLLFdBQWIsRUFBMEI7QUFDdEIsRUFBQSxLQUFLLENBQUMsYUFBTixDQUFvQixLQUFLLENBQUMsY0FBTixFQUFwQjtBQUNIOztBQUVELElBQUksSUFBSSxLQUFLLFNBQWIsRUFBd0I7QUFDcEI7QUFDSDs7QUFFRCxJQUFJLElBQUksS0FBSyx3QkFBYixFQUF1QztBQUNuQyxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxjQUFULENBQXdCLGVBQXhCLENBQXpCO0FBQ0EsRUFBQSxnQkFBZ0IsQ0FBQyxNQUFqQjtBQUNBLEVBQUEsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsY0FBdkIsRUFBdUMsTUFBdkMsQ0FBOEMsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsc0JBQXZCLENBQTlDO0FBQ0EsNkNBQXVCLElBQXZCO0FBQ0gsQyxDQUdEOzs7QUFDQSxJQUFJLFNBQVMsQ0FBQyxNQUFkLEVBQXNCO0FBQ2xCO0FBQ0EsTUFBTSxNQUFNLEdBQUcsRUFBRSxFQUFqQixDQUZrQixDQUlsQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxJQUFQLENBQVksTUFBWixFQUFvQixJQUFwQixFQUxrQixDQU9sQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxFQUFQLENBQVUscUJBQVYsRUFBaUMsVUFBQSxZQUFZLEVBQUk7QUFDN0MsUUFBTSxrQkFBa0IsR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixxQkFBdkIsQ0FBM0I7O0FBRUEsUUFBSSxLQUFLLENBQUMsTUFBTixDQUFhLENBQUMsa0JBQUQsQ0FBYixDQUFKLEVBQXdDO0FBQ3BDLE1BQUEsa0JBQWtCLENBQUMsWUFBbkIsQ0FBZ0MsU0FBaEMsRUFBMkMsWUFBWSxDQUFDLEtBQXhEO0FBQ0EsTUFBQSxrQkFBa0IsQ0FBQyxZQUFuQixDQUFnQyxLQUFoQyxFQUF1QyxZQUFZLENBQUMsVUFBcEQ7QUFDSDtBQUNKLEdBUEQ7QUFRSCxDLENBS0Q7OztBQUNBLElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxjQUFULENBQXdCLFdBQXhCLENBQWpCO0FBQ0EsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGNBQVQsQ0FBd0IsTUFBeEIsQ0FBYjs7QUFFQSxJQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBQyxRQUFELEVBQVcsSUFBWCxDQUFiLENBQUosRUFBb0M7QUFFaEM7QUFDQSxFQUFBLFFBQVEsQ0FBQyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxZQUFNO0FBQ3JDLElBQUEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxNQUFmLENBQXNCLE1BQXRCO0FBQ0gsR0FGRDtBQUdILEMsQ0FLRDs7O0FBQ0EsSUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLGNBQVQsQ0FBd0IsWUFBeEIsQ0FBbEI7QUFDQSxJQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsY0FBVCxDQUF3QixjQUF4QixDQUF4QjtBQUNBLElBQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLHNDQUF2QixDQUFuQjs7QUFFQSxJQUFJLEtBQUssQ0FBQyxNQUFOLENBQWEsQ0FBQyxTQUFELEVBQVksZUFBWixFQUE2QixVQUE3QixDQUFiLENBQUosRUFBNEQ7QUFFeEQ7QUFDQSxFQUFBLFNBQVMsQ0FBQyxnQkFBVixDQUEyQixPQUEzQixFQUFvQztBQUFBLFdBQU0sTUFBTSxDQUFDLFNBQVAsRUFBTjtBQUFBLEdBQXBDO0FBQ0EsRUFBQSxTQUFTLENBQUMsZ0JBQVYsQ0FBMkIsTUFBM0IsRUFBbUM7QUFBQSxXQUFNLE1BQU0sQ0FBQyxTQUFQLEVBQU47QUFBQSxHQUFuQyxFQUp3RCxDQU94RDs7QUFDQSxFQUFBLGVBQWUsQ0FBQyxnQkFBaEIsQ0FBaUMsT0FBakMsRUFBMEMsVUFBQSxDQUFDO0FBQUEsV0FBSSxNQUFNLENBQUMsS0FBUCxDQUFhLENBQWIsQ0FBSjtBQUFBLEdBQTNDLEVBUndELENBV3hEOztBQUNBLEVBQUEsVUFBVSxDQUFDLGdCQUFYLENBQTRCLE9BQTVCLEVBQXFDLFVBQUEsQ0FBQyxFQUFJO0FBQ3RDLFFBQUksU0FBUyxDQUFDLEtBQVYsS0FBb0IsRUFBeEIsRUFBNEI7QUFDeEIsTUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLENBQWI7QUFDSDtBQUNKLEdBSkQsRUFad0QsQ0FtQnhEOztBQUNBLEVBQUEsUUFBUSxDQUFDLGdCQUFULENBQTBCLFVBQTFCLEVBQXNDLFVBQUEsQ0FBQyxFQUFJO0FBQ3ZDLFlBQVEsQ0FBQyxDQUFDLEdBQVY7QUFDSSxXQUFLLEdBQUw7QUFDSSxRQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsQ0FBYixFQURKLENBQ29COztBQUNoQjtBQUhSO0FBS0gsR0FORDtBQU9ILEMsQ0FHRDs7O0FBQ0EsSUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixvQ0FBdkIsQ0FBN0I7O0FBRUEsSUFBSSxLQUFLLENBQUMsTUFBTixDQUFhLENBQUMsb0JBQUQsQ0FBYixLQUF3QyxLQUFLLENBQUMsZ0JBQU4sQ0FBdUIsY0FBdkIsQ0FBNUMsRUFBb0Y7QUFDaEYsRUFBQSxtQkFBbUIsQ0FBQyxRQUFwQixDQUE2QixvQkFBN0I7QUFDSDs7Ozs7Ozs7Ozs7O0FDdkdELElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFULENBQXdCLFlBQXhCLENBQWxCO0FBQ0EsSUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLGNBQVQsQ0FBd0IsY0FBeEIsQ0FBeEI7O0FBRU8sU0FBUyxLQUFULENBQWUsQ0FBZixFQUFrQjtBQUNyQixFQUFBLENBQUMsQ0FBQyxjQUFGO0FBQ0EsRUFBQSxTQUFTLENBQUMsS0FBVjtBQUNIOztBQUVNLFNBQVMsU0FBVCxHQUFxQjtBQUN4QixFQUFBLGVBQWUsQ0FBQyxTQUFoQixDQUEwQixNQUExQixDQUFpQyxNQUFqQztBQUNIOztBQUVNLFNBQVMsU0FBVCxHQUFxQjtBQUN4QixNQUFJLFNBQVMsQ0FBQyxLQUFWLEtBQW9CLEVBQXhCLEVBQTRCO0FBQ3hCLElBQUEsZUFBZSxDQUFDLFNBQWhCLENBQTBCLEdBQTFCLENBQThCLE1BQTlCO0FBQ0g7QUFDSjs7QUFFTSxTQUFTLEtBQVQsQ0FBZSxDQUFmLEVBQWtCO0FBQ3JCLEVBQUEsU0FBUyxDQUFDLEtBQVYsR0FBa0IsRUFBbEI7QUFDQSxFQUFBLEtBQUssQ0FBQyxDQUFELENBQUw7QUFDSDs7Ozs7Ozs7OztBQ3JCRDs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLGVBQXZCLENBQWxCOztBQUNlLFNBQVMsaUJBQVQsR0FBNkI7QUFDeEMsRUFBQSxTQUFTLENBQUMsU0FBVixDQUFvQixNQUFwQixDQUEyQixVQUEzQjtBQUVBLEVBQUEsY0FBYztBQUNkLEVBQUEsWUFBWTtBQUNaLEVBQUEsV0FBVztBQUNkOztBQUVELFNBQVMsY0FBVCxHQUEwQjtBQUN0QixNQUFNLFdBQVcsR0FBRyw0QkFBZ0IsYUFBaEIsQ0FBcEI7O0FBQ0EsTUFBSSxXQUFKLEVBQWlCO0FBQ2IsSUFBQSxTQUFTLENBQUMsV0FBVixHQUF3QixFQUF4QjtBQUNBLElBQUEsV0FBVyxDQUFDLE9BQVosQ0FBb0IsVUFBQSxVQUFVO0FBQUEsYUFBSSxTQUFTLENBQUMsTUFBVixDQUFpQixZQUFZLENBQUMsVUFBRCxDQUE3QixDQUFKO0FBQUEsS0FBOUI7QUFDSCxHQUhELE1BR087QUFDSCxJQUFBLG9CQUFvQjtBQUN2QjtBQUNKOztBQUVELFNBQVMsV0FBVCxHQUF1QjtBQUNuQixNQUFNLG9CQUFvQixHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLGNBQXZCLENBQTdCO0FBRUEsTUFBSSxzQkFBSixDQUFhLG9CQUFiLEVBQW1DO0FBQy9CLElBQUEsU0FBUyxFQUFFLEdBRG9CO0FBRS9CLElBQUEsS0FBSyxFQUFFO0FBQUEsYUFBTSxvQkFBb0IsRUFBMUI7QUFBQTtBQUZ3QixHQUFuQztBQUlILEMsQ0FFRDs7O0FBQ0EsU0FBUyxvQkFBVCxHQUFnQztBQUM1QixNQUFNLE1BQU0sc0JBQU8sUUFBUSxDQUFDLGdCQUFULENBQTBCLHFCQUExQixDQUFQLENBQVo7O0FBQ0EsTUFBSSxXQUFXLEdBQUcsRUFBbEI7QUFFQSxFQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsVUFBQSxLQUFLLEVBQUk7QUFDcEI7QUFDQSxRQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBakI7QUFDQSxRQUFNLElBQUksR0FBRyxLQUFLLENBQUMsV0FBbkI7QUFDQSxRQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBTixDQUFvQixPQUFwQixFQUE2QixPQUEzQyxDQUpvQixDQU1wQjs7QUFDQSxRQUFNLE1BQU0sR0FBRztBQUFFLE1BQUEsRUFBRSxFQUFFLEVBQU47QUFBVSxNQUFBLElBQUksRUFBRSxJQUFoQjtBQUFzQixNQUFBLEtBQUssRUFBRTtBQUE3QixLQUFmO0FBQ0EsSUFBQSxXQUFXLENBQUMsSUFBWixDQUFpQixNQUFqQjtBQUNBLGdDQUFnQixhQUFoQixFQUErQixXQUEvQjtBQUNILEdBVkQ7QUFZQSxTQUFPLFdBQVA7QUFDSDs7QUFFRCxTQUFTLFlBQVQsR0FBd0I7QUFDcEIsTUFBTSxNQUFNLHNCQUFPLFFBQVEsQ0FBQyxnQkFBVCxDQUEwQixxQkFBMUIsQ0FBUCxDQUFaOztBQUNBLE1BQU0sSUFBSSxHQUFHLDRCQUFnQixhQUFoQixDQUFiO0FBRUEsRUFBQSxNQUFNLENBQUMsT0FBUCxDQUFlLFVBQUEsS0FBSyxFQUFJO0FBQ3BCLElBQUEsV0FBVyxDQUFDLElBQUQsRUFBTyxLQUFQLENBQVg7QUFFQSxJQUFBLEtBQUssQ0FBQyxnQkFBTixDQUF1QixRQUF2QixFQUFpQyxVQUFBLEtBQUssRUFBSTtBQUN0QztBQUNBLFVBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFqQjtBQUNBLFVBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFOLENBQWEsT0FBM0IsQ0FIc0MsQ0FLdEM7O0FBQ0EsVUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUwsQ0FBVSxVQUFBLFVBQVU7QUFBQSxlQUFJLFVBQVUsQ0FBQyxFQUFYLEtBQWtCLEVBQXRCO0FBQUEsT0FBcEIsQ0FBbkI7QUFDQSxNQUFBLFVBQVUsQ0FBQyxLQUFYLEdBQW1CLEtBQW5CO0FBQ0Esa0NBQWdCLGFBQWhCLEVBQStCLElBQS9CLEVBUnNDLENBVXRDOztBQUNBLE1BQUEsVUFBVSxDQUFDLEtBQVgsS0FBcUIsS0FBckIsR0FBNkIsS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsR0FBaEIsQ0FBb0IsS0FBcEIsQ0FBN0IsR0FBMEQsS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsTUFBaEIsQ0FBdUIsS0FBdkIsQ0FBMUQ7QUFDSCxLQVpEO0FBYUgsR0FoQkQ7QUFpQkg7O0FBRUQsU0FBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLE9BQTNCLEVBQW9DO0FBQ2hDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFMLENBQVUsVUFBQSxVQUFVO0FBQUEsV0FBSSxVQUFVLENBQUMsRUFBWCxLQUFrQixPQUFPLENBQUMsRUFBOUI7QUFBQSxHQUFwQixDQUFuQjtBQUNBLEVBQUEsVUFBVSxDQUFDLEtBQVgsS0FBcUIsS0FBckIsR0FBNkIsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsR0FBbEIsQ0FBc0IsS0FBdEIsQ0FBN0IsR0FBNEQsT0FBTyxDQUFDLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsS0FBekIsQ0FBNUQ7QUFDSCxDLENBRUQ7OztBQUNBLFNBQVMsWUFBVCxDQUFzQixVQUF0QixFQUFrQztBQUM5QixNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixPQUF2QixDQUFkO0FBQ0EsRUFBQSxLQUFLLENBQUMsRUFBTixHQUFXLFVBQVUsQ0FBQyxFQUF0QjtBQUNBLEVBQUEsS0FBSyxDQUFDLFNBQU4sR0FBa0IsSUFBbEI7QUFDQSxFQUFBLFVBQVUsQ0FBQyxLQUFYLEdBQW1CLEtBQUssQ0FBQyxTQUFOLEdBQWtCLElBQXJDLEdBQTRDLEtBQUssQ0FBQyxTQUFOLEdBQWtCLEtBQTlEO0FBRUEsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBLEVBQUEsS0FBSyxDQUFDLElBQU4sR0FBYSxVQUFiO0FBQ0EsRUFBQSxLQUFLLENBQUMsT0FBTixHQUFnQixVQUFVLENBQUMsS0FBM0I7QUFFQSxFQUFBLEtBQUssQ0FBQyxNQUFOLENBQWEsS0FBYjtBQUNBLEVBQUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxVQUFVLENBQUMsSUFBeEI7QUFFQSxTQUFPLEtBQVA7QUFDSDs7Ozs7Ozs7OztBQzlGRDs7Ozs7Ozs7Ozs7Ozs7OztBQUVPLFNBQVMsUUFBVCxDQUFrQixJQUFsQixFQUF3QjtBQUMzQixFQUFBLFNBQVMsR0FDSixJQURMLENBQ1UsVUFBQSxZQUFZLEVBQUk7QUFDbEIsUUFBSSxZQUFZLEdBQUcsQ0FBbkIsRUFBc0I7QUFDbEIsTUFBQSxJQUFJLENBQUMsU0FBTCxDQUFlLEdBQWYsQ0FBbUIsa0JBQW5CO0FBQ0EsTUFBQSxJQUFJLENBQUMsWUFBTCxDQUFrQixlQUFsQixFQUFtQyxZQUFuQztBQUNILEtBSEQsTUFHTztBQUNILE1BQUEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxNQUFmLENBQXNCLGtCQUF0QjtBQUNIO0FBQ0osR0FSTDtBQVNIOztBQUdELFNBQVMsZ0JBQVQsR0FBNEI7QUFDeEIsTUFBTSxPQUFPLEdBQUc7QUFDWixJQUFBLE1BQU0sRUFBRSxLQURJO0FBRVosSUFBQSxPQUFPLEVBQUU7QUFBRSxzQkFBZ0I7QUFBbEI7QUFGRyxHQUFoQjtBQUtBLFNBQU8sS0FBSyxDQUFDLG9CQUFELEVBQXVCLE9BQXZCLENBQUwsQ0FBcUMsSUFBckMsQ0FBMEMsVUFBQSxHQUFHO0FBQUEsV0FBSSxHQUFHLENBQUMsSUFBSixFQUFKO0FBQUEsR0FBN0MsQ0FBUDtBQUNIOztBQUVELFNBQVMsU0FBVCxHQUFxQjtBQUNqQixNQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsZUFBTixDQUFzQixjQUF0QixDQUF0QjtBQUNBLE1BQU0sWUFBWSxHQUFHLGdCQUFnQixHQUNoQyxJQURnQixDQUNYLFVBQUEsSUFBSSxFQUFJO0FBQUEsK0JBQzBCLElBRDFCO0FBQUEsUUFDSCxhQURHO0FBQUEsUUFDWSxVQURaOztBQUVWLFdBQU8sYUFBUDtBQUNILEdBSmdCLEVBS2hCLElBTGdCLENBS1gsVUFBQSxhQUFhLEVBQUk7QUFDbkIsUUFBSSxjQUFjLEdBQUcsQ0FBckI7O0FBQ0EsUUFBSSxhQUFKLEVBQW1CO0FBQ2YsTUFBQSxhQUFhLENBQUMsT0FBZCxDQUFzQixVQUFBLFlBQVksRUFBSTtBQUNsQyxZQUFJLENBQUMsYUFBYSxDQUFDLFFBQWQsQ0FBdUIsWUFBWSxDQUFDLFVBQXBDLENBQUwsRUFBc0Q7QUFDbEQsVUFBQSxjQUFjO0FBQ2pCO0FBQ0osT0FKRDtBQUtIOztBQUNELFdBQU8sY0FBUDtBQUNILEdBZmdCLENBQXJCO0FBZ0JBLFNBQU8sWUFBUDtBQUNIOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0NEOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVPLFNBQVMsTUFBVCxPQUFnQztBQUFBO0FBQUEsTUFBWixTQUFZOztBQUNuQyxNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUMsS0FBVixDQUFnQixVQUFBLFFBQVE7QUFBQSxXQUFJLFFBQVEsSUFBSSxJQUFoQjtBQUFBLEdBQXhCLENBQWY7QUFDQSxTQUFPLE1BQVA7QUFDSDs7QUFHTSxTQUFTLGVBQVQsQ0FBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUM7QUFDeEMsRUFBQSxZQUFZLENBQUMsT0FBYixDQUFxQixJQUFyQixFQUEyQixJQUFJLENBQUMsU0FBTCxDQUFlLElBQWYsQ0FBM0I7QUFDSDs7QUFHTSxTQUFTLGVBQVQsQ0FBeUIsSUFBekIsRUFBK0I7QUFDbEMsU0FBTyxJQUFJLENBQUMsS0FBTCxDQUFXLFlBQVksQ0FBQyxPQUFiLENBQXFCLElBQXJCLENBQVgsQ0FBUDtBQUNIOztBQUVNLFNBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0M7QUFBRTtBQUNyQyxNQUFJLE9BQUo7O0FBQ0EsTUFBSTtBQUNBLElBQUEsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFELENBQWhCO0FBQ0EsUUFBSSxDQUFDLEdBQUcsa0JBQVI7QUFDQSxJQUFBLE9BQU8sQ0FBQyxPQUFSLENBQWdCLENBQWhCLEVBQW1CLENBQW5CO0FBQ0EsSUFBQSxPQUFPLENBQUMsVUFBUixDQUFtQixDQUFuQjtBQUNBLFdBQU8sSUFBUDtBQUNILEdBTkQsQ0FNRSxPQUFPLENBQVAsRUFBVTtBQUNSLFdBQU8sQ0FBQyxZQUFZLFlBQWIsS0FDQyxDQUFDLENBQUMsSUFBRixLQUFXLEVBQVgsSUFDQSxDQUFDLENBQUMsSUFBRixLQUFXLElBRFgsSUFFQSxDQUFDLENBQUMsSUFBRixLQUFXLG9CQUZYLElBR0EsQ0FBQyxDQUFDLElBQUYsS0FBVyw0QkFKWixLQUtGLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBUixLQUFtQixDQUxuQztBQU1IO0FBQ0o7O0FBRU0sU0FBUyxjQUFULEdBQTBCO0FBQzdCLE1BQUksY0FBSjs7QUFFQSxNQUFJLGdCQUFnQixDQUFDLGNBQUQsQ0FBcEIsRUFBc0M7QUFDbEMsUUFBTSxXQUFXLEdBQUcsZUFBZSxDQUFDLGFBQUQsQ0FBbkM7O0FBQ0EsUUFBSSxXQUFKLEVBQWlCO0FBQ2IsTUFBQSxjQUFjLEdBQUcsT0FBTyxDQUFDLFdBQUQsQ0FBeEI7QUFDSCxLQUZELE1BRU87QUFDSCxNQUFBLGNBQWMsR0FBRyxDQUFDLHNCQUFELEVBQXlCLGdCQUF6QixFQUEyQyxpQkFBM0MsRUFBOEQsaUJBQTlELENBQWpCO0FBQ0g7QUFDSixHQVBELE1BT087QUFDSCxJQUFBLGNBQWMsR0FBRyxDQUFDLHNCQUFELEVBQXlCLGdCQUF6QixFQUEyQyxpQkFBM0MsRUFBOEQsaUJBQTlELENBQWpCO0FBQ0g7O0FBRUQsU0FBTyxjQUFQO0FBQ0g7O0FBRU0sU0FBUyxhQUFULENBQXVCLE1BQXZCLEVBQStCO0FBQ2xDO0FBQ0EsTUFBTSxXQUFXLEdBQUcsQ0FBQyxlQUFELEVBQWtCLGdCQUFsQixFQUFvQyxpQkFBcEMsRUFBdUQsVUFBdkQsQ0FBcEI7QUFDQSxFQUFBLFdBQVcsQ0FBQyxPQUFaLENBQW9CLFVBQUEsT0FBTztBQUFBLFdBQUksUUFBUSxDQUFDLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUMsTUFBakMsRUFBSjtBQUFBLEdBQTNCLEVBSGtDLENBS2xDOztBQUNBLEVBQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxVQUFBLElBQUksRUFBSTtBQUNuQixJQUFBLFFBQVEsQ0FBQyxhQUFULENBQXVCLGNBQXZCLEVBQXVDLE1BQXZDLENBQThDLFFBQVEsQ0FBQyxhQUFULENBQXVCLElBQXZCLENBQTlDOztBQUVBLFFBQUksSUFBSSxLQUFLLGdCQUFiLEVBQStCO0FBQzNCO0FBQ0g7O0FBQ0QsUUFBSSxJQUFJLEtBQUssaUJBQWIsRUFBZ0M7QUFDNUI7QUFDSDs7QUFDRCxRQUFJLElBQUksS0FBSyxpQkFBYixFQUFnQztBQUM1QjtBQUNIOztBQUNELFFBQUksSUFBSSxLQUFLLHNCQUFiLEVBQXFDO0FBQ2pDLGlEQUF1QixXQUF2QjtBQUNIO0FBQ0osR0FmRDtBQWdCSDs7QUFFTSxTQUFTLE9BQVQsQ0FBaUIsV0FBakIsRUFBOEI7QUFDakMsTUFBTSxjQUFjLEdBQUcsRUFBdkIsQ0FEaUMsQ0FHakM7O0FBQ0EsRUFBQSxXQUFXLENBQUMsT0FBWixDQUFvQixVQUFBLFVBQVUsRUFBSTtBQUM5QixJQUFBLFVBQVUsQ0FBQyxFQUFYLEdBQWdCLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBWixDQUF4Qjs7QUFFQSxRQUFJLFVBQVUsQ0FBQyxLQUFYLElBQW9CLFVBQVUsQ0FBQyxFQUFYLEtBQWtCLENBQTFDLEVBQTZDO0FBQ3pDLE1BQUEsY0FBYyxDQUFDLElBQWYsQ0FBb0Isc0JBQXBCO0FBQ0g7O0FBQ0QsUUFBSSxVQUFVLENBQUMsS0FBWCxJQUFvQixVQUFVLENBQUMsRUFBWCxLQUFrQixDQUExQyxFQUE2QztBQUN6QyxNQUFBLGNBQWMsQ0FBQyxJQUFmLENBQW9CLGdCQUFwQjtBQUNIOztBQUNELFFBQUksVUFBVSxDQUFDLEtBQVgsSUFBb0IsVUFBVSxDQUFDLEVBQVgsS0FBa0IsQ0FBMUMsRUFBNkM7QUFDekMsTUFBQSxjQUFjLENBQUMsSUFBZixDQUFvQixpQkFBcEI7QUFDSDs7QUFDRCxRQUFJLFVBQVUsQ0FBQyxLQUFYLElBQW9CLFVBQVUsQ0FBQyxFQUFYLEtBQWtCLENBQTFDLEVBQTZDO0FBQ3pDLE1BQUEsY0FBYyxDQUFDLElBQWYsQ0FBb0IsaUJBQXBCO0FBQ0g7QUFDSixHQWZEO0FBaUJBLFNBQU8sY0FBUDtBQUNIOzs7Ozs7Ozs7O0FDckdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLFVBQXZCLENBQWpCO0FBQ0EsUUFBUSxDQUFDLFNBQVQ7O0FBbUhBLFNBQVMsSUFBVCxDQUFjLFFBQWQsRUFBd0I7QUFBQSxNQUNkLGdCQURjO0FBQUE7O0FBQUE7O0FBRWhCLGdDQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7O0FBRUEsWUFBSyxZQUFMLENBQWtCO0FBQUUsUUFBQSxJQUFJLEVBQUU7QUFBUixPQUFsQjs7QUFDQSxZQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNEIsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsU0FBakIsQ0FBMkIsSUFBM0IsQ0FBNUI7O0FBRUEsWUFBSyxPQUFMLEdBQ0ssSUFETCxDQUNVLFVBQUEsSUFBSSxFQUFJO0FBQUEsbUNBQzBCLElBRDFCO0FBQUEsWUFDSCxhQURHO0FBQUEsWUFDWSxVQURaOztBQUVWLGNBQUssYUFBTCxDQUFtQixVQUFuQjs7QUFDQSxZQUFJLFFBQVEsS0FBSyxXQUFqQixFQUE4QjtBQUMxQixVQUFBLGFBQWEsQ0FBQyxNQUFkLENBQXFCLENBQXJCLEVBQXdCLGFBQWEsQ0FBQyxNQUF0QztBQUNIOztBQUNELGNBQUssbUJBQUwsQ0FBeUIsYUFBekI7QUFDSCxPQVJMOztBQVNBLFlBQUsscUJBQUwsR0FBNkIsTUFBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLDBCQUE5QixDQUE3QjtBQUNBLFlBQUssa0JBQUwsR0FBMEIsTUFBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLHNCQUE5QixDQUExQjtBQWhCVTtBQWlCYjs7QUFuQmU7QUFBQTtBQUFBLGdDQXFCTjtBQUNOLFlBQU0sT0FBTyxHQUFHO0FBQ1osVUFBQSxNQUFNLEVBQUUsS0FESTtBQUVaLFVBQUEsT0FBTyxFQUFFO0FBQUUsNEJBQWdCO0FBQWxCO0FBRkcsU0FBaEI7QUFLQSxlQUFPLEtBQUssQ0FBQyxvQkFBRCxFQUF1QixPQUF2QixDQUFMLENBQXFDLElBQXJDLENBQTBDLFVBQUEsR0FBRztBQUFBLGlCQUFJLEdBQUcsQ0FBQyxJQUFKLEVBQUo7QUFBQSxTQUE3QyxDQUFQO0FBQ0g7QUE1QmU7QUFBQTtBQUFBLG9DQThCRixVQTlCRSxFQThCVTtBQUFBOztBQUN0QixRQUFBLFVBQVUsQ0FBQyxPQUFYLENBQW1CLFVBQUEsR0FBRyxFQUFJO0FBQ3RCLFVBQUEsTUFBSSxDQUFDLGtCQUFMLENBQXdCLGtCQUF4QixDQUEyQyxXQUEzQyx1QkFBcUUsR0FBckUsZ0JBQTZFLEdBQTdFO0FBQ0gsU0FGRDtBQUdIO0FBbENlO0FBQUE7QUFBQSwwQ0FvQ0ksYUFwQ0osRUFvQ21CO0FBQUE7O0FBQy9CLFFBQUEsYUFBYSxDQUFDLE9BQWQsQ0FBc0IsVUFBQSxZQUFZLEVBQUk7QUFDbEMsVUFBQSxNQUFJLENBQUMscUJBQUwsQ0FBMkIsa0JBQTNCLENBQThDLFdBQTlDLCtDQUNjLFlBQVksQ0FBQyxVQUQzQix1Q0FDOEQsWUFBWSxDQUFDLFVBRDNFLHNEQUVnQixZQUFZLENBQUMsSUFBYixDQUFrQixDQUFsQixDQUZoQixxQkFFNkMsWUFBWSxDQUFDLFVBRjFELHlDQUdPLFlBQVksQ0FBQyxLQUhwQiwwQ0FJTyxZQUFZLENBQUMsV0FKcEIsZ0JBSXFDLFlBQVksQ0FBQyxJQUFiLENBQWtCLENBQWxCLENBSnJDOztBQVFBLGNBQUksS0FBSyxDQUFDLGdCQUFOLENBQXVCLGNBQXZCLENBQUosRUFBNEM7QUFDeEMsZ0JBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxlQUFOLENBQXNCLGNBQXRCLENBQXRCO0FBQ0EsWUFBQSxNQUFJLENBQUMsV0FBTCxHQUFtQixhQUFhLEdBQUcsYUFBSCxHQUFtQixFQUFuRDs7QUFFQSxnQkFBTSxJQUFJLEdBQUcsTUFBSSxDQUFDLHFCQUFMLENBQTJCLGFBQTNCLENBQXlDLGdCQUF6QyxDQUFiOztBQUVBLGdCQUFJLE1BQUksQ0FBQyxXQUFMLENBQWlCLFFBQWpCLENBQTBCLElBQUksQ0FBQyxZQUFMLENBQWtCLEtBQWxCLENBQTFCLENBQUosRUFBeUQ7QUFDckQsY0FBQSxJQUFJLENBQUMsU0FBTCxDQUFlLEdBQWYsQ0FBbUIsTUFBbkI7QUFDSDs7QUFDRCxZQUFBLElBQUksQ0FBQyxnQkFBTCxDQUFzQixPQUF0QixFQUErQjtBQUFBLHFCQUFNLE1BQUksQ0FBQyxLQUFMLENBQVcsSUFBWCxDQUFOO0FBQUEsYUFBL0I7QUFDSDtBQUNKLFNBcEJEO0FBcUJIO0FBMURlO0FBQUE7QUFBQSw0QkE0RFYsWUE1RFUsRUE0REk7QUFDaEIsYUFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLFlBQVksQ0FBQyxZQUFiLENBQTBCLEtBQTFCLENBQXRCO0FBQ0EsUUFBQSxLQUFLLENBQUMsZUFBTixDQUFzQixjQUF0QixFQUFzQyxLQUFLLFdBQTNDO0FBQ0g7QUEvRGU7O0FBQUE7QUFBQSxtQ0FDVyxXQURYOztBQWtFcEIsRUFBQSxNQUFNLENBQUMsY0FBUCxDQUFzQixNQUF0QixDQUE2QixzQkFBN0IsRUFBcUQsZ0JBQXJEO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekxELElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLFVBQXZCLENBQWpCO0FBQ0EsUUFBUSxDQUFDLFNBQVQ7O0FBNkdBLFNBQVMsSUFBVCxHQUFnQjtBQUFBLE1BQ04sY0FETTtBQUFBOztBQUFBOztBQUVSLDhCQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7QUFDQTs7QUFDQSxZQUFLLFlBQUwsQ0FBa0I7QUFBRSxRQUFBLElBQUksRUFBRTtBQUFSLE9BQWxCOztBQUNBLFlBQUssVUFBTCxDQUFnQixXQUFoQixDQUE0QixRQUFRLENBQUMsT0FBVCxDQUFpQixTQUFqQixDQUEyQixJQUEzQixDQUE1QixFQUpVLENBTVY7OztBQUNBLFlBQUssZUFBTCxHQUF1QixNQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsQ0FBOEIsa0JBQTlCLENBQXZCO0FBQ0EsWUFBSyxZQUFMLEdBQW9CLE1BQUssVUFBTCxDQUFnQixhQUFoQixDQUE4QixpQkFBOUIsQ0FBcEI7QUFDQSxZQUFLLGFBQUwsR0FBcUIsTUFBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLDhCQUE5QixDQUFyQjtBQUNBLFlBQUssU0FBTCxHQUFpQixNQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsQ0FBOEIsNkJBQTlCLENBQWpCO0FBQ0EsWUFBSyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsWUFBSyxZQUFMLEdBQW9CLENBQXBCLENBWlUsQ0FjVjs7QUFDQSxZQUFLLElBQUwsR0FBWSxNQUFLLE9BQUwsR0FBZSxJQUFmLENBQW9CLFVBQUEsSUFBSSxFQUFJO0FBQ3BDLGNBQUssZUFBTDs7QUFFQSxZQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBSyxTQUFOLENBQUosQ0FBcUIsUUFBckIsQ0FBOEIsTUFBSyxZQUFuQyxFQUFpRCxPQUE5RDs7QUFDQSxjQUFLLG9CQUFMLENBQTBCLElBQTFCOztBQUVBLGNBQUssSUFBTCxHQUFZLElBQVo7QUFDSCxPQVBXLENBQVosQ0FmVSxDQXdCVjs7QUFDQSxZQUFLLGFBQUwsQ0FBbUIsZ0JBQW5CLENBQW9DLE9BQXBDLEVBQTZDO0FBQUEsZUFBTSxNQUFLLFFBQUwsQ0FBYyxVQUFkLENBQU47QUFBQSxPQUE3Qzs7QUFDQSxZQUFLLFNBQUwsQ0FBZSxnQkFBZixDQUFnQyxPQUFoQyxFQUF5QztBQUFBLGVBQU0sTUFBSyxRQUFMLENBQWMsTUFBZCxDQUFOO0FBQUEsT0FBekM7O0FBMUJVO0FBMkJiOztBQTdCTztBQUFBO0FBQUEsd0NBK0JVO0FBQ2QsYUFBSyxZQUFMLENBQWtCLFdBQWxCLGtCQUF3QyxLQUFLLFNBQUwsR0FBaUIsQ0FBekQscUJBQXFFLEtBQUssWUFBTCxHQUFvQixDQUF6RjtBQUNIO0FBakNPO0FBQUE7QUFBQSwyQ0FtQ2EsT0FuQ2IsRUFtQ3NCO0FBQUE7O0FBQzFCLGFBQUssZUFBTCxDQUFxQixXQUFyQixHQUFtQyxFQUFuQztBQUNBLGFBQUssZUFBTDtBQUVBLFFBQUEsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsVUFBQSxNQUFNLEVBQUk7QUFDdEIsY0FBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBLFVBQUEsR0FBRyxDQUFDLFNBQUosQ0FBYyxHQUFkLENBQWtCLFFBQWxCO0FBRUEsY0FBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBbkI7QUFDQSxVQUFBLFVBQVUsQ0FBQyxXQUFYLEdBQXlCLE1BQU0sQ0FBQyxNQUFoQztBQUNBLFVBQUEsR0FBRyxDQUFDLE1BQUosQ0FBVyxVQUFYO0FBRUEsY0FBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBYjtBQUNBLFVBQUEsTUFBTSxDQUFDLFNBQVAsQ0FBaUIsT0FBakIsQ0FBeUIsVUFBQSxRQUFRLEVBQUk7QUFDakMsZ0JBQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLElBQXZCLENBQWhCO0FBQ0EsWUFBQSxRQUFRLEtBQUssRUFBYixHQUFrQixPQUFPLENBQUMsV0FBUixHQUFzQix3QkFBeEMsR0FBbUUsT0FBTyxDQUFDLFdBQVIsR0FBc0IsUUFBekY7QUFDQSxZQUFBLElBQUksQ0FBQyxNQUFMLENBQVksT0FBWjtBQUNILFdBSkQ7QUFLQSxVQUFBLEdBQUcsQ0FBQyxNQUFKLENBQVcsSUFBWDs7QUFFQSxVQUFBLE1BQUksQ0FBQyxlQUFMLENBQXFCLE1BQXJCLENBQTRCLEdBQTVCO0FBQ0gsU0FqQkQ7QUFrQkg7QUF6RE87QUFBQTtBQUFBLCtCQTJEQyxTQTNERCxFQTJEWTtBQUNoQixZQUFJLFNBQVMsS0FBSyxVQUFsQixFQUE4QjtBQUMxQixjQUFJLEtBQUssWUFBTCxHQUFvQixDQUF4QixFQUEyQjtBQUN2QixpQkFBSyxZQUFMO0FBQ0gsV0FGRCxNQUVPLElBQUksS0FBSyxZQUFMLEtBQXNCLENBQXRCLElBQTJCLEtBQUssU0FBTCxHQUFpQixDQUFoRCxFQUFtRDtBQUN0RCxpQkFBSyxZQUFMLEdBQW9CLENBQXBCO0FBQ0EsaUJBQUssU0FBTDtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxTQUFTLEtBQUssTUFBbEIsRUFBMEI7QUFDdEIsY0FBSSxLQUFLLFlBQUwsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDdkIsaUJBQUssWUFBTDtBQUNILFdBRkQsTUFFTyxJQUFJLEtBQUssWUFBTCxLQUFzQixDQUF0QixJQUEyQixLQUFLLFNBQUwsR0FBaUIsQ0FBaEQsRUFBbUQ7QUFDdEQsaUJBQUssWUFBTCxHQUFvQixDQUFwQjtBQUNBLGlCQUFLLFNBQUw7QUFDSDtBQUNKOztBQUVELGFBQUssZUFBTDtBQUVBLFlBQU0sSUFBSSxHQUFHLEtBQUssSUFBTCxDQUFVLEtBQUssU0FBZixFQUEwQixRQUExQixDQUFtQyxLQUFLLFlBQXhDLEVBQXNELE9BQW5FO0FBQ0EsYUFBSyxvQkFBTCxDQUEwQixJQUExQjtBQUNIO0FBbEZPO0FBQUE7QUFBQSx3Q0FvRlU7QUFDZCxhQUFLLFNBQUwsS0FBbUIsQ0FBbkIsSUFBd0IsS0FBSyxZQUFMLEtBQXNCLENBQTlDLEdBQ0ksS0FBSyxhQUFMLENBQW1CLFNBQW5CLENBQTZCLEdBQTdCLENBQWlDLFVBQWpDLENBREosR0FDbUQsS0FBSyxhQUFMLENBQW1CLFNBQW5CLENBQTZCLE1BQTdCLENBQW9DLFVBQXBDLENBRG5EO0FBR0EsYUFBSyxTQUFMLEtBQW1CLENBQW5CLElBQXdCLEtBQUssWUFBTCxLQUFzQixDQUE5QyxHQUNJLEtBQUssU0FBTCxDQUFlLFNBQWYsQ0FBeUIsR0FBekIsQ0FBNkIsVUFBN0IsQ0FESixHQUMrQyxLQUFLLFNBQUwsQ0FBZSxTQUFmLENBQXlCLE1BQXpCLENBQWdDLFVBQWhDLENBRC9DO0FBRUgsT0ExRk8sQ0E0RlI7O0FBNUZRO0FBQUE7QUFBQSxnQ0E2RkU7QUFDTixZQUFNLE9BQU8sR0FBRztBQUNaLFVBQUEsTUFBTSxFQUFFLEtBREk7QUFFWixVQUFBLE9BQU8sRUFBRTtBQUFFLDRCQUFnQjtBQUFsQjtBQUZHLFNBQWhCO0FBS0EsZUFBTyxLQUFLLENBQUMsaUJBQUQsRUFBb0IsT0FBcEIsQ0FBTCxDQUFrQyxJQUFsQyxDQUF1QyxVQUFBLEdBQUc7QUFBQSxpQkFBSSxHQUFHLENBQUMsSUFBSixFQUFKO0FBQUEsU0FBMUMsQ0FBUDtBQUNIO0FBcEdPOztBQUFBO0FBQUEsbUNBQ2lCLFdBRGpCOztBQXVHWixFQUFBLGNBQWMsQ0FBQyxNQUFmLENBQXNCLGlCQUF0QixFQUF5QyxjQUF6QztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RORCxJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixVQUF2QixDQUFqQjtBQUNBLFFBQVEsQ0FBQyxTQUFUOztBQTBGQSxTQUFTLElBQVQsR0FBZ0I7QUFBQSxNQUNOLFFBRE07QUFBQTs7QUFBQTs7QUFFUix3QkFBYztBQUFBOztBQUFBOztBQUNWOztBQUVBLFlBQUssWUFBTCxDQUFrQjtBQUFFLFFBQUEsSUFBSSxFQUFFO0FBQVIsT0FBbEI7O0FBQ0EsWUFBSyxVQUFMLENBQWdCLFdBQWhCLENBQTRCLFFBQVEsQ0FBQyxPQUFULENBQWlCLFNBQWpCLENBQTJCLElBQTNCLENBQTVCOztBQUVBLFlBQUssSUFBTCxHQUFZLE1BQUssT0FBTCxHQUNQLElBRE8sQ0FDRixVQUFBLElBQUksRUFBSTtBQUNWLGNBQUssY0FBTCxDQUFvQixJQUFJLENBQUMsQ0FBRCxDQUF4Qjs7QUFDQSxjQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0gsT0FKTyxDQUFaO0FBTUEsWUFBSyxTQUFMLEdBQWlCLE1BQUssVUFBTCxDQUFnQixhQUFoQixDQUE4QixZQUE5QixDQUFqQjtBQUNBLFlBQUssYUFBTCxHQUFxQixNQUFLLFNBQUwsQ0FBZSxhQUFmLENBQTZCLG1CQUE3QixDQUFyQjtBQUNBLFlBQUssU0FBTCxHQUFpQixNQUFLLFNBQUwsQ0FBZSxhQUFmLENBQTZCLGtCQUE3QixDQUFqQjs7QUFFQSxZQUFLLFNBQUwsQ0FBZSxnQkFBZixDQUFnQyxPQUFoQyxFQUF5QztBQUFBLGVBQU0sTUFBSyxRQUFMLENBQWMsTUFBZCxDQUFOO0FBQUEsT0FBekM7O0FBQ0EsWUFBSyxhQUFMLENBQW1CLGdCQUFuQixDQUFvQyxPQUFwQyxFQUE2QztBQUFBLGVBQU0sTUFBSyxRQUFMLENBQWMsVUFBZCxDQUFOO0FBQUEsT0FBN0M7O0FBQ0EsWUFBSyxLQUFMLEdBQWEsQ0FBYjtBQWxCVTtBQW1CYjs7QUFyQk87QUFBQTtBQUFBLGdDQXVCRTtBQUNOLFlBQU0sT0FBTyxHQUFHO0FBQ1osVUFBQSxNQUFNLEVBQUUsS0FESTtBQUVaLFVBQUEsT0FBTyxFQUFFO0FBQUUsNEJBQWdCO0FBQWxCO0FBRkcsU0FBaEI7QUFLQSxlQUFPLEtBQUssQ0FBQyxXQUFELEVBQWMsT0FBZCxDQUFMLENBQTRCLElBQTVCLENBQWlDLFVBQUEsR0FBRztBQUFBLGlCQUFJLEdBQUcsQ0FBQyxJQUFKLEVBQUo7QUFBQSxTQUFwQyxDQUFQO0FBQ0g7QUE5Qk87QUFBQTtBQUFBLHFDQWdDTyxJQWhDUCxFQWdDYTtBQUNqQixZQUFNLGtCQUFrQixHQUFHLEtBQUssVUFBTCxDQUFnQixjQUFoQixDQUErQixxQkFBL0IsQ0FBM0I7QUFDQSxRQUFBLGtCQUFrQixDQUFDLFdBQW5CLEdBQWlDLEVBQWpDO0FBRUEsYUFBSyxTQUFMLENBQWUsYUFBZixDQUE2QixNQUE3QixFQUFxQyxXQUFyQyxhQUFzRCxJQUFJLENBQUMsR0FBM0QsY0FBa0UsSUFBSSxDQUFDLEtBQXZFLGNBQWdGLElBQUksQ0FBQyxJQUFyRjtBQUVBLFFBQUEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxPQUFmLENBQXVCLFVBQUEsUUFBUSxFQUFJO0FBQy9CLGNBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxTQUFULEdBQXFCLFFBQVEsQ0FBQyxTQUFULENBQW1CLEtBQW5CLENBQXlCLENBQXpCLEVBQTRCLFlBQWpELEdBQWdFLGFBQWxGO0FBRUEsY0FBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBLFVBQUEsR0FBRyxDQUFDLFNBQUosQ0FBYyxHQUFkLENBQWtCLGlCQUFsQjtBQUNBLFVBQUEsa0JBQWtCLENBQUMsV0FBbkIsQ0FBK0IsR0FBL0I7QUFFQSxjQUFNLElBQUksR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixHQUF2QixDQUFiO0FBQ0EsVUFBQSxJQUFJLENBQUMsV0FBTCxhQUFzQixRQUFRLENBQUMsYUFBVCxDQUF1QixJQUE3QyxnQkFBdUQsUUFBUSxDQUFDLFdBQVQsQ0FBcUIsSUFBNUU7QUFDQSxVQUFBLEdBQUcsQ0FBQyxXQUFKLENBQWdCLElBQWhCO0FBRUEsY0FBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBYjtBQUNBLFVBQUEsSUFBSSxDQUFDLFdBQUwsR0FBbUIsUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsT0FBaEIsQ0FBd0IsQ0FBeEIsRUFBMkIsS0FBOUM7QUFDQSxVQUFBLEdBQUcsQ0FBQyxXQUFKLENBQWdCLElBQWhCO0FBRUEsY0FBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBYjtBQUNBLFVBQUEsSUFBSSxDQUFDLFdBQUwsR0FBbUIsU0FBbkI7QUFDQSxVQUFBLEdBQUcsQ0FBQyxXQUFKLENBQWdCLElBQWhCO0FBRUEsY0FBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBaEI7QUFDQSxVQUFBLE9BQU8sQ0FBQyxXQUFSLEdBQXNCLFFBQVEsQ0FBQyxNQUFULENBQWdCLFNBQWhCLENBQTBCLENBQTFCLEVBQTZCLEtBQW5EO0FBQ0EsVUFBQSxHQUFHLENBQUMsV0FBSixDQUFnQixPQUFoQjtBQUNILFNBdEJEO0FBdUJIO0FBN0RPO0FBQUE7QUFBQSwrQkErREMsU0EvREQsRUErRFk7QUFDaEIsUUFBQSxTQUFTLEtBQUssVUFBZCxHQUEyQixLQUFLLEtBQUwsRUFBM0IsR0FBMEMsS0FBSyxLQUFMLEVBQTFDO0FBRUEsYUFBSyxLQUFMLEtBQWUsQ0FBZixHQUFtQixLQUFLLGFBQUwsQ0FBbUIsU0FBbkIsQ0FBNkIsR0FBN0IsQ0FBaUMsVUFBakMsQ0FBbkIsR0FBa0UsS0FBSyxhQUFMLENBQW1CLFNBQW5CLENBQTZCLE1BQTdCLENBQW9DLFVBQXBDLENBQWxFO0FBQ0EsYUFBSyxLQUFMLEtBQWUsQ0FBZixHQUFtQixLQUFLLFNBQUwsQ0FBZSxTQUFmLENBQXlCLEdBQXpCLENBQTZCLFVBQTdCLENBQW5CLEdBQThELEtBQUssU0FBTCxDQUFlLFNBQWYsQ0FBeUIsTUFBekIsQ0FBZ0MsVUFBaEMsQ0FBOUQ7QUFFQSxhQUFLLGNBQUwsQ0FBb0IsS0FBSyxJQUFMLENBQVUsS0FBSyxLQUFmLENBQXBCO0FBQ0g7QUF0RU87O0FBQUE7QUFBQSxtQ0FDVyxXQURYOztBQXlFWixFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE1BQXRCLENBQTZCLGlCQUE3QixFQUFnRCxRQUFoRDtBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JLRCxJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixVQUF2QixDQUFqQjtBQUNBLFFBQVEsQ0FBQyxTQUFUOztBQXVJQSxTQUFTLElBQVQsR0FBZ0I7QUFBQSxNQUNOLGFBRE07QUFBQTs7QUFBQTs7QUFFUiw2QkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0E7O0FBQ0EsWUFBSyxZQUFMLENBQWtCO0FBQUUsUUFBQSxJQUFJLEVBQUU7QUFBUixPQUFsQjs7QUFDQSxZQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNEIsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsU0FBakIsQ0FBMkIsSUFBM0IsQ0FBNUI7O0FBRUEsWUFBSyxPQUFMLEdBQWUsSUFBZixDQUFvQixVQUFBLElBQUksRUFBSTtBQUFBLG1DQUNJLElBREo7QUFBQSxZQUNqQixPQURpQjtBQUFBLFlBQ1IsUUFEUTs7QUFHeEIsY0FBSyxlQUFMLENBQXFCLE9BQXJCOztBQUNBLGNBQUssaUJBQUwsQ0FBdUIsUUFBdkI7QUFDSCxPQUxEOztBQU9BLFlBQUssZ0JBQUwsR0FBd0IsTUFBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLGlCQUE5QixDQUF4QjtBQUNBLFlBQUssaUJBQUwsR0FBeUIsTUFBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLGtCQUE5QixDQUF6QjtBQWRVO0FBZWI7O0FBakJPO0FBQUE7QUFBQSx3Q0FtQlUsT0FuQlYsRUFtQm1CO0FBQUE7O0FBQ3ZCLFFBQUEsT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsVUFBQSxNQUFNLEVBQUk7QUFDdEIsY0FBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjs7QUFDQSxjQUFJLE1BQU0sQ0FBQyxXQUFYLEVBQXdCO0FBQ3BCLFlBQUEsR0FBRyxDQUFDLFNBQUosQ0FBYyxHQUFkLENBQWtCLGNBQWxCO0FBQ0g7O0FBRUQsY0FBTSxRQUFRLDBFQUVBLE1BQU0sQ0FBQyxTQUZQLHNDQUdULE1BQU0sQ0FBQyxXQUFQLENBQW1CLFFBSFYsY0FHc0IsTUFBTSxDQUFDLFdBQVAsQ0FBbUIsU0FIekMsc0JBQWQsQ0FOc0IsQ0FXdEI7QUFDQTs7QUFFQSxVQUFBLEdBQUcsQ0FBQyxTQUFKLEdBQWdCLFFBQWhCOztBQUNBLFVBQUEsTUFBSSxDQUFDLGlCQUFMLENBQXVCLE1BQXZCLENBQThCLEdBQTlCO0FBQ0gsU0FoQkQ7QUFpQkg7QUFyQ087QUFBQTtBQUFBLHNDQXdDUSxPQXhDUixFQXdDaUI7QUFBQTs7QUFDckIsUUFBQSxPQUFPLENBQUMsT0FBUixDQUFnQixVQUFBLE1BQU0sRUFBSTtBQUN0QjtBQUNBLGNBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFFQSxjQUFJLFNBQUo7O0FBQ0EsY0FBSSxPQUFPLE1BQU0sQ0FBQyxLQUFkLEtBQXdCLFFBQXhCLElBQW9DLE1BQU0sQ0FBQyxLQUFQLElBQWdCLEdBQXBELElBQTJELE1BQU0sQ0FBQyxLQUFQLEtBQWlCLEdBQWhGLEVBQXFGO0FBQ2pGLFlBQUEsU0FBUyxvQ0FBVDtBQUNILFdBRkQsTUFFTyxJQUFJLE9BQU8sTUFBTSxDQUFDLEtBQWQsS0FBd0IsUUFBeEIsSUFBb0MsTUFBTSxDQUFDLEtBQVAsR0FBZSxHQUFuRCxJQUEwRCxNQUFNLENBQUMsS0FBUCxLQUFpQixHQUEzRSxJQUFrRixNQUFNLENBQUMsS0FBUCxLQUFpQixJQUF2RyxFQUE2RztBQUNoSCxZQUFBLFNBQVMsbUNBQVQ7QUFDSDs7QUFFRCxjQUFNLFFBQVEsK0JBQ1osU0FEWSxrQ0FFVCxNQUFNLENBQUMsTUFBUCxDQUFjLE1BQWQsQ0FBcUIsS0FGWixzQ0FHVCxNQUFNLENBQUMsS0FIRSxzQ0FJVCxNQUFNLENBQUMsUUFKRSwyQkFBZDtBQU9BLFVBQUEsR0FBRyxDQUFDLFNBQUosR0FBZ0IsUUFBaEI7O0FBQ0EsVUFBQSxNQUFJLENBQUMsZ0JBQUwsQ0FBc0IsTUFBdEIsQ0FBNkIsR0FBN0I7QUFDSCxTQXBCRDtBQXFCSCxPQTlETyxDQWdFUjs7QUFoRVE7QUFBQTtBQUFBLGdDQWlFRTtBQUNOLFlBQU0sT0FBTyxHQUFHO0FBQ1osVUFBQSxNQUFNLEVBQUUsS0FESTtBQUVaLFVBQUEsT0FBTyxFQUFFO0FBQUUsNEJBQWdCO0FBQWxCO0FBRkcsU0FBaEI7QUFLQSxlQUFPLEtBQUssQ0FBQyxnQkFBRCxFQUFtQixPQUFuQixDQUFMLENBQWlDLElBQWpDLENBQXNDLFVBQUEsR0FBRztBQUFBLGlCQUFJLEdBQUcsQ0FBQyxJQUFKLEVBQUo7QUFBQSxTQUF6QyxDQUFQO0FBQ0g7QUF4RU87O0FBQUE7QUFBQSxtQ0FDZ0IsV0FEaEI7O0FBMkVaLEVBQUEsY0FBYyxDQUFDLE1BQWYsQ0FBc0IsZ0JBQXRCLEVBQXdDLGFBQXhDO0FBQ0g7Ozs7Ozs7Ozs7QUN0TkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsSUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsVUFBdkIsQ0FBakI7O0FBQ0EsUUFBUSxDQUFDLFNBQVQ7O0lBc0NNLGtCOzs7OztBQUVGLGdDQUFjO0FBQUE7O0FBQUE7O0FBQ1Y7O0FBRUEsVUFBSyxZQUFMLENBQWtCO0FBQUUsTUFBQSxJQUFJLEVBQUU7QUFBUixLQUFsQjs7QUFDQSxVQUFLLFVBQUwsQ0FBZ0IsV0FBaEIsQ0FBNEIsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsU0FBakIsQ0FBMkIsSUFBM0IsQ0FBNUI7O0FBQ0EsVUFBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLEdBQTlCLEVBQW1DLFdBQW5DLEdBQWlELE1BQUssWUFBTCxDQUFrQixTQUFsQixDQUFqRDs7QUFDQSxVQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsQ0FBOEIsS0FBOUIsRUFBcUMsZ0JBQXJDLENBQXNELE9BQXRELEVBQStELFlBQU07QUFDakUsWUFBSyxJQUFMOztBQUNBLFlBQUssS0FBTDtBQUNILEtBSEQ7O0FBTlU7QUFVYjs7Ozs2Q0FNd0IsSSxFQUFNLFEsRUFBVSxRLEVBQVU7QUFDL0MsVUFBSSxRQUFRLElBQUksUUFBWixJQUF3QixRQUFRLElBQUksRUFBeEMsRUFBNEM7QUFDeEMsWUFBTSxHQUFHLEdBQUcsS0FBSyxZQUFMLENBQWtCLEtBQWxCLENBQVo7O0FBQ0EsWUFBSSxLQUFLLENBQUMsZ0JBQU4sQ0FBdUIsY0FBdkIsQ0FBSixFQUE0QztBQUN4QyxjQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsZUFBTixDQUFzQixjQUF0QixDQUF0Qjs7QUFDQSxjQUFJLGFBQUosRUFBbUI7QUFDZixnQkFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFkLENBQXVCLEdBQXZCLENBQUwsRUFBa0M7QUFDOUIsbUJBQUssYUFBTDtBQUNBLG1CQUFLLElBQUw7QUFDSDtBQUNKLFdBTEQsTUFLTztBQUNILGlCQUFLLGFBQUw7QUFDQSxpQkFBSyxJQUFMO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7OztvQ0FFZTtBQUNaLFdBQUssVUFBTCxDQUFnQixhQUFoQixDQUE4QixHQUE5QixFQUFtQyxXQUFuQyxHQUFpRCxLQUFLLFlBQUwsQ0FBa0IsU0FBbEIsQ0FBakQ7QUFDSDs7OzJCQUVNO0FBQ0gsV0FBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLEtBQTlCLEVBQXFDLFNBQXJDLENBQStDLE1BQS9DLENBQXNELE1BQXREO0FBQ0EsTUFBQSxRQUFRLENBQUMsYUFBVCxDQUF1QixNQUF2QixFQUErQixTQUEvQixDQUF5QyxHQUF6QyxDQUE2QyxtQkFBN0M7QUFDSDs7OzJCQUVNO0FBQ0gsV0FBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLEtBQTlCLEVBQXFDLFNBQXJDLENBQStDLEdBQS9DLENBQW1ELE1BQW5EO0FBQ0EsTUFBQSxRQUFRLENBQUMsYUFBVCxDQUF1QixNQUF2QixFQUErQixTQUEvQixDQUF5QyxNQUF6QyxDQUFnRCxtQkFBaEQ7QUFDSDs7OzRCQUVPO0FBQ0osVUFBSSxLQUFLLENBQUMsZ0JBQU4sQ0FBdUIsY0FBdkIsQ0FBSixFQUE0QztBQUN4QyxZQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsZUFBTixDQUFzQixjQUF0QixDQUF0QjtBQUNBLFlBQU0sV0FBVyxHQUFHLGFBQWEsR0FBRyxhQUFILEdBQW1CLEVBQXBEO0FBRUEsUUFBQSxXQUFXLENBQUMsSUFBWixDQUFpQixLQUFLLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBakI7QUFDQSxRQUFBLEtBQUssQ0FBQyxlQUFOLENBQXNCLGNBQXRCLEVBQXNDLFdBQXRDO0FBQ0g7QUFDSjs7O3dCQTVDK0I7QUFDNUIsYUFBTyxDQUFDLEtBQUQsQ0FBUDtBQUNIOzs7O2lDQWhCNEIsVzs7QUE2RGpDLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE1BQXRCLENBQTZCLHFCQUE3QixFQUFvRCxrQkFBcEQiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKiohXG4gKiBTb3J0YWJsZSAxLjEwLjJcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGF1dGhvclx0b3dlbm0gICAgPG93ZW4yMzM1NUBnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Tb3J0YWJsZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gICAgdmFyIGtleSwgaTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBcIjEuMTAuMlwiO1xuXG4gIGZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICAgIHJldHVybiAhIVxuICAgICAgLypAX19QVVJFX18qL1xuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChwYXR0ZXJuKTtcbiAgICB9XG4gIH1cblxuICB2YXIgSUUxMU9yTGVzcyA9IHVzZXJBZ2VudCgvKD86VHJpZGVudC4qcnZbIDpdPzExXFwufG1zaWV8aWVtb2JpbGV8V2luZG93cyBQaG9uZSkvaSk7XG4gIHZhciBFZGdlID0gdXNlckFnZW50KC9FZGdlL2kpO1xuICB2YXIgRmlyZUZveCA9IHVzZXJBZ2VudCgvZmlyZWZveC9pKTtcbiAgdmFyIFNhZmFyaSA9IHVzZXJBZ2VudCgvc2FmYXJpL2kpICYmICF1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiAhdXNlckFnZW50KC9hbmRyb2lkL2kpO1xuICB2YXIgSU9TID0gdXNlckFnZW50KC9pUChhZHxvZHxob25lKS9pKTtcbiAgdmFyIENocm9tZUZvckFuZHJvaWQgPSB1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiB1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG5cbiAgdmFyIGNhcHR1cmVNb2RlID0ge1xuICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH07XG5cbiAgZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBmbikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBmbikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVzKFxuICAvKipIVE1MRWxlbWVudCovXG4gIGVsLFxuICAvKipTdHJpbmcqL1xuICBzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IpIHJldHVybjtcbiAgICBzZWxlY3RvclswXSA9PT0gJz4nICYmIChzZWxlY3RvciA9IHNlbGVjdG9yLnN1YnN0cmluZygxKSk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbC5tYXRjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsLm1zTWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50T3JIb3N0KGVsKSB7XG4gICAgcmV0dXJuIGVsLmhvc3QgJiYgZWwgIT09IGRvY3VtZW50ICYmIGVsLmhvc3Qubm9kZVR5cGUgPyBlbC5ob3N0IDogZWwucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3Nlc3QoXG4gIC8qKkhUTUxFbGVtZW50Ki9cbiAgZWwsXG4gIC8qKlN0cmluZyovXG4gIHNlbGVjdG9yLFxuICAvKipIVE1MRWxlbWVudCovXG4gIGN0eCwgaW5jbHVkZUNUWCkge1xuICAgIGlmIChlbCkge1xuICAgICAgY3R4ID0gY3R4IHx8IGRvY3VtZW50O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsICYmIChzZWxlY3RvclswXSA9PT0gJz4nID8gZWwucGFyZW50Tm9kZSA9PT0gY3R4ICYmIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSA6IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkgfHwgaW5jbHVkZUNUWCAmJiBlbCA9PT0gY3R4KSB7XG4gICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsID09PSBjdHgpIGJyZWFrO1xuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICB9IHdoaWxlIChlbCA9IGdldFBhcmVudE9ySG9zdChlbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIFJfU1BBQ0UgPSAvXFxzKy9nO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsLCBuYW1lLCBzdGF0ZSkge1xuICAgIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdFtzdGF0ZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IChjbGFzc05hbWUgKyAoc3RhdGUgPyAnICcgKyBuYW1lIDogJycpKS5yZXBsYWNlKFJfU1BBQ0UsICcgJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3NzKGVsLCBwcm9wLCB2YWwpIHtcbiAgICB2YXIgc3R5bGUgPSBlbCAmJiBlbC5zdHlsZTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgIHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wID09PSB2b2lkIDAgPyB2YWwgOiB2YWxbcHJvcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xuICAgICAgICAgIHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlW3Byb3BdID0gdmFsICsgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gJycgOiAncHgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXRyaXgoZWwsIHNlbGZPbmx5KSB7XG4gICAgdmFyIGFwcGxpZWRUcmFuc2Zvcm1zID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gY3NzKGVsLCAndHJhbnNmb3JtJyk7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09ICdub25lJykge1xuICAgICAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gdHJhbnNmb3JtICsgJyAnICsgYXBwbGllZFRyYW5zZm9ybXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgICB9IHdoaWxlICghc2VsZk9ubHkgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICAgIH1cblxuICAgIHZhciBtYXRyaXhGbiA9IHdpbmRvdy5ET01NYXRyaXggfHwgd2luZG93LldlYktpdENTU01hdHJpeCB8fCB3aW5kb3cuQ1NTTWF0cml4IHx8IHdpbmRvdy5NU0NTU01hdHJpeDtcbiAgICAvKmpzaGludCAtVzA1NiAqL1xuXG4gICAgcmV0dXJuIG1hdHJpeEZuICYmIG5ldyBtYXRyaXhGbihhcHBsaWVkVHJhbnNmb3Jtcyk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgICBpZiAoY3R4KSB7XG4gICAgICB2YXIgbGlzdCA9IGN0eC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGl0ZXJhdG9yKGxpc3RbaV0sIGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSB7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuXG4gICAgaWYgKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBcImJvdW5kaW5nIGNsaWVudCByZWN0XCIgb2YgZ2l2ZW4gZWxlbWVudFxyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvc2UgYm91bmRpbmdDbGllbnRSZWN0IGlzIHdhbnRlZFxyXG4gICAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgYmxvY2sgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaW5lclxyXG4gICAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIHJlbGF0aXZlIHBhcmVudCBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpZW5yXHJcbiAgICogQHBhcmFtICB7W0Jvb2xlYW5dfSB1bmRvU2NhbGUgICAgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBjb250YWluZXIncyBzY2FsZSgpIHNob3VsZCBiZSB1bmRvbmVcclxuICAgKiBAcGFyYW0gIHtbSFRNTEVsZW1lbnRdfSBjb250YWluZXIgICAgICAgICAgICAgIFRoZSBwYXJlbnQgdGhlIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgZWwsIHdpdGggc3BlY2lmaWVkIGFkanVzdG1lbnRzXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRSZWN0KGVsLCByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrLCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50LCB1bmRvU2NhbGUsIGNvbnRhaW5lcikge1xuICAgIGlmICghZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsICE9PSB3aW5kb3cpIHJldHVybjtcbiAgICB2YXIgZWxSZWN0LCB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGhlaWdodCwgd2lkdGg7XG5cbiAgICBpZiAoZWwgIT09IHdpbmRvdyAmJiBlbCAhPT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRvcCA9IGVsUmVjdC50b3A7XG4gICAgICBsZWZ0ID0gZWxSZWN0LmxlZnQ7XG4gICAgICBib3R0b20gPSBlbFJlY3QuYm90dG9tO1xuICAgICAgcmlnaHQgPSBlbFJlY3QucmlnaHQ7XG4gICAgICBoZWlnaHQgPSBlbFJlY3QuaGVpZ2h0O1xuICAgICAgd2lkdGggPSBlbFJlY3Qud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgICBsZWZ0ID0gMDtcbiAgICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIH1cblxuICAgIGlmICgocmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50KSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIHRyYW5zbGF0ZSgpXG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZWwucGFyZW50Tm9kZTsgLy8gc29sdmVzICMxMTIzIChzZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzk1MzgwNi82MDg4MzEyKVxuICAgICAgLy8gTm90IG5lZWRlZCBvbiA8PSBJRTExXG5cbiAgICAgIGlmICghSUUxMU9yTGVzcykge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChjc3MoY29udGFpbmVyLCAndHJhbnNmb3JtJykgIT09ICdub25lJyB8fCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICYmIGNzcyhjb250YWluZXIsICdwb3NpdGlvbicpICE9PSAnc3RhdGljJykpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBTZXQgcmVsYXRpdmUgdG8gZWRnZXMgb2YgcGFkZGluZyBib3ggb2YgY29udGFpbmVyXG5cbiAgICAgICAgICAgIHRvcCAtPSBjb250YWluZXJSZWN0LnRvcCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItdG9wLXdpZHRoJykpO1xuICAgICAgICAgICAgbGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSk7XG4gICAgICAgICAgICBib3R0b20gPSB0b3AgKyBlbFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgZWxSZWN0LndpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgICAgICB9IHdoaWxlIChjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVuZG9TY2FsZSAmJiBlbCAhPT0gd2luZG93KSB7XG4gICAgICAvLyBBZGp1c3QgZm9yIHNjYWxlKClcbiAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChjb250YWluZXIgfHwgZWwpLFxuICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZDtcblxuICAgICAgaWYgKGVsTWF0cml4KSB7XG4gICAgICAgIHRvcCAvPSBzY2FsZVk7XG4gICAgICAgIGxlZnQgLz0gc2NhbGVYO1xuICAgICAgICB3aWR0aCAvPSBzY2FsZVg7XG4gICAgICAgIGhlaWdodCAvPSBzY2FsZVk7XG4gICAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICAgICAgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIHNpZGUgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCBwYXN0IGEgc2lkZSBvZiBpdHMgcGFyZW50c1xyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgICAgIFRoZSBlbGVtZW50IHdobydzIHNpZGUgYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgaXMgaW4gcXVlc3Rpb25cclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIGVsU2lkZSAgICAgICBTaWRlIG9mIHRoZSBlbGVtZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHBhcmVudFNpZGUgICBTaWRlIG9mIHRoZSBwYXJlbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgIFRoZSBwYXJlbnQgc2Nyb2xsIGVsZW1lbnQgdGhhdCB0aGUgZWwncyBzaWRlIGlzIHNjcm9sbGVkIHBhc3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1Njcm9sbGVkUGFzdChlbCwgZWxTaWRlLCBwYXJlbnRTaWRlKSB7XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCB0cnVlKSxcbiAgICAgICAgZWxTaWRlVmFsID0gZ2V0UmVjdChlbClbZWxTaWRlXTtcbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICB2YXIgcGFyZW50U2lkZVZhbCA9IGdldFJlY3QocGFyZW50KVtwYXJlbnRTaWRlXSxcbiAgICAgICAgICB2aXNpYmxlID0gdm9pZCAwO1xuXG4gICAgICBpZiAocGFyZW50U2lkZSA9PT0gJ3RvcCcgfHwgcGFyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPj0gcGFyZW50U2lkZVZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPD0gcGFyZW50U2lkZVZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2aXNpYmxlKSByZXR1cm4gcGFyZW50O1xuICAgICAgaWYgKHBhcmVudCA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcbiAgICAgIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHBhcmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBHZXRzIG50aCBjaGlsZCBvZiBlbCwgaWdub3JpbmcgaGlkZGVuIGNoaWxkcmVuLCBzb3J0YWJsZSdzIGVsZW1lbnRzIChkb2VzIG5vdCBpZ25vcmUgY2xvbmUgaWYgaXQncyB2aXNpYmxlKVxyXG4gICAqIGFuZCBub24tZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFRoZSBwYXJlbnQgZWxlbWVudFxyXG4gICAqIEBwYXJhbSAge051bWJlcn0gY2hpbGROdW0gICAgICBUaGUgaW5kZXggb2YgdGhlIGNoaWxkXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAgICAgIFBhcmVudCBTb3J0YWJsZSdzIG9wdGlvbnNcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGNoaWxkIGF0IGluZGV4IGNoaWxkTnVtLCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zKSB7XG4gICAgdmFyIGN1cnJlbnRDaGlsZCA9IDAsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGkgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmdob3N0ICYmIGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5kcmFnZ2VkICYmIGNsb3Nlc3QoY2hpbGRyZW5baV0sIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q2hpbGQgPT09IGNoaWxkTnVtKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudENoaWxkKys7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcclxuICAgKiBHZXRzIHRoZSBsYXN0IGNoaWxkIGluIHRoZSBlbCwgaWdub3JpbmcgZ2hvc3RFbCBvciBpbnZpc2libGUgZWxlbWVudHMgKGNsb25lcylcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgUGFyZW50IGVsZW1lbnRcclxuICAgKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3IgICAgQW55IG90aGVyIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgVGhlIGxhc3QgY2hpbGQsIGlnbm9yaW5nIGdob3N0RWxcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxhc3RDaGlsZChlbCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbGFzdCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICB3aGlsZSAobGFzdCAmJiAobGFzdCA9PT0gU29ydGFibGUuZ2hvc3QgfHwgY3NzKGxhc3QsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzZWxlY3RvciAmJiAhbWF0Y2hlcyhsYXN0LCBzZWxlY3RvcikpKSB7XG4gICAgICBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0IHx8IG51bGw7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudCBmb3IgYSBzZWxlY3RlZCBzZXQgb2ZcclxuICAgKiBlbGVtZW50c1xyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxyXG4gICAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvclxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluZGV4KGVsLCBzZWxlY3Rvcikge1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICBpZiAoIWVsIHx8ICFlbC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuXG4gICAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdURU1QTEFURScgJiYgZWwgIT09IFNvcnRhYmxlLmNsb25lICYmICghc2VsZWN0b3IgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzY3JvbGwgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50LCBhZGRlZCB3aXRoIGFsbCB0aGUgc2Nyb2xsIG9mZnNldHMgb2YgcGFyZW50IGVsZW1lbnRzLlxyXG4gICAqIFRoZSB2YWx1ZSBpcyByZXR1cm5lZCBpbiByZWFsIHBpeGVscy5cclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcclxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgT2Zmc2V0cyBpbiB0aGUgZm9ybWF0IG9mIFtsZWZ0LCB0b3BdXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChlbCkge1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gMCxcbiAgICAgICAgb2Zmc2V0VG9wID0gMCxcbiAgICAgICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGVsKSxcbiAgICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4LmEsXG4gICAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeC5kO1xuICAgICAgICBvZmZzZXRMZWZ0ICs9IGVsLnNjcm9sbExlZnQgKiBzY2FsZVg7XG4gICAgICAgIG9mZnNldFRvcCArPSBlbC5zY3JvbGxUb3AgKiBzY2FsZVk7XG4gICAgICB9IHdoaWxlIChlbCAhPT0gd2luU2Nyb2xsZXIgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBbb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wXTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IHdpdGhpbiB0aGUgZ2l2ZW4gYXJyYXlcclxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyICAgQXJyYXkgdGhhdCBtYXkgb3IgbWF5IG5vdCBob2xkIHRoZSBvYmplY3RcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgQW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5LXZhbHVlIHBhaXIgdW5pcXVlIHRvIGFuZCBpZGVudGljYWwgdG8gYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGZpbmRcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgVGhlIGluZGV4IG9mIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5LCBvciAtMVxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5kZXhPZk9iamVjdChhcnIsIG9iaikge1xuICAgIGZvciAodmFyIGkgaW4gYXJyKSB7XG4gICAgICBpZiAoIWFyci5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldID09PSBhcnJbaV1ba2V5XSkgcmV0dXJuIE51bWJlcihpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgaW5jbHVkZVNlbGYpIHtcbiAgICAvLyBza2lwIHRvIHdpbmRvd1xuICAgIGlmICghZWwgfHwgIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICB2YXIgZWxlbSA9IGVsO1xuICAgIHZhciBnb3RTZWxmID0gZmFsc2U7XG5cbiAgICBkbyB7XG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGdldCBlbGVtIGNzcyBpZiBpdCBpc24ndCBldmVuIG92ZXJmbG93aW5nIGluIHRoZSBmaXJzdCBwbGFjZSAocGVyZm9ybWFuY2UpXG4gICAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCkge1xuICAgICAgICB2YXIgZWxlbUNTUyA9IGNzcyhlbGVtKTtcblxuICAgICAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggJiYgKGVsZW1DU1Mub3ZlcmZsb3dYID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WCA9PSAnc2Nyb2xsJykgfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCAmJiAoZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dZID09ICdzY3JvbGwnKSkge1xuICAgICAgICAgIGlmICghZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgfHwgZWxlbSA9PT0gZG9jdW1lbnQuYm9keSkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICBpZiAoZ290U2VsZiB8fCBpbmNsdWRlU2VsZikgcmV0dXJuIGVsZW07XG4gICAgICAgICAgZ290U2VsZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgIH0gd2hpbGUgKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpO1xuXG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICAgIGlmIChkc3QgJiYgc3JjKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWN0RXF1YWwocmVjdDEsIHJlY3QyKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQocmVjdDEudG9wKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi50b3ApICYmIE1hdGgucm91bmQocmVjdDEubGVmdCkgPT09IE1hdGgucm91bmQocmVjdDIubGVmdCkgJiYgTWF0aC5yb3VuZChyZWN0MS5oZWlnaHQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmhlaWdodCkgJiYgTWF0aC5yb3VuZChyZWN0MS53aWR0aCkgPT09IE1hdGgucm91bmQocmVjdDIud2lkdGgpO1xuICB9XG5cbiAgdmFyIF90aHJvdHRsZVRpbWVvdXQ7XG5cbiAgZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIG1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3Rocm90dGxlVGltZW91dCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgfSwgbXMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxUaHJvdHRsZSgpIHtcbiAgICBjbGVhclRpbWVvdXQoX3Rocm90dGxlVGltZW91dCk7XG4gICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbEJ5KGVsLCB4LCB5KSB7XG4gICAgZWwuc2Nyb2xsTGVmdCArPSB4O1xuICAgIGVsLnNjcm9sbFRvcCArPSB5O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmUoZWwpIHtcbiAgICB2YXIgUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuICAgIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG5cbiAgICBpZiAoUG9seW1lciAmJiBQb2x5bWVyLmRvbSkge1xuICAgICAgcmV0dXJuIFBvbHltZXIuZG9tKGVsKS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICgkKSB7XG4gICAgICByZXR1cm4gJChlbCkuY2xvbmUodHJ1ZSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UmVjdChlbCwgcmVjdCkge1xuICAgIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgY3NzKGVsLCAndG9wJywgcmVjdC50b3ApO1xuICAgIGNzcyhlbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgIGNzcyhlbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gICAgY3NzKGVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5zZXRSZWN0KGVsKSB7XG4gICAgY3NzKGVsLCAncG9zaXRpb24nLCAnJyk7XG4gICAgY3NzKGVsLCAndG9wJywgJycpO1xuICAgIGNzcyhlbCwgJ2xlZnQnLCAnJyk7XG4gICAgY3NzKGVsLCAnd2lkdGgnLCAnJyk7XG4gICAgY3NzKGVsLCAnaGVpZ2h0JywgJycpO1xuICB9XG5cbiAgdmFyIGV4cGFuZG8gPSAnU29ydGFibGUnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkge1xuICAgIHZhciBhbmltYXRpb25TdGF0ZXMgPSBbXSxcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZDtcbiAgICByZXR1cm4ge1xuICAgICAgY2FwdHVyZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBjYXB0dXJlQW5pbWF0aW9uU3RhdGUoKSB7XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHJldHVybjtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbCh0aGlzLmVsLmNoaWxkcmVuKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY3NzKGNoaWxkLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgY2hpbGQgPT09IFNvcnRhYmxlLmdob3N0KSByZXR1cm47XG4gICAgICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goe1xuICAgICAgICAgICAgdGFyZ2V0OiBjaGlsZCxcbiAgICAgICAgICAgIHJlY3Q6IGdldFJlY3QoY2hpbGQpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZnJvbVJlY3QgPSBfb2JqZWN0U3ByZWFkKHt9LCBhbmltYXRpb25TdGF0ZXNbYW5pbWF0aW9uU3RhdGVzLmxlbmd0aCAtIDFdLnJlY3QpOyAvLyBJZiBhbmltYXRpbmc6IGNvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG5cblxuICAgICAgICAgIGlmIChjaGlsZC50aGlzQW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE1hdHJpeCA9IG1hdHJpeChjaGlsZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZE1hdHJpeCkge1xuICAgICAgICAgICAgICBmcm9tUmVjdC50b3AgLT0gY2hpbGRNYXRyaXguZjtcbiAgICAgICAgICAgICAgZnJvbVJlY3QubGVmdCAtPSBjaGlsZE1hdHJpeC5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkLmZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZEFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiBhZGRBbmltYXRpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIHJlbW92ZUFuaW1hdGlvblN0YXRlKHRhcmdldCkge1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMuc3BsaWNlKGluZGV4T2ZPYmplY3QoYW5pbWF0aW9uU3RhdGVzLCB7XG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgfSksIDEpO1xuICAgICAgfSxcbiAgICAgIGFuaW1hdGVBbGw6IGZ1bmN0aW9uIGFuaW1hdGVBbGwoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5pbWF0aW5nID0gZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRpb25UaW1lID0gMDtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgICAgIGZyb21SZWN0ID0gdGFyZ2V0LmZyb21SZWN0LFxuICAgICAgICAgICAgICB0b1JlY3QgPSBnZXRSZWN0KHRhcmdldCksXG4gICAgICAgICAgICAgIHByZXZGcm9tUmVjdCA9IHRhcmdldC5wcmV2RnJvbVJlY3QsXG4gICAgICAgICAgICAgIHByZXZUb1JlY3QgPSB0YXJnZXQucHJldlRvUmVjdCxcbiAgICAgICAgICAgICAgYW5pbWF0aW5nUmVjdCA9IHN0YXRlLnJlY3QsXG4gICAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeCh0YXJnZXQsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldE1hdHJpeCkge1xuICAgICAgICAgICAgLy8gQ29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAgICAgIHRvUmVjdC50b3AgLT0gdGFyZ2V0TWF0cml4LmY7XG4gICAgICAgICAgICB0b1JlY3QubGVmdCAtPSB0YXJnZXRNYXRyaXguZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQudG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgICAgaWYgKHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIENvdWxkIGFsc28gY2hlY2sgaWYgYW5pbWF0aW5nUmVjdCBpcyBiZXR3ZWVuIGZyb21SZWN0IGFuZCB0b1JlY3RcbiAgICAgICAgICAgIGlmIChpc1JlY3RFcXVhbChwcmV2RnJvbVJlY3QsIHRvUmVjdCkgJiYgIWlzUmVjdEVxdWFsKGZyb21SZWN0LCB0b1JlY3QpICYmIC8vIE1ha2Ugc3VyZSBhbmltYXRpbmdSZWN0IGlzIG9uIGxpbmUgYmV0d2VlbiB0b1JlY3QgJiBmcm9tUmVjdFxuICAgICAgICAgICAgKGFuaW1hdGluZ1JlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoYW5pbWF0aW5nUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpID09PSAoZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSkge1xuICAgICAgICAgICAgICAvLyBJZiByZXR1cm5pbmcgdG8gc2FtZSBwbGFjZSBhcyBzdGFydGVkIGZyb20gYW5pbWF0aW9uIGFuZCBvbiBzYW1lIGF4aXNcbiAgICAgICAgICAgICAgdGltZSA9IGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIHByZXZGcm9tUmVjdCwgcHJldlRvUmVjdCwgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBpZiBmcm9tUmVjdCAhPSB0b1JlY3Q6IGFuaW1hdGVcblxuXG4gICAgICAgICAgaWYgKCFpc1JlY3RFcXVhbCh0b1JlY3QsIGZyb21SZWN0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgICB0aW1lID0gX3RoaXMub3B0aW9ucy5hbmltYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLmFuaW1hdGUodGFyZ2V0LCBhbmltYXRpbmdSZWN0LCB0b1JlY3QsIHRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYW5pbWF0aW9uVGltZSA9IE1hdGgubWF4KGFuaW1hdGlvblRpbWUsIHRpbWUpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyKTtcbiAgICAgICAgICAgIHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRhcmdldC5hbmltYXRpb25UaW1lID0gMDtcbiAgICAgICAgICAgICAgdGFyZ2V0LnByZXZGcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIHRhcmdldC5mcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIHRhcmdldC5wcmV2VG9SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICAgIHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSB0aW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcblxuICAgICAgICBpZiAoIWFuaW1hdGluZykge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgICAgfSxcbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUodGFyZ2V0LCBjdXJyZW50UmVjdCwgdG9SZWN0LCBkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeCh0aGlzLmVsKSxcbiAgICAgICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZCxcbiAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9IChjdXJyZW50UmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICAgICAgdHJhbnNsYXRlWSA9IChjdXJyZW50UmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChzY2FsZVkgfHwgMSk7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSAhIXRyYW5zbGF0ZVg7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSAhIXRyYW5zbGF0ZVk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgnICsgdHJhbnNsYXRlWCArICdweCwnICsgdHJhbnNsYXRlWSArICdweCwwKScpO1xuICAgICAgICAgIHJlcGFpbnQodGFyZ2V0KTsgLy8gcmVwYWludFxuXG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAndHJhbnNmb3JtICcgKyBkdXJhdGlvbiArICdtcycgKyAodGhpcy5vcHRpb25zLmVhc2luZyA/ICcgJyArIHRoaXMub3B0aW9ucy5lYXNpbmcgOiAnJykpO1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgICAgdHlwZW9mIHRhcmdldC5hbmltYXRlZCA9PT0gJ251bWJlcicgJiYgY2xlYXJUaW1lb3V0KHRhcmdldC5hbmltYXRlZCk7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWSA9IGZhbHNlO1xuICAgICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZXBhaW50KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQub2Zmc2V0V2lkdGg7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBmcm9tUmVjdCwgdG9SZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSBhbmltYXRpbmdSZWN0LnRvcCwgMikgKyBNYXRoLnBvdyhmcm9tUmVjdC5sZWZ0IC0gYW5pbWF0aW5nUmVjdC5sZWZ0LCAyKSkgLyBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCwgMikgKyBNYXRoLnBvdyhmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQsIDIpKSAqIG9wdGlvbnMuYW5pbWF0aW9uO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBbXTtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbiAgfTtcbiAgdmFyIFBsdWdpbk1hbmFnZXIgPSB7XG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgc3RhdGljIHByb3BlcnRpZXNcbiAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBkZWZhdWx0cykge1xuICAgICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgICAgcGx1Z2luW29wdGlvbl0gPSBkZWZhdWx0c1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIH0sXG4gICAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5ldmVudENhbmNlbGVkID0gZmFsc2U7XG5cbiAgICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmV2ZW50Q2FuY2VsZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gRmlyZSBnbG9iYWwgZXZlbnRzIGlmIGl0IGV4aXN0cyBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0oX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgICB9LCBldnQpKTtcbiAgICAgICAgfSAvLyBPbmx5IGZpcmUgcGx1Z2luIGV2ZW50IGlmIHBsdWdpbiBpcyBlbmFibGVkIGluIHRoaXMgc29ydGFibGUsXG4gICAgICAgIC8vIGFuZCBwbHVnaW4gaGFzIGV2ZW50IGRlZmluZWRcblxuXG4gICAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zW3BsdWdpbi5wbHVnaW5OYW1lXSAmJiBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXSkge1xuICAgICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgICAgfSwgZXZ0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZVBsdWdpbnM6IGZ1bmN0aW9uIGluaXRpYWxpemVQbHVnaW5zKHNvcnRhYmxlLCBlbCwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luLnBsdWdpbk5hbWU7XG4gICAgICAgIGlmICghc29ydGFibGUub3B0aW9uc1twbHVnaW5OYW1lXSAmJiAhcGx1Z2luLmluaXRpYWxpemVCeURlZmF1bHQpIHJldHVybjtcbiAgICAgICAgdmFyIGluaXRpYWxpemVkID0gbmV3IHBsdWdpbihzb3J0YWJsZSwgZWwsIHNvcnRhYmxlLm9wdGlvbnMpO1xuICAgICAgICBpbml0aWFsaXplZC5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgICBpbml0aWFsaXplZC5vcHRpb25zID0gc29ydGFibGUub3B0aW9ucztcbiAgICAgICAgc29ydGFibGVbcGx1Z2luTmFtZV0gPSBpbml0aWFsaXplZDsgLy8gQWRkIGRlZmF1bHQgb3B0aW9ucyBmcm9tIHBsdWdpblxuXG4gICAgICAgIF9leHRlbmRzKGRlZmF1bHRzLCBpbml0aWFsaXplZC5kZWZhdWx0cyk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgb3B0aW9uIGluIHNvcnRhYmxlLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbW9kaWZpZWQgPSB0aGlzLm1vZGlmeU9wdGlvbihzb3J0YWJsZSwgb3B0aW9uLCBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc29ydGFibGUub3B0aW9uc1tvcHRpb25dID0gbW9kaWZpZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSB7XG4gICAgICB2YXIgZXZlbnRQcm9wZXJ0aWVzID0ge307XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbi5ldmVudFByb3BlcnRpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgICBfZXh0ZW5kcyhldmVudFByb3BlcnRpZXMsIHBsdWdpbi5ldmVudFByb3BlcnRpZXMuY2FsbChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0sIG5hbWUpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV2ZW50UHJvcGVydGllcztcbiAgICB9LFxuICAgIG1vZGlmeU9wdGlvbjogZnVuY3Rpb24gbW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG1vZGlmaWVkVmFsdWU7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAvLyBQbHVnaW4gbXVzdCBleGlzdCBvbiB0aGUgU29ydGFibGVcbiAgICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gSWYgc3RhdGljIG9wdGlvbiBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgb3B0aW9uLCBjYWxsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBTb3J0YWJsZSdzIGluc3RhbmNlIG9mIHRoaXMgcGx1Z2luXG5cbiAgICAgICAgaWYgKHBsdWdpbi5vcHRpb25MaXN0ZW5lcnMgJiYgdHlwZW9mIHBsdWdpbi5vcHRpb25MaXN0ZW5lcnNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtb2RpZmllZFZhbHVlID0gcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXS5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtb2RpZmllZFZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KF9yZWYpIHtcbiAgICB2YXIgc29ydGFibGUgPSBfcmVmLnNvcnRhYmxlLFxuICAgICAgICByb290RWwgPSBfcmVmLnJvb3RFbCxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgdGFyZ2V0RWwgPSBfcmVmLnRhcmdldEVsLFxuICAgICAgICBjbG9uZUVsID0gX3JlZi5jbG9uZUVsLFxuICAgICAgICB0b0VsID0gX3JlZi50b0VsLFxuICAgICAgICBmcm9tRWwgPSBfcmVmLmZyb21FbCxcbiAgICAgICAgb2xkSW5kZXggPSBfcmVmLm9sZEluZGV4LFxuICAgICAgICBuZXdJbmRleCA9IF9yZWYubmV3SW5kZXgsXG4gICAgICAgIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZi5vbGREcmFnZ2FibGVJbmRleCxcbiAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBfcmVmLm5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICAgIGV4dHJhRXZlbnRQcm9wZXJ0aWVzID0gX3JlZi5leHRyYUV2ZW50UHJvcGVydGllcztcbiAgICBzb3J0YWJsZSA9IHNvcnRhYmxlIHx8IHJvb3RFbCAmJiByb290RWxbZXhwYW5kb107XG4gICAgaWYgKCFzb3J0YWJsZSkgcmV0dXJuO1xuICAgIHZhciBldnQsXG4gICAgICAgIG9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zLFxuICAgICAgICBvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBldnQudG8gPSB0b0VsIHx8IHJvb3RFbDtcbiAgICBldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XG4gICAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gICAgZXZ0LmNsb25lID0gY2xvbmVFbDtcbiAgICBldnQub2xkSW5kZXggPSBvbGRJbmRleDtcbiAgICBldnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgICBldnQub2xkRHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgICBldnQubmV3RHJhZ2dhYmxlSW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleDtcbiAgICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgZXZ0LnB1bGxNb2RlID0gcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBhbGxFdmVudFByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcywgUGx1Z2luTWFuYWdlci5nZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpKTtcblxuICAgIGZvciAodmFyIG9wdGlvbiBpbiBhbGxFdmVudFByb3BlcnRpZXMpIHtcbiAgICAgIGV2dFtvcHRpb25dID0gYWxsRXZlbnRQcm9wZXJ0aWVzW29wdGlvbl07XG4gICAgfVxuXG4gICAgaWYgKHJvb3RFbCkge1xuICAgICAgcm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1tvbk5hbWVdKSB7XG4gICAgICBvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGx1Z2luRXZlbnQgPSBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5ldnQsXG4gICAgICAgIGRhdGEgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiZXZ0XCJdKTtcblxuICAgIFBsdWdpbk1hbmFnZXIucGx1Z2luRXZlbnQuYmluZChTb3J0YWJsZSkoZXZlbnROYW1lLCBzb3J0YWJsZSwgX29iamVjdFNwcmVhZCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHBhcmVudEVsOiBwYXJlbnRFbCxcbiAgICAgIGdob3N0RWw6IGdob3N0RWwsXG4gICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgIG5leHRFbDogbmV4dEVsLFxuICAgICAgbGFzdERvd25FbDogbGFzdERvd25FbCxcbiAgICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgICBjbG9uZUhpZGRlbjogY2xvbmVIaWRkZW4sXG4gICAgICBkcmFnU3RhcnRlZDogbW92ZWQsXG4gICAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgICBhY3RpdmVTb3J0YWJsZTogU29ydGFibGUuYWN0aXZlLFxuICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4OiBvbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgIGhpZGVHaG9zdEZvclRhcmdldDogX2hpZGVHaG9zdEZvclRhcmdldCxcbiAgICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0OiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICBjbG9uZU5vd0hpZGRlbjogZnVuY3Rpb24gY2xvbmVOb3dIaWRkZW4oKSB7XG4gICAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBjbG9uZU5vd1Nob3duOiBmdW5jdGlvbiBjbG9uZU5vd1Nob3duKCkge1xuICAgICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KG5hbWUpIHtcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZGF0YSkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGluZm8pIHtcbiAgICBkaXNwYXRjaEV2ZW50KF9vYmplY3RTcHJlYWQoe1xuICAgICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICAgIHRhcmdldEVsOiBkcmFnRWwsXG4gICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4OiBvbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleFxuICAgIH0sIGluZm8pKTtcbiAgfVxuXG4gIHZhciBkcmFnRWwsXG4gICAgICBwYXJlbnRFbCxcbiAgICAgIGdob3N0RWwsXG4gICAgICByb290RWwsXG4gICAgICBuZXh0RWwsXG4gICAgICBsYXN0RG93bkVsLFxuICAgICAgY2xvbmVFbCxcbiAgICAgIGNsb25lSGlkZGVuLFxuICAgICAgb2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4LFxuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICBhY3RpdmVHcm91cCxcbiAgICAgIHB1dFNvcnRhYmxlLFxuICAgICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2UsXG4gICAgICBzb3J0YWJsZXMgPSBbXSxcbiAgICAgIHRhcEV2dCxcbiAgICAgIHRvdWNoRXZ0LFxuICAgICAgbGFzdER4LFxuICAgICAgbGFzdER5LFxuICAgICAgdGFwRGlzdGFuY2VMZWZ0LFxuICAgICAgdGFwRGlzdGFuY2VUb3AsXG4gICAgICBtb3ZlZCxcbiAgICAgIGxhc3RUYXJnZXQsXG4gICAgICBsYXN0RGlyZWN0aW9uLFxuICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gICAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2UsXG4gICAgICB0YXJnZXRNb3ZlRGlzdGFuY2UsXG4gICAgICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuICBnaG9zdFJlbGF0aXZlUGFyZW50LFxuICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBbXSxcbiAgICAgIC8vIChsZWZ0LCB0b3ApXG4gIF9zaWxlbnQgPSBmYWxzZSxcbiAgICAgIHNhdmVkSW5wdXRDaGVja2VkID0gW107XG4gIC8qKiBAY29uc3QgKi9cblxuICB2YXIgZG9jdW1lbnRFeGlzdHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICAgICAgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPSBJT1MsXG4gICAgICBDU1NGbG9hdFByb3BlcnR5ID0gRWRnZSB8fCBJRTExT3JMZXNzID8gJ2Nzc0Zsb2F0JyA6ICdmbG9hdCcsXG4gICAgICAvLyBUaGlzIHdpbGwgbm90IHBhc3MgZm9yIElFOSwgYmVjYXVzZSBJRTkgRG5EIG9ubHkgd29ya3Mgb24gYW5jaG9yc1xuICBzdXBwb3J0RHJhZ2dhYmxlID0gZG9jdW1lbnRFeGlzdHMgJiYgIUNocm9tZUZvckFuZHJvaWQgJiYgIUlPUyAmJiAnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnRFeGlzdHMpIHJldHVybjsgLy8gZmFsc2Ugd2hlbiA8PSBJRTExXG5cbiAgICBpZiAoSUUxMU9yTGVzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICAgIHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XG4gIH0oKSxcbiAgICAgIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgZWxXaWR0aCA9IHBhcnNlSW50KGVsQ1NTLndpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdSaWdodCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJMZWZ0V2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyUmlnaHRXaWR0aCksXG4gICAgICAgIGNoaWxkMSA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcbiAgICAgICAgY2hpbGQyID0gZ2V0Q2hpbGQoZWwsIDEsIG9wdGlvbnMpLFxuICAgICAgICBmaXJzdENoaWxkQ1NTID0gY2hpbGQxICYmIGNzcyhjaGlsZDEpLFxuICAgICAgICBzZWNvbmRDaGlsZENTUyA9IGNoaWxkMiAmJiBjc3MoY2hpbGQyKSxcbiAgICAgICAgZmlyc3RDaGlsZFdpZHRoID0gZmlyc3RDaGlsZENTUyAmJiBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMSkud2lkdGgsXG4gICAgICAgIHNlY29uZENoaWxkV2lkdGggPSBzZWNvbmRDaGlsZENTUyAmJiBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQyKS53aWR0aDtcblxuICAgIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICAgIHJldHVybiBlbENTUy5mbGV4RGlyZWN0aW9uID09PSAnY29sdW1uJyB8fCBlbENTUy5mbGV4RGlyZWN0aW9uID09PSAnY29sdW1uLXJldmVyc2UnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICB9XG5cbiAgICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgICByZXR1cm4gZWxDU1MuZ3JpZFRlbXBsYXRlQ29sdW1ucy5zcGxpdCgnICcpLmxlbmd0aCA8PSAxID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgICAgdmFyIHRvdWNoaW5nU2lkZUNoaWxkMiA9IGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIHJldHVybiBjaGlsZDIgJiYgKHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSAnYm90aCcgfHwgc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09IHRvdWNoaW5nU2lkZUNoaWxkMikgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDEgJiYgKGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2Jsb2NrJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdmbGV4JyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICd0YWJsZScgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZ3JpZCcgfHwgZmlyc3RDaGlsZFdpZHRoID49IGVsV2lkdGggJiYgZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyB8fCBjaGlsZDIgJiYgZWxDU1NbQ1NTRmxvYXRQcm9wZXJ0eV0gPT09ICdub25lJyAmJiBmaXJzdENoaWxkV2lkdGggKyBzZWNvbmRDaGlsZFdpZHRoID4gZWxXaWR0aCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICB9LFxuICAgICAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICAgIHZhciBkcmFnRWxTMU9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QubGVmdCA6IGRyYWdSZWN0LnRvcCxcbiAgICAgICAgZHJhZ0VsUzJPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LnJpZ2h0IDogZHJhZ1JlY3QuYm90dG9tLFxuICAgICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgICB0YXJnZXRTMU9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5sZWZ0IDogdGFyZ2V0UmVjdC50b3AsXG4gICAgICAgIHRhcmdldFMyT3BwID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnJpZ2h0IDogdGFyZ2V0UmVjdC5ib3R0b20sXG4gICAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICAgIHJldHVybiBkcmFnRWxTMU9wcCA9PT0gdGFyZ2V0UzFPcHAgfHwgZHJhZ0VsUzJPcHAgPT09IHRhcmdldFMyT3BwIHx8IGRyYWdFbFMxT3BwICsgZHJhZ0VsT3BwTGVuZ3RoIC8gMiA9PT0gdGFyZ2V0UzFPcHAgKyB0YXJnZXRPcHBMZW5ndGggLyAyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgWCBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcbiAgICovXG4gIF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSA9IGZ1bmN0aW9uIF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSh4LCB5KSB7XG4gICAgdmFyIHJldDtcbiAgICBzb3J0YWJsZXMuc29tZShmdW5jdGlvbiAoc29ydGFibGUpIHtcbiAgICAgIGlmIChsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgICB2YXIgcmVjdCA9IGdldFJlY3Qoc29ydGFibGUpLFxuICAgICAgICAgIHRocmVzaG9sZCA9IHNvcnRhYmxlW2V4cGFuZG9dLm9wdGlvbnMuZW1wdHlJbnNlcnRUaHJlc2hvbGQsXG4gICAgICAgICAgaW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSByZWN0LmxlZnQgLSB0aHJlc2hvbGQgJiYgeCA8PSByZWN0LnJpZ2h0ICsgdGhyZXNob2xkLFxuICAgICAgICAgIGluc2lkZVZlcnRpY2FsbHkgPSB5ID49IHJlY3QudG9wIC0gdGhyZXNob2xkICYmIHkgPD0gcmVjdC5ib3R0b20gKyB0aHJlc2hvbGQ7XG5cbiAgICAgIGlmICh0aHJlc2hvbGQgJiYgaW5zaWRlSG9yaXpvbnRhbGx5ICYmIGluc2lkZVZlcnRpY2FsbHkpIHtcbiAgICAgICAgcmV0dXJuIHJldCA9IHNvcnRhYmxlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gICAgICBfcHJlcGFyZUdyb3VwID0gZnVuY3Rpb24gX3ByZXBhcmVHcm91cChvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gdG9Gbih2YWx1ZSwgcHVsbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgZHJhZ0VsLCBldnQpIHtcbiAgICAgICAgdmFyIHNhbWVHcm91cCA9IHRvLm9wdGlvbnMuZ3JvdXAubmFtZSAmJiBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZSAmJiB0by5vcHRpb25zLmdyb3VwLm5hbWUgPT09IGZyb20ub3B0aW9ucy5ncm91cC5uYW1lO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIChwdWxsIHx8IHNhbWVHcm91cCkpIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHB1bGwgdmFsdWVcbiAgICAgICAgICAvLyBEZWZhdWx0IHB1bGwgYW5kIHB1dCB2YWx1ZSBpZiBzYW1lIGdyb3VwXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdG9Gbih2YWx1ZSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpLCBwdWxsKSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvdGhlckdyb3VwID0gKHB1bGwgPyB0byA6IGZyb20pLm9wdGlvbnMuZ3JvdXAubmFtZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gb3RoZXJHcm91cCB8fCB2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XG5cbiAgICBpZiAoIW9yaWdpbmFsR3JvdXAgfHwgX3R5cGVvZihvcmlnaW5hbEdyb3VwKSAhPSAnb2JqZWN0Jykge1xuICAgICAgb3JpZ2luYWxHcm91cCA9IHtcbiAgICAgICAgbmFtZTogb3JpZ2luYWxHcm91cFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBncm91cC5uYW1lID0gb3JpZ2luYWxHcm91cC5uYW1lO1xuICAgIGdyb3VwLmNoZWNrUHVsbCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdWxsLCB0cnVlKTtcbiAgICBncm91cC5jaGVja1B1dCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdXQpO1xuICAgIGdyb3VwLnJldmVydENsb25lID0gb3JpZ2luYWxHcm91cC5yZXZlcnRDbG9uZTtcbiAgICBvcHRpb25zLmdyb3VwID0gZ3JvdXA7XG4gIH0sXG4gICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX2hpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgfVxuICB9LFxuICAgICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICAgIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xuICAgIH1cbiAgfTsgLy8gIzExODQgZml4IC0gUHJldmVudCBjbGljayBldmVudCBvbiBmYWxsYmFjayBpZiBkcmFnZ2VkIGJ1dCBpdGVtIG5vdCBjaGFuZ2VkIHBvc2l0aW9uXG5cblxuICBpZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChpZ25vcmVOZXh0Q2xpY2spIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICYmIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgfVxuXG4gIHZhciBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCA9IGZ1bmN0aW9uIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCkge1xuICAgIGlmIChkcmFnRWwpIHtcbiAgICAgIGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XG5cbiAgICAgIHZhciBuZWFyZXN0ID0gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG5cbiAgICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICAgIC8vIENyZWF0ZSBpbWl0YXRpb24gZXZlbnRcbiAgICAgICAgdmFyIGV2ZW50ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBldnQpIHtcbiAgICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBldmVudFtpXSA9IGV2dFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC5yb290RWwgPSBuZWFyZXN0O1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgIG5lYXJlc3RbZXhwYW5kb10uX29uRHJhZ092ZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX2NoZWNrT3V0c2lkZVRhcmdldEVsID0gZnVuY3Rpb24gX2NoZWNrT3V0c2lkZVRhcmdldEVsKGV2dCkge1xuICAgIGlmIChkcmFnRWwpIHtcbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGNsYXNzICBTb3J0YWJsZVxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgW29wdGlvbnNdXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gU29ydGFibGUoZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShlbCAmJiBlbC5ub2RlVHlwZSAmJiBlbC5ub2RlVHlwZSA9PT0gMSkpIHtcbiAgICAgIHRocm93IFwiU29ydGFibGU6IGBlbGAgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKGVsKSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IGVsOyAvLyByb290IGVsZW1lbnRcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyk7IC8vIEV4cG9ydCBpbnN0YW5jZVxuXG4gICAgZWxbZXhwYW5kb10gPSB0aGlzO1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgc29ydDogdHJ1ZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHN0b3JlOiBudWxsLFxuICAgICAgaGFuZGxlOiBudWxsLFxuICAgICAgZHJhZ2dhYmxlOiAvXlt1b11sJC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJz5saScgOiAnPionLFxuICAgICAgc3dhcFRocmVzaG9sZDogMSxcbiAgICAgIC8vIHBlcmNlbnRhZ2U7IDAgPD0geCA8PSAxXG4gICAgICBpbnZlcnRTd2FwOiBmYWxzZSxcbiAgICAgIC8vIGludmVydCBhbHdheXNcbiAgICAgIGludmVydGVkU3dhcFRocmVzaG9sZDogbnVsbCxcbiAgICAgIC8vIHdpbGwgYmUgc2V0IHRvIHNhbWUgYXMgc3dhcFRocmVzaG9sZCBpZiBkZWZhdWx0XG4gICAgICByZW1vdmVDbG9uZU9uSGlkZTogdHJ1ZSxcbiAgICAgIGRpcmVjdGlvbjogZnVuY3Rpb24gZGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RldGVjdERpcmVjdGlvbihlbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBnaG9zdENsYXNzOiAnc29ydGFibGUtZ2hvc3QnLFxuICAgICAgY2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxuICAgICAgZHJhZ0NsYXNzOiAnc29ydGFibGUtZHJhZycsXG4gICAgICBpZ25vcmU6ICdhLCBpbWcnLFxuICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgcHJldmVudE9uRmlsdGVyOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uOiAwLFxuICAgICAgZWFzaW5nOiBudWxsLFxuICAgICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRyYWdFbC50ZXh0Q29udGVudCk7XG4gICAgICB9LFxuICAgICAgZHJvcEJ1YmJsZTogZmFsc2UsXG4gICAgICBkcmFnb3ZlckJ1YmJsZTogZmFsc2UsXG4gICAgICBkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXG4gICAgICBkZWxheTogMCxcbiAgICAgIGRlbGF5T25Ub3VjaE9ubHk6IGZhbHNlLFxuICAgICAgdG91Y2hTdGFydFRocmVzaG9sZDogKE51bWJlci5wYXJzZUludCA/IE51bWJlciA6IHdpbmRvdykucGFyc2VJbnQod2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEwKSB8fCAxLFxuICAgICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXG4gICAgICBmYWxsYmFja0NsYXNzOiAnc29ydGFibGUtZmFsbGJhY2snLFxuICAgICAgZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxuICAgICAgZmFsbGJhY2tUb2xlcmFuY2U6IDAsXG4gICAgICBmYWxsYmFja09mZnNldDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgc3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZSAmJiAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3csXG4gICAgICBlbXB0eUluc2VydFRocmVzaG9sZDogNVxuICAgIH07XG4gICAgUGx1Z2luTWFuYWdlci5pbml0aWFsaXplUGx1Z2lucyh0aGlzLCBlbCwgZGVmYXVsdHMpOyAvLyBTZXQgZGVmYXVsdCBvcHRpb25zXG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XG4gICAgfVxuXG4gICAgX3ByZXBhcmVHcm91cChvcHRpb25zKTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cblxuICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH0gLy8gU2V0dXAgZHJhZyBtb2RlXG5cblxuICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlID0gb3B0aW9ucy5mb3JjZUZhbGxiYWNrID8gZmFsc2UgOiBzdXBwb3J0RHJhZ2dhYmxlO1xuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAvLyBUb3VjaCBzdGFydCB0aHJlc2hvbGQgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbmF0aXZlIGRyYWdzdGFydCB0aHJlc2hvbGRcbiAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gMTtcbiAgICB9IC8vIEJpbmQgZXZlbnRzXG5cblxuICAgIGlmIChvcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICBvbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgICBvbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgIG9uKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gICAgfVxuXG4gICAgc29ydGFibGVzLnB1c2godGhpcy5lbCk7IC8vIFJlc3RvcmUgc29ydGluZ1xuXG4gICAgb3B0aW9ucy5zdG9yZSAmJiBvcHRpb25zLnN0b3JlLmdldCAmJiB0aGlzLnNvcnQob3B0aW9ucy5zdG9yZS5nZXQodGhpcykgfHwgW10pOyAvLyBBZGQgYW5pbWF0aW9uIHN0YXRlIG1hbmFnZXJcblxuICAgIF9leHRlbmRzKHRoaXMsIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpKTtcbiAgfVxuXG4gIFNvcnRhYmxlLnByb3RvdHlwZSA9XG4gIC8qKiBAbGVuZHMgU29ydGFibGUucHJvdG90eXBlICovXG4gIHtcbiAgICBjb25zdHJ1Y3RvcjogU29ydGFibGUsXG4gICAgX2lzT3V0c2lkZVRoaXNFbDogZnVuY3Rpb24gX2lzT3V0c2lkZVRoaXNFbCh0YXJnZXQpIHtcbiAgICAgIGlmICghdGhpcy5lbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5lbCkge1xuICAgICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXREaXJlY3Rpb246IGZ1bmN0aW9uIF9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24uY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgZHJhZ0VsKSA6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcbiAgICBfb25UYXBTdGFydDogZnVuY3Rpb24gX29uVGFwU3RhcnQoXG4gICAgLyoqIEV2ZW50fFRvdWNoRXZlbnQgKi9cbiAgICBldnQpIHtcbiAgICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybjtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBwcmV2ZW50T25GaWx0ZXIgPSBvcHRpb25zLnByZXZlbnRPbkZpbHRlcixcbiAgICAgICAgICB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSB8fCBldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICYmIGV2dCxcbiAgICAgICAgICB0YXJnZXQgPSAodG91Y2ggfHwgZXZ0KS50YXJnZXQsXG4gICAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdIHx8IGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0YXJnZXQsXG4gICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG5cbiAgICAgIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUoZWwpOyAvLyBEb24ndCB0cmlnZ2VyIHN0YXJ0IGV2ZW50IHdoZW4gYW4gZWxlbWVudCBpcyBiZWVuIGRyYWdnZWQsIG90aGVyd2lzZSB0aGUgZXZ0Lm9sZGluZGV4IGFsd2F5cyB3cm9uZyB3aGVuIHNldCBvcHRpb24uZ3JvdXAuXG5cblxuICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgvbW91c2Vkb3dufHBvaW50ZXJkb3duLy50ZXN0KHR5cGUpICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47IC8vIG9ubHkgbGVmdCBidXR0b24gYW5kIGVuYWJsZWRcbiAgICAgIH0gLy8gY2FuY2VsIGRuZCBpZiBvcmlnaW5hbCB0YXJnZXQgaXMgY29udGVudCBlZGl0YWJsZVxuXG5cbiAgICAgIGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKTtcblxuICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIC8vIElnbm9yaW5nIGR1cGxpY2F0ZSBgZG93bmBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuXG4gICAgICBvbGRJbmRleCA9IGluZGV4KHRhcmdldCk7XG4gICAgICBvbGREcmFnZ2FibGVJbmRleCA9IGluZGV4KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUpOyAvLyBDaGVjayBmaWx0ZXJcblxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCB0aGlzKSkge1xuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgIHJvb3RFbDogb3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgICAgIGZyb21FbDogZWxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsdGVyKSB7XG4gICAgICAgIGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgICAgY3JpdGVyaWEgPSBjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsLCBmYWxzZSk7XG5cbiAgICAgICAgICBpZiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgICByb290RWw6IGNyaXRlcmlhLFxuICAgICAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgICAgdG9FbDogZWxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmhhbmRsZSAmJiAhY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmVwYXJlIGBkcmFnc3RhcnRgXG5cblxuICAgICAgdGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQpO1xuICAgIH0sXG4gICAgX3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uIF9wcmVwYXJlRHJhZ1N0YXJ0KFxuICAgIC8qKiBFdmVudCAqL1xuICAgIGV2dCxcbiAgICAvKiogVG91Y2ggKi9cbiAgICB0b3VjaCxcbiAgICAvKiogSFRNTEVsZW1lbnQgKi9cbiAgICB0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgZWwgPSBfdGhpcy5lbCxcbiAgICAgICAgICBvcHRpb25zID0gX3RoaXMub3B0aW9ucyxcbiAgICAgICAgICBvd25lckRvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgICBkcmFnU3RhcnRGbjtcblxuICAgICAgaWYgKHRhcmdldCAmJiAhZHJhZ0VsICYmIHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIHJvb3RFbCA9IGVsO1xuICAgICAgICBkcmFnRWwgPSB0YXJnZXQ7XG4gICAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7XG4gICAgICAgIG5leHRFbCA9IGRyYWdFbC5uZXh0U2libGluZztcbiAgICAgICAgbGFzdERvd25FbCA9IHRhcmdldDtcbiAgICAgICAgYWN0aXZlR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgICAgICBTb3J0YWJsZS5kcmFnZ2VkID0gZHJhZ0VsO1xuICAgICAgICB0YXBFdnQgPSB7XG4gICAgICAgICAgdGFyZ2V0OiBkcmFnRWwsXG4gICAgICAgICAgY2xpZW50WDogKHRvdWNoIHx8IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRZXG4gICAgICAgIH07XG4gICAgICAgIHRhcERpc3RhbmNlTGVmdCA9IHRhcEV2dC5jbGllbnRYIC0gZHJhZ1JlY3QubGVmdDtcbiAgICAgICAgdGFwRGlzdGFuY2VUb3AgPSB0YXBFdnQuY2xpZW50WSAtIGRyYWdSZWN0LnRvcDtcbiAgICAgICAgdGhpcy5fbGFzdFggPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRYO1xuICAgICAgICB0aGlzLl9sYXN0WSA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFk7XG4gICAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICdhbGwnO1xuXG4gICAgICAgIGRyYWdTdGFydEZuID0gZnVuY3Rpb24gZHJhZ1N0YXJ0Rm4oKSB7XG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5RW5kZWQnLCBfdGhpcywge1xuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIERlbGF5ZWQgZHJhZyBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgICAgICAvLyB3ZSBjYW4gcmUtZW5hYmxlIHRoZSBldmVudHM6IHRvdWNobW92ZS9tb3VzZW1vdmVcblxuXG4gICAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgICAgICAgaWYgKCFGaXJlRm94ICYmIF90aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgfSAvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG5cblxuICAgICAgICAgIF90aGlzLl90cmlnZ2VyRHJhZ1N0YXJ0KGV2dCwgdG91Y2gpOyAvLyBEcmFnIHN0YXJ0IGV2ZW50XG5cblxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgIG5hbWU6ICdjaG9vc2UnLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7IC8vIENob3NlbiBpdGVtXG5cblxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5jaG9zZW5DbGFzcywgdHJ1ZSk7XG4gICAgICAgIH07IC8vIERpc2FibGUgXCJkcmFnZ2FibGVcIlxuXG5cbiAgICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICAgIGZpbmQoZHJhZ0VsLCBjcml0ZXJpYS50cmltKCksIF9kaXNhYmxlRHJhZ2dhYmxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApOyAvLyBNYWtlIGRyYWdFbCBkcmFnZ2FibGUgKG11c3QgYmUgYmVmb3JlIGRlbGF5IGZvciBGaXJlRm94KVxuXG4gICAgICAgIGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSA0O1xuICAgICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5U3RhcnQnLCB0aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7IC8vIERlbGF5IGlzIGltcG9zc2libGUgZm9yIG5hdGl2ZSBEbkQgaW4gRWRnZSBvciBJRVxuXG4gICAgICAgIGlmIChvcHRpb25zLmRlbGF5ICYmICghb3B0aW9ucy5kZWxheU9uVG91Y2hPbmx5IHx8IHRvdWNoKSAmJiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8ICEoRWRnZSB8fCBJRTExT3JMZXNzKSkpIHtcbiAgICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIElmIHRoZSB1c2VyIG1vdmVzIHRoZSBwb2ludGVyIG9yIGxldCBnbyB0aGUgY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgICAvLyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICAgICAgLy8gZGlzYWJsZSB0aGUgZGVsYXllZCBkcmFnXG5cblxuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgICBvcHRpb25zLnN1cHBvcnRQb2ludGVyICYmIG9uKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICAgIF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYWdTdGFydEZuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXI6IGZ1bmN0aW9uIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIoXG4gICAgLyoqIFRvdWNoRXZlbnR8UG9pbnRlckV2ZW50ICoqL1xuICAgIGUpIHtcbiAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cbiAgICAgIGlmIChNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA+PSBNYXRoLmZsb29yKHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkIC8gKHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWcoKSB7XG4gICAgICBkcmFnRWwgJiYgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuICAgIH0sXG4gICAgX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICB9LFxuICAgIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfdHJpZ2dlckRyYWdTdGFydChcbiAgICAvKiogRXZlbnQgKi9cbiAgICBldnQsXG4gICAgLyoqIFRvdWNoICovXG4gICAgdG91Y2gpIHtcbiAgICAgIHRvdWNoID0gdG91Y2ggfHwgZXZ0LnBvaW50ZXJUeXBlID09ICd0b3VjaCcgJiYgZXZ0O1xuXG4gICAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8IHRvdWNoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoKSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgICAgb24ocm9vdEVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgLy8gVGltZW91dCBuZWNjZXNzYXJ5IGZvciBJRTlcbiAgICAgICAgICBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgfSxcbiAgICBfZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIF9kcmFnU3RhcnRlZChmYWxsYmFjaywgZXZ0KSB7XG5cbiAgICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHJvb3RFbCAmJiBkcmFnRWwpIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydGVkJywgdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEFwcGx5IGVmZmVjdFxuXG4gICAgICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCBmYWxzZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgU29ydGFibGUuYWN0aXZlID0gdGhpcztcbiAgICAgICAgZmFsbGJhY2sgJiYgdGhpcy5fYXBwZW5kR2hvc3QoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX251bGxpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9lbXVsYXRlRHJhZ092ZXI6IGZ1bmN0aW9uIF9lbXVsYXRlRHJhZ092ZXIoKSB7XG4gICAgICBpZiAodG91Y2hFdnQpIHtcbiAgICAgICAgdGhpcy5fbGFzdFggPSB0b3VjaEV2dC5jbGllbnRYO1xuICAgICAgICB0aGlzLl9sYXN0WSA9IHRvdWNoRXZ0LmNsaWVudFk7XG5cbiAgICAgICAgX2hpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0O1xuXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICAgIGlmICh0YXJnZXQgPT09IHBhcmVudCkgYnJlYWs7XG4gICAgICAgICAgcGFyZW50ID0gdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbCh0YXJnZXQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAocGFyZW50W2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBwYXJlbnRbZXhwYW5kb10uX29uRHJhZ092ZXIoe1xuICAgICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoRXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICByb290RWw6IHBhcmVudFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIXRoaXMub3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHBhcmVudDsgLy8gc3RvcmUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIF9vblRvdWNoTW92ZShcbiAgICAvKipUb3VjaEV2ZW50Ki9cbiAgICBldnQpIHtcbiAgICAgIGlmICh0YXBFdnQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBmYWxsYmFja1RvbGVyYW5jZSA9IG9wdGlvbnMuZmFsbGJhY2tUb2xlcmFuY2UsXG4gICAgICAgICAgICBmYWxsYmFja09mZnNldCA9IG9wdGlvbnMuZmFsbGJhY2tPZmZzZXQsXG4gICAgICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQsXG4gICAgICAgICAgICBnaG9zdE1hdHJpeCA9IGdob3N0RWwgJiYgbWF0cml4KGdob3N0RWwsIHRydWUpLFxuICAgICAgICAgICAgc2NhbGVYID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5hLFxuICAgICAgICAgICAgc2NhbGVZID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5kLFxuICAgICAgICAgICAgcmVsYXRpdmVTY3JvbGxPZmZzZXQgPSBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICYmIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpLFxuICAgICAgICAgICAgZHggPSAodG91Y2guY2xpZW50WCAtIHRhcEV2dC5jbGllbnRYICsgZmFsbGJhY2tPZmZzZXQueCkgLyAoc2NhbGVYIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMF0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFswXSA6IDApIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICAgIGR5ID0gKHRvdWNoLmNsaWVudFkgLSB0YXBFdnQuY2xpZW50WSArIGZhbGxiYWNrT2Zmc2V0LnkpIC8gKHNjYWxlWSB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzFdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMV0gOiAwKSAvIChzY2FsZVkgfHwgMSk7IC8vIG9ubHkgc2V0IHRoZSBzdGF0dXMgdG8gZHJhZ2dpbmcsIHdoZW4gd2UgYXJlIGFjdHVhbGx5IGRyYWdnaW5nXG5cbiAgICAgICAgaWYgKCFTb3J0YWJsZS5hY3RpdmUgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tUb2xlcmFuY2UgJiYgTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPCBmYWxsYmFja1RvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2hvc3RFbCkge1xuICAgICAgICAgIGlmIChnaG9zdE1hdHJpeCkge1xuICAgICAgICAgICAgZ2hvc3RNYXRyaXguZSArPSBkeCAtIChsYXN0RHggfHwgMCk7XG4gICAgICAgICAgICBnaG9zdE1hdHJpeC5mICs9IGR5IC0gKGxhc3REeSB8fCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2hvc3RNYXRyaXggPSB7XG4gICAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgICAgIGU6IGR4LFxuICAgICAgICAgICAgICBmOiBkeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3NzTWF0cml4ID0gXCJtYXRyaXgoXCIuY29uY2F0KGdob3N0TWF0cml4LmEsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYiwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5jLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmQsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5mLCBcIilcIik7XG4gICAgICAgICAgY3NzKGdob3N0RWwsICd3ZWJraXRUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICAgIGNzcyhnaG9zdEVsLCAnbW96VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgICBjc3MoZ2hvc3RFbCwgJ21zVHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgICAgbGFzdER4ID0gZHg7XG4gICAgICAgICAgbGFzdER5ID0gZHk7XG4gICAgICAgICAgdG91Y2hFdnQgPSB0b3VjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FwcGVuZEdob3N0OiBmdW5jdGlvbiBfYXBwZW5kR2hvc3QoKSB7XG4gICAgICAvLyBCdWcgaWYgdXNpbmcgc2NhbGUoKTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYzNzA1OFxuICAgICAgLy8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxuICAgICAgaWYgKCFnaG9zdEVsKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuZmFsbGJhY2tPbkJvZHkgPyBkb2N1bWVudC5ib2R5IDogcm9vdEVsLFxuICAgICAgICAgICAgcmVjdCA9IGdldFJlY3QoZHJhZ0VsLCB0cnVlLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSwgdHJ1ZSwgY29udGFpbmVyKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIFBvc2l0aW9uIGFic29sdXRlbHlcblxuICAgICAgICBpZiAoUG9zaXRpb25HaG9zdEFic29sdXRlbHkpIHtcbiAgICAgICAgICAvLyBHZXQgcmVsYXRpdmVseSBwb3NpdGlvbmVkIHBhcmVudFxuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBjb250YWluZXI7XG5cbiAgICAgICAgICB3aGlsZSAoY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJyAmJiBjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCA9PT0gZG9jdW1lbnQpIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgICByZWN0LnRvcCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHJlY3QubGVmdCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdob3N0RWwgPSBkcmFnRWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5mYWxsYmFja0NsYXNzLCB0cnVlKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ2JveC1zaXppbmcnLCAnYm9yZGVyLWJveCcpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21hcmdpbicsIDApO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdvcGFjaXR5JywgJzAuOCcpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3Bvc2l0aW9uJywgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnekluZGV4JywgJzEwMDAwMCcpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3BvaW50ZXJFdmVudHMnLCAnbm9uZScpO1xuICAgICAgICBTb3J0YWJsZS5naG9zdCA9IGdob3N0RWw7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnaG9zdEVsKTsgLy8gU2V0IHRyYW5zZm9ybS1vcmlnaW5cblxuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybS1vcmlnaW4nLCB0YXBEaXN0YW5jZUxlZnQgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLndpZHRoKSAqIDEwMCArICclICcgKyB0YXBEaXN0YW5jZVRvcCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUuaGVpZ2h0KSAqIDEwMCArICclJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChcbiAgICAvKipFdmVudCovXG4gICAgZXZ0LFxuICAgIC8qKmJvb2xlYW4qL1xuICAgIGZhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2ZlcjtcbiAgICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW5FdmVudCgnc2V0dXBDbG9uZScsIHRoaXMpO1xuXG4gICAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgY2xvbmVFbCA9IGNsb25lKGRyYWdFbCk7XG4gICAgICAgIGNsb25lRWwuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGNsb25lRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcblxuICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICB0b2dnbGVDbGFzcyhjbG9uZUVsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgU29ydGFibGUuY2xvbmUgPSBjbG9uZUVsO1xuICAgICAgfSAvLyAjMTE0MzogSUZyYW1lIHN1cHBvcnQgd29ya2Fyb3VuZFxuXG5cbiAgICAgIF90aGlzLmNsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBwbHVnaW5FdmVudCgnY2xvbmUnLCBfdGhpcyk7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgbmFtZTogJ2Nsb25lJ1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpOyAvLyBTZXQgcHJvcGVyIGRyb3AgZXZlbnRzXG5cbiAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICBpZ25vcmVOZXh0Q2xpY2sgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVW5kbyB3aGF0IHdhcyBzZXQgaW4gX3ByZXBhcmVEcmFnU3RhcnQgYmVmb3JlIGRyYWcgc3RhcnRlZFxuICAgICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XG5cbiAgICAgICAgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgIGRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICAgIG9wdGlvbnMuc2V0RGF0YSAmJiBvcHRpb25zLnNldERhdGEuY2FsbChfdGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgb24oZG9jdW1lbnQsICdkcm9wJywgX3RoaXMpOyAvLyAjMTI3NiBmaXg6XG5cbiAgICAgICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVaKDApJyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgX3RoaXMuX2RyYWdTdGFydElkID0gX25leHRUaWNrKF90aGlzLl9kcmFnU3RhcnRlZC5iaW5kKF90aGlzLCBmYWxsYmFjaywgZXZ0KSk7XG4gICAgICBvbihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xuICAgICAgbW92ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoU2FmYXJpKSB7XG4gICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gUmV0dXJucyB0cnVlIC0gaWYgbm8gZnVydGhlciBhY3Rpb24gaXMgbmVlZGVkIChlaXRoZXIgaW5zZXJ0ZWQgb3IgYW5vdGhlciBjb25kaXRpb24pXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uIF9vbkRyYWdPdmVyKFxuICAgIC8qKkV2ZW50Ki9cbiAgICBldnQpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgICAgdGFyZ2V0ID0gZXZ0LnRhcmdldCxcbiAgICAgICAgICBkcmFnUmVjdCxcbiAgICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICAgIHJldmVydCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGdyb3VwID0gb3B0aW9ucy5ncm91cCxcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICAgICAgICBpc093bmVyID0gYWN0aXZlR3JvdXAgPT09IGdyb3VwLFxuICAgICAgICAgIGNhblNvcnQgPSBvcHRpb25zLnNvcnQsXG4gICAgICAgICAgZnJvbVNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgdmVydGljYWwsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGNvbXBsZXRlZEZpcmVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChfc2lsZW50KSByZXR1cm47XG5cbiAgICAgIGZ1bmN0aW9uIGRyYWdPdmVyRXZlbnQobmFtZSwgZXh0cmEpIHtcbiAgICAgICAgcGx1Z2luRXZlbnQobmFtZSwgX3RoaXMsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgIGlzT3duZXI6IGlzT3duZXIsXG4gICAgICAgICAgYXhpczogdmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICAgIHJldmVydDogcmV2ZXJ0LFxuICAgICAgICAgIGRyYWdSZWN0OiBkcmFnUmVjdCxcbiAgICAgICAgICB0YXJnZXRSZWN0OiB0YXJnZXRSZWN0LFxuICAgICAgICAgIGNhblNvcnQ6IGNhblNvcnQsXG4gICAgICAgICAgZnJvbVNvcnRhYmxlOiBmcm9tU29ydGFibGUsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWQsXG4gICAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUodGFyZ2V0LCBhZnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCBnZXRSZWN0KHRhcmdldCksIGV2dCwgYWZ0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hhbmdlZDogY2hhbmdlZFxuICAgICAgICB9LCBleHRyYSkpO1xuICAgICAgfSAvLyBDYXB0dXJlIGFuaW1hdGlvbiBzdGF0ZVxuXG5cbiAgICAgIGZ1bmN0aW9uIGNhcHR1cmUoKSB7XG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZScpO1xuXG4gICAgICAgIF90aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJldHVybiBpbnZvY2F0aW9uIHdoZW4gZHJhZ0VsIGlzIGluc2VydGVkIChvciBjb21wbGV0ZWQpXG5cblxuICAgICAgZnVuY3Rpb24gY29tcGxldGVkKGluc2VydGlvbikge1xuICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckNvbXBsZXRlZCcsIHtcbiAgICAgICAgICBpbnNlcnRpb246IGluc2VydGlvblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKF90aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgICAgLy8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogYWN0aXZlU29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHB1dFNvcnRhYmxlICE9PSBfdGhpcyAmJiBfdGhpcyAhPT0gU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBwdXRTb3J0YWJsZSA9IF90aGlzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSAmJiBwdXRTb3J0YWJsZSkge1xuICAgICAgICAgICAgcHV0U29ydGFibGUgPSBudWxsO1xuICAgICAgICAgIH0gLy8gQW5pbWF0aW9uXG5cblxuICAgICAgICAgIGlmIChmcm9tU29ydGFibGUgPT09IF90aGlzKSB7XG4gICAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSB0YXJnZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlJyk7XG4gICAgICAgICAgICBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICAgIGZyb21Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgICBmcm9tU29ydGFibGUuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTnVsbCBsYXN0VGFyZ2V0IGlmIGl0IGlzIG5vdCBpbnNpZGUgYSBwcmV2aW91c2x5IHN3YXBwZWQgZWxlbWVudFxuXG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gZHJhZ0VsICYmICFkcmFnRWwuYW5pbWF0ZWQgfHwgdGFyZ2V0ID09PSBlbCAmJiAhdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgICAgIH0gLy8gbm8gYnViYmxpbmcgYW5kIG5vdCBmYWxsYmFja1xuXG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmICFldnQucm9vdEVsICYmIHRhcmdldCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpOyAvLyBEbyBub3QgZGV0ZWN0IGZvciBlbXB0eSBpbnNlcnQgaWYgYWxyZWFkeSBpbnNlcnRlZFxuXG5cbiAgICAgICAgICAhaW5zZXJ0aW9uICYmIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICAhb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZEZpcmVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gQ2FsbCB3aGVuIGRyYWdFbCBoYXMgYmVlbiBpbnNlcnRlZFxuXG5cbiAgICAgIGZ1bmN0aW9uIGNoYW5nZWQoKSB7XG4gICAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIG5hbWU6ICdjaGFuZ2UnLFxuICAgICAgICAgIHRvRWw6IGVsLFxuICAgICAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIHRydWUpO1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXInKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICAgIGlmIChkcmFnRWwuY29udGFpbnMoZXZ0LnRhcmdldCkgfHwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC5hbmltYXRpbmdYICYmIHRhcmdldC5hbmltYXRpbmdZIHx8IF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcblxuICAgICAgaWYgKGFjdGl2ZVNvcnRhYmxlICYmICFvcHRpb25zLmRpc2FibGVkICYmIChpc093bmVyID8gY2FuU29ydCB8fCAocmV2ZXJ0ID0gIXJvb3RFbC5jb250YWlucyhkcmFnRWwpKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgICA6IHB1dFNvcnRhYmxlID09PSB0aGlzIHx8ICh0aGlzLmxhc3RQdXRNb2RlID0gYWN0aXZlR3JvdXAuY2hlY2tQdWxsKHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpICYmIGdyb3VwLmNoZWNrUHV0KHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpKSB7XG4gICAgICAgIHZlcnRpY2FsID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSA9PT0gJ3ZlcnRpY2FsJztcbiAgICAgICAgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCk7XG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyVmFsaWQnKTtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgICAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAgICAgcGFyZW50RWwgPSByb290RWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgICAgZHJhZ092ZXJFdmVudCgncmV2ZXJ0Jyk7XG5cbiAgICAgICAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRFbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsTGFzdENoaWxkID0gbGFzdENoaWxkKGVsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgICAgaWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XG4gICAgICAgICAgLy8gSWYgYWxyZWFkeSBhdCBlbmQgb2YgbGlzdDogRG8gbm90IGluc2VydFxuICAgICAgICAgIGlmIChlbExhc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgICB9IC8vIGFzc2lnbiB0YXJnZXQgb25seSBpZiBjb25kaXRpb24gaXMgdHJ1ZVxuXG5cbiAgICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgJiYgZWwgPT09IGV2dC50YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGVsTGFzdENoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsICEhdGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNhcHR1cmUoKTtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnROb2RlID09PSBlbCkge1xuICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IDAsXG4gICAgICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCxcbiAgICAgICAgICAgICAgZGlmZmVyZW50TGV2ZWwgPSBkcmFnRWwucGFyZW50Tm9kZSAhPT0gZWwsXG4gICAgICAgICAgICAgIGRpZmZlcmVudFJvd0NvbCA9ICFfZHJhZ0VsSW5Sb3dDb2x1bW4oZHJhZ0VsLmFuaW1hdGVkICYmIGRyYWdFbC50b1JlY3QgfHwgZHJhZ1JlY3QsIHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQudG9SZWN0IHx8IHRhcmdldFJlY3QsIHZlcnRpY2FsKSxcbiAgICAgICAgICAgICAgc2lkZTEgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICAgICAgICBzY3JvbGxlZFBhc3RUb3AgPSBpc1Njcm9sbGVkUGFzdCh0YXJnZXQsICd0b3AnLCAndG9wJykgfHwgaXNTY3JvbGxlZFBhc3QoZHJhZ0VsLCAndG9wJywgJ3RvcCcpLFxuICAgICAgICAgICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxlZFBhc3RUb3AgPyBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wIDogdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKGxhc3RUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwID0gdGFyZ2V0UmVjdFtzaWRlMV07XG4gICAgICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSAhZGlmZmVyZW50Um93Q29sICYmIG9wdGlvbnMuaW52ZXJ0U3dhcCB8fCBkaWZmZXJlbnRMZXZlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3Rpb24gPSBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIGRpZmZlcmVudFJvd0NvbCA/IDEgOiBvcHRpb25zLnN3YXBUaHJlc2hvbGQsIG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkID09IG51bGwgPyBvcHRpb25zLnN3YXBUaHJlc2hvbGQgOiBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCwgaXNDaXJjdW1zdGFudGlhbEludmVydCwgbGFzdFRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICB2YXIgc2libGluZztcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBiZXNpZGUgZHJhZ0VsIGluIHJlc3BlY3RpdmUgZGlyZWN0aW9uIChpZ25vcmluZyBoaWRkZW4gZWxlbWVudHMpXG4gICAgICAgICAgICB2YXIgZHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBkcmFnSW5kZXggLT0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50RWwuY2hpbGRyZW5bZHJhZ0luZGV4XTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgKGNzcyhzaWJsaW5nLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2libGluZyA9PT0gZ2hvc3RFbCkpO1xuICAgICAgICAgIH0gLy8gSWYgZHJhZ0VsIGlzIGFscmVhZHkgYmVzaWRlIHRhcmdldDogRG8gbm90IGluc2VydFxuXG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIHx8IHNpYmxpbmcgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICBsYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgIGFmdGVyID0gZmFsc2U7XG4gICAgICAgICAgYWZ0ZXIgPSBkaXJlY3Rpb24gPT09IDE7XG5cbiAgICAgICAgICB2YXIgbW92ZVZlY3RvciA9IF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGFmdGVyKTtcblxuICAgICAgICAgIGlmIChtb3ZlVmVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG1vdmVWZWN0b3IgPT09IDEgfHwgbW92ZVZlY3RvciA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBtb3ZlVmVjdG9yID09PSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoX3Vuc2lsZW50LCAzMCk7XG4gICAgICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgICAgIGlmIChhZnRlciAmJiAhbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xuICAgICAgICAgICAgfSAvLyBVbmRvIGNocm9tZSdzIHNjcm9sbCBhZGp1c3RtZW50IChoYXMgbm8gZWZmZWN0IG9uIG90aGVyIGJyb3dzZXJzKVxuXG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxlZFBhc3RUb3ApIHtcbiAgICAgICAgICAgICAgc2Nyb2xsQnkoc2Nyb2xsZWRQYXN0VG9wLCAwLCBzY3JvbGxCZWZvcmUgLSBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxuICAgICAgICAgICAgLy8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cblxuICAgICAgICAgICAgaWYgKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAhPT0gdW5kZWZpbmVkICYmICFpc0NpcmN1bXN0YW50aWFsSW52ZXJ0KSB7XG4gICAgICAgICAgICAgIHRhcmdldE1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAtIGdldFJlY3QodGFyZ2V0KVtzaWRlMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbC5jb250YWlucyhkcmFnRWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX2lnbm9yZVdoaWxlQW5pbWF0aW5nOiBudWxsLFxuICAgIF9vZmZNb3ZlRXZlbnRzOiBmdW5jdGlvbiBfb2ZmTW92ZUV2ZW50cygpIHtcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgfSxcbiAgICBfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uIF9vZmZVcEV2ZW50cygpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICAgIH0sXG4gICAgX29uRHJvcDogZnVuY3Rpb24gX29uRHJvcChcbiAgICAvKipFdmVudCovXG4gICAgZXZ0KSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG4gICAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgICAgcGx1Z2luRXZlbnQoJ2Ryb3AnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcbiAgICAgIHBhcmVudEVsID0gZHJhZ0VsICYmIGRyYWdFbC5wYXJlbnROb2RlOyAvLyBHZXQgYWdhaW4gYWZ0ZXIgcGx1Z2luIGV2ZW50XG5cbiAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMuX251bGxpbmcoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZTtcbiAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9sb29wSWQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuICAgICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuY2xvbmVJZCk7XG5cbiAgICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7IC8vIFVuYmluZCBldmVudHNcblxuXG4gICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnZHJvcCcsIHRoaXMpO1xuICAgICAgICBvZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29mZk1vdmVFdmVudHMoKTtcblxuICAgICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuICAgICAgaWYgKFNhZmFyaSkge1xuICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJycpO1xuICAgICAgfVxuXG4gICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJycpO1xuXG4gICAgICBpZiAoZXZ0KSB7XG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICFvcHRpb25zLmRyb3BCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2hvc3RFbCAmJiBnaG9zdEVsLnBhcmVudE5vZGUgJiYgZ2hvc3RFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGdob3N0RWwpO1xuXG4gICAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGNsb25lKHMpXG4gICAgICAgICAgY2xvbmVFbCAmJiBjbG9uZUVsLnBhcmVudE5vZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgICAgb2ZmKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuXG4gICAgICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7IC8vIFJlbW92ZSBjbGFzc2VzXG4gICAgICAgICAgLy8gZ2hvc3RDbGFzcyBpcyBhZGRlZCBpbiBkcmFnU3RhcnRlZFxuXG4gICAgICAgICAgaWYgKG1vdmVkICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpOyAvLyBEcmFnIHN0b3AgZXZlbnRcblxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbmFtZTogJ3VuY2hvb3NlJyxcbiAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgbmV3SW5kZXg6IG51bGwsXG4gICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJvb3RFbCAhPT0gcGFyZW50RWwpIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCBldmVudFxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYWRkJyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7IC8vIFJlbW92ZSBldmVudFxuXG5cbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTsgLy8gZHJhZyBmcm9tIG9uZSBsaXN0IGFuZCBkcm9wIGludG8gYW5vdGhlclxuXG5cbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUuc2F2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJhZyAmIGRyb3Agd2l0aGluIHRoZSBzYW1lIGxpc3RcbiAgICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIC8qIGpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09IG51bGwgfHwgbmV3SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdlbmQnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gU2F2ZSBzb3J0aW5nXG5cblxuICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX251bGxpbmcoKTtcbiAgICB9LFxuICAgIF9udWxsaW5nOiBmdW5jdGlvbiBfbnVsbGluZygpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdudWxsaW5nJywgdGhpcyk7XG4gICAgICByb290RWwgPSBkcmFnRWwgPSBwYXJlbnRFbCA9IGdob3N0RWwgPSBuZXh0RWwgPSBjbG9uZUVsID0gbGFzdERvd25FbCA9IGNsb25lSGlkZGVuID0gdGFwRXZ0ID0gdG91Y2hFdnQgPSBtb3ZlZCA9IG5ld0luZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4ID0gbGFzdFRhcmdldCA9IGxhc3REaXJlY3Rpb24gPSBwdXRTb3J0YWJsZSA9IGFjdGl2ZUdyb3VwID0gU29ydGFibGUuZHJhZ2dlZCA9IFNvcnRhYmxlLmdob3N0ID0gU29ydGFibGUuY2xvbmUgPSBTb3J0YWJsZS5hY3RpdmUgPSBudWxsO1xuICAgICAgc2F2ZWRJbnB1dENoZWNrZWQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IGxhc3REeCA9IGxhc3REeSA9IDA7XG4gICAgfSxcbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24gaGFuZGxlRXZlbnQoXG4gICAgLyoqRXZlbnQqL1xuICAgIGV2dCkge1xuICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICBjYXNlICdkcm9wJzpcbiAgICAgICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICAgICAgdGhpcy5fb25Ecm9wKGV2dCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAgICBjYXNlICdkcmFnb3Zlcic6XG4gICAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgICAgdGhpcy5fb25EcmFnT3ZlcihldnQpO1xuXG4gICAgICAgICAgICBfZ2xvYmFsRHJhZ092ZXIoZXZ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWxlY3RzdGFydCc6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdGhlIGl0ZW0gaW50byBhbiBhcnJheSBvZiBzdHJpbmcuXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgb3JkZXIgPSBbXSxcbiAgICAgICAgICBlbCxcbiAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZWwuY2hpbGRyZW4sXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICBlbCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmIChjbG9zZXN0KGVsLCBvcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpKSB7XG4gICAgICAgICAgb3JkZXIucHVzaChlbC5nZXRBdHRyaWJ1dGUob3B0aW9ucy5kYXRhSWRBdHRyKSB8fCBfZ2VuZXJhdGVJZChlbCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXG4gICAgICovXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChvcmRlcikge1xuICAgICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICAgICAgcm9vdEVsID0gdGhpcy5lbDtcbiAgICAgIHRoaXMudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAoY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsLCBmYWxzZSkpIHtcbiAgICAgICAgICBpdGVtc1tpZF0gPSBlbDtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgICAgcm9vdEVsLnJlbW92ZUNoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBjdXJyZW50IHNvcnRpbmdcbiAgICAgKi9cbiAgICBzYXZlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgdmFyIHN0b3JlID0gdGhpcy5vcHRpb25zLnN0b3JlO1xuICAgICAgc3RvcmUgJiYgc3RvcmUuc2V0ICYmIHN0b3JlLnNldCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxuICAgICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXG4gICAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgICAqL1xuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QkMShlbCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBjbG9zZXN0KGVsLCBzZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldC9nZXQgb3B0aW9uXG4gICAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSAgIHsqfSAgICAgIFt2YWx1ZV1cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBvcHRpb246IGZ1bmN0aW9uIG9wdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW25hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBQbHVnaW5NYW5hZ2VyLm1vZGlmeU9wdGlvbih0aGlzLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBtb2RpZmllZFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgX3ByZXBhcmVHcm91cChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdkZXN0cm95JywgdGhpcyk7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgZWxbZXhwYW5kb10gPSBudWxsO1xuICAgICAgb2ZmKGVsLCAnbW91c2Vkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgICBvZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgICBvZmYoZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuXG4gICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb2ZmKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgICAgb2ZmKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gICAgICB9IC8vIFJlbW92ZSBkcmFnZ2FibGUgYXR0cmlidXRlc1xuXG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2dhYmxlJyk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgICBzb3J0YWJsZXMuc3BsaWNlKHNvcnRhYmxlcy5pbmRleE9mKHRoaXMuZWwpLCAxKTtcbiAgICAgIHRoaXMuZWwgPSBlbCA9IG51bGw7XG4gICAgfSxcbiAgICBfaGlkZUNsb25lOiBmdW5jdGlvbiBfaGlkZUNsb25lKCkge1xuICAgICAgaWYgKCFjbG9uZUhpZGRlbikge1xuICAgICAgICBwbHVnaW5FdmVudCgnaGlkZUNsb25lJywgdGhpcyk7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG4gICAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2hvd0Nsb25lOiBmdW5jdGlvbiBfc2hvd0Nsb25lKHB1dFNvcnRhYmxlKSB7XG4gICAgICBpZiAocHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xvbmVIaWRkZW4pIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ3Nob3dDbG9uZScsIHRoaXMpO1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuOyAvLyBzaG93IGNsb25lIGF0IGRyYWdFbCBvciBvcmlnaW5hbCBwb3NpdGlvblxuXG4gICAgICAgIGlmIChyb290RWwuY29udGFpbnMoZHJhZ0VsKSAmJiAhdGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRFbCkge1xuICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlKGRyYWdFbCwgY2xvbmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9nbG9iYWxEcmFnT3ZlcihcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICBpZiAoZXZ0LmRhdGFUcmFuc2Zlcikge1xuICAgICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgIH1cblxuICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uTW92ZShmcm9tRWwsIHRvRWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldEVsLCB0YXJnZXRSZWN0LCBvcmlnaW5hbEV2ZW50LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcbiAgICB2YXIgZXZ0LFxuICAgICAgICBzb3J0YWJsZSA9IGZyb21FbFtleHBhbmRvXSxcbiAgICAgICAgb25Nb3ZlRm4gPSBzb3J0YWJsZS5vcHRpb25zLm9uTW92ZSxcbiAgICAgICAgcmV0VmFsOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdtb3ZlJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KCdtb3ZlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXZ0LnRvID0gdG9FbDtcbiAgICBldnQuZnJvbSA9IGZyb21FbDtcbiAgICBldnQuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICBldnQuZHJhZ2dlZFJlY3QgPSBkcmFnUmVjdDtcbiAgICBldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XG4gICAgZXZ0LnJlbGF0ZWRSZWN0ID0gdGFyZ2V0UmVjdCB8fCBnZXRSZWN0KHRvRWwpO1xuICAgIGV2dC53aWxsSW5zZXJ0QWZ0ZXIgPSB3aWxsSW5zZXJ0QWZ0ZXI7XG4gICAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgIGZyb21FbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICBpZiAob25Nb3ZlRm4pIHtcbiAgICAgIHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kaXNhYmxlRHJhZ2dhYmxlKGVsKSB7XG4gICAgZWwuZHJhZ2dhYmxlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zaWxlbnQoKSB7XG4gICAgX3NpbGVudCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KGxhc3RDaGlsZChzb3J0YWJsZS5lbCwgc29ydGFibGUub3B0aW9ucy5kcmFnZ2FibGUpKTtcbiAgICB2YXIgc3BhY2VyID0gMTA7XG4gICAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICsgc3BhY2VyIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSAmJiBldnQuY2xpZW50WCA+PSByZWN0LmxlZnQgOiBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LnRvcCB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gKyBzcGFjZXI7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIHN3YXBUaHJlc2hvbGQsIGludmVydGVkU3dhcFRocmVzaG9sZCwgaW52ZXJ0U3dhcCwgaXNMYXN0VGFyZ2V0KSB7XG4gICAgdmFyIG1vdXNlT25BeGlzID0gdmVydGljYWwgPyBldnQuY2xpZW50WSA6IGV2dC5jbGllbnRYLFxuICAgICAgICB0YXJnZXRMZW5ndGggPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCxcbiAgICAgICAgdGFyZ2V0UzEgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgICB0YXJnZXRTMiA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5ib3R0b20gOiB0YXJnZXRSZWN0LnJpZ2h0LFxuICAgICAgICBpbnZlcnQgPSBmYWxzZTtcblxuICAgIGlmICghaW52ZXJ0U3dhcCkge1xuICAgICAgLy8gTmV2ZXIgaW52ZXJ0IG9yIGNyZWF0ZSBkcmFnRWwgc2hhZG93IHdoZW4gdGFyZ2V0IG1vdmVtZW5ldCBjYXVzZXMgbW91c2UgdG8gbW92ZSBwYXN0IHRoZSBlbmQgb2YgcmVndWxhciBzd2FwVGhyZXNob2xkXG4gICAgICBpZiAoaXNMYXN0VGFyZ2V0ICYmIHRhcmdldE1vdmVEaXN0YW5jZSA8IHRhcmdldExlbmd0aCAqIHN3YXBUaHJlc2hvbGQpIHtcbiAgICAgICAgLy8gbXVsdGlwbGllZCBvbmx5IGJ5IHN3YXBUaHJlc2hvbGQgYmVjYXVzZSBtb3VzZSB3aWxsIGFscmVhZHkgYmUgaW5zaWRlIHRhcmdldCBieSAoMSAtIHRocmVzaG9sZCkgKiB0YXJnZXRMZW5ndGggLyAyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCBvbiBzaWRlIG9wcG9zaXRlIG9mIGxhc3REaXJlY3Rpb25cbiAgICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggJiYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiA6IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSkge1xuICAgICAgICAgIC8vIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCwgZG8gbm90IHJlc3RyaWN0IGludmVydGVkIHRocmVzaG9sZCB0byBkcmFnRWwgc2hhZG93XG4gICAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoKSB7XG4gICAgICAgICAgLy8gZHJhZ0VsIHNoYWRvdyAodGFyZ2V0IG1vdmUgZGlzdGFuY2Ugc2hhZG93KVxuICAgICAgICAgIGlmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldE1vdmVEaXN0YW5jZSAvLyBvdmVyIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgICA6IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRNb3ZlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiAtbGFzdERpcmVjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVndWxhclxuICAgICAgICBpZiAobW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyICYmIG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMikge1xuICAgICAgICAgIHJldHVybiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZlcnQgPSBpbnZlcnQgfHwgaW52ZXJ0U3dhcDtcblxuICAgIGlmIChpbnZlcnQpIHtcbiAgICAgIC8vIEludmVydCBvZiByZWd1bGFyXG4gICAgICBpZiAobW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgfHwgbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpIHtcbiAgICAgICAgcmV0dXJuIG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggLyAyID8gMSA6IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkaXJlY3Rpb24gZHJhZ0VsIG11c3QgYmUgc3dhcHBlZCByZWxhdGl2ZSB0byB0YXJnZXQgaW4gb3JkZXIgdG8gbWFrZSBpdFxuICAgKiBzZWVtIHRoYXQgZHJhZ0VsIGhhcyBiZWVuIFwiaW5zZXJ0ZWRcIiBpbnRvIHRoYXQgZWxlbWVudCdzIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICAgICAgVGhlIHRhcmdldCB3aG9zZSBwb3NpdGlvbiBkcmFnRWwgaXMgYmVpbmcgaW5zZXJ0ZWQgYXRcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICBEaXJlY3Rpb24gZHJhZ0VsIG11c3QgYmUgc3dhcHBlZFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKGluZGV4KGRyYWdFbCkgPCBpbmRleCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgaWRcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIF9nZW5lcmF0ZUlkKGVsKSB7XG4gICAgdmFyIHN0ciA9IGVsLnRhZ05hbWUgKyBlbC5jbGFzc05hbWUgKyBlbC5zcmMgKyBlbC5ocmVmICsgZWwudGV4dENvbnRlbnQsXG4gICAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdW0udG9TdHJpbmcoMzYpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShyb290KSB7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gMDtcbiAgICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgICB2YXIgaWR4ID0gaW5wdXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgICBlbC5jaGVja2VkICYmIHNhdmVkSW5wdXRDaGVja2VkLnB1c2goZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9uZXh0VGljayhmbikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jYW5jZWxOZXh0VGljayhpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xuICB9IC8vIEZpeGVkICM5NzM6XG5cblxuICBpZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmICgoU29ydGFibGUuYWN0aXZlIHx8IGF3YWl0aW5nRHJhZ1N0YXJ0ZWQpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIEV4cG9ydCB1dGlsc1xuXG5cbiAgU29ydGFibGUudXRpbHMgPSB7XG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIGNzczogY3NzLFxuICAgIGZpbmQ6IGZpbmQsXG4gICAgaXM6IGZ1bmN0aW9uIGlzKGVsLCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuICEhY2xvc2VzdChlbCwgc2VsZWN0b3IsIGVsLCBmYWxzZSk7XG4gICAgfSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgY2xvc2VzdDogY2xvc2VzdCxcbiAgICB0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBuZXh0VGljazogX25leHRUaWNrLFxuICAgIGNhbmNlbE5leHRUaWNrOiBfY2FuY2VsTmV4dFRpY2ssXG4gICAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICAgIGdldENoaWxkOiBnZXRDaGlsZFxuICB9O1xuICAvKipcbiAgICogR2V0IHRoZSBTb3J0YWJsZSBpbnN0YW5jZSBvZiBhbiBlbGVtZW50XG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50XG4gICAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcbiAgICovXG5cbiAgU29ydGFibGUuZ2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudFtleHBhbmRvXTtcbiAgfTtcbiAgLyoqXG4gICAqIE1vdW50IGEgcGx1Z2luIHRvIFNvcnRhYmxlXG4gICAqIEBwYXJhbSAgey4uLlNvcnRhYmxlUGx1Z2lufFNvcnRhYmxlUGx1Z2luW119IHBsdWdpbnMgICAgICAgUGx1Z2lucyBiZWluZyBtb3VudGVkXG4gICAqL1xuXG5cbiAgU29ydGFibGUubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW5zWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGlmICghcGx1Z2luLnByb3RvdHlwZSB8fCAhcGx1Z2luLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBcIlNvcnRhYmxlOiBNb3VudGVkIHBsdWdpbiBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChwbHVnaW4pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBsdWdpbi51dGlscykgU29ydGFibGUudXRpbHMgPSBfb2JqZWN0U3ByZWFkKHt9LCBTb3J0YWJsZS51dGlscywgcGx1Z2luLnV0aWxzKTtcbiAgICAgIFBsdWdpbk1hbmFnZXIubW91bnQocGx1Z2luKTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZSBzb3J0YWJsZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgZWxcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgW29wdGlvbnNdXG4gICAqL1xuXG5cbiAgU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTb3J0YWJsZShlbCwgb3B0aW9ucyk7XG4gIH07IC8vIEV4cG9ydFxuXG5cbiAgU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgdmFyIGF1dG9TY3JvbGxzID0gW10sXG4gICAgICBzY3JvbGxFbCxcbiAgICAgIHNjcm9sbFJvb3RFbCxcbiAgICAgIHNjcm9sbGluZyA9IGZhbHNlLFxuICAgICAgbGFzdEF1dG9TY3JvbGxYLFxuICAgICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgICAgdG91Y2hFdnQkMSxcbiAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsO1xuXG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gICAgZnVuY3Rpb24gQXV0b1Njcm9sbCgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsU2Vuc2l0aXZpdHk6IDMwLFxuICAgICAgICBzY3JvbGxTcGVlZDogMTAsXG4gICAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgICAgfTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIEF1dG9TY3JvbGwucHJvdG90eXBlID0ge1xuICAgICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxFdmVudC50b3VjaGVzKSB7XG4gICAgICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjIpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgIC8vIEZvciB3aGVuIGJ1YmJsaW5nIGlzIGNhbmNlbGVkIGFuZCB1c2luZyBmYWxsYmFjayAoZmFsbGJhY2sgJ3RvdWNobW92ZScgYWx3YXlzIHJlYWNoZWQpXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRyYWdPdmVyQnViYmxlICYmICFvcmlnaW5hbEV2ZW50LnJvb3RFbCkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7XG4gICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgY2FuY2VsVGhyb3R0bGUoKTtcbiAgICAgIH0sXG4gICAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgICB0b3VjaEV2dCQxID0gc2Nyb2xsUm9vdEVsID0gc2Nyb2xsRWwgPSBzY3JvbGxpbmcgPSBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IGxhc3RBdXRvU2Nyb2xsWCA9IGxhc3RBdXRvU2Nyb2xsWSA9IG51bGw7XG4gICAgICAgIGF1dG9TY3JvbGxzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbChldnQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQXV0b1Njcm9sbChldnQsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIF9oYW5kbGVBdXRvU2Nyb2xsOiBmdW5jdGlvbiBfaGFuZGxlQXV0b1Njcm9sbChldnQsIGZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WSxcbiAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAgIC8vIEVkZ2UncyBhdXRvc2Nyb2xsIHNlZW1zIHRvbyBjb25kaXRpb25hbCxcbiAgICAgICAgLy8gTUFDT1MgU2FmYXJpIGRvZXMgbm90IGhhdmUgYXV0b3Njcm9sbCxcbiAgICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgICAgaWYgKGZhbGxiYWNrIHx8IEVkZ2UgfHwgSUUxMU9yTGVzcyB8fCBTYWZhcmkpIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7IC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG5cbiAgICAgICAgICB2YXIgb2dFbGVtU2Nyb2xsZXIgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChzY3JvbGxpbmcgJiYgKCFwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCB8fCB4ICE9PSBsYXN0QXV0b1Njcm9sbFggfHwgeSAhPT0gbGFzdEF1dG9TY3JvbGxZKSkge1xuICAgICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpOyAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuXG4gICAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0VsZW0gPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpLCB0cnVlKTtcblxuICAgICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBvZ0VsZW1TY3JvbGxlciA9IG5ld0VsZW07XG4gICAgICAgICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYXV0b1Njcm9sbChldnQsIF90aGlzLm9wdGlvbnMsIG5ld0VsZW0sIGZhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgICBsYXN0QXV0b1Njcm9sbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBEbkQgaXMgZW5hYmxlZCAoYW5kIGJyb3dzZXIgaGFzIGdvb2QgYXV0b3Njcm9sbGluZyksIGZpcnN0IGF1dG9zY3JvbGwgd2lsbCBhbHJlYWR5IHNjcm9sbCwgc28gZ2V0IHBhcmVudCBhdXRvc2Nyb2xsIG9mIGZpcnN0IGF1dG9zY3JvbGxcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5idWJibGVTY3JvbGwgfHwgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSkgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMoQXV0b1Njcm9sbCwge1xuICAgICAgcGx1Z2luTmFtZTogJ3Njcm9sbCcsXG4gICAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICAgIGF1dG9TY3JvbGxzLmZvckVhY2goZnVuY3Rpb24gKGF1dG9TY3JvbGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xuICAgIH0pO1xuICAgIGF1dG9TY3JvbGxzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICAgIGNsZWFySW50ZXJ2YWwocG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwpO1xuICB9XG5cbiAgdmFyIGF1dG9TY3JvbGwgPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0LCBvcHRpb25zLCByb290RWwsIGlzRmFsbGJhY2spIHtcbiAgICAvLyBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUwNTUyMVxuICAgIGlmICghb3B0aW9ucy5zY3JvbGwpIHJldHVybjtcbiAgICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgIHNlbnMgPSBvcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5LFxuICAgICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG4gICAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgIHZhciBzY3JvbGxUaGlzSW5zdGFuY2UgPSBmYWxzZSxcbiAgICAgICAgc2Nyb2xsQ3VzdG9tRm47IC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG5cbiAgICBpZiAoc2Nyb2xsUm9vdEVsICE9PSByb290RWwpIHtcbiAgICAgIHNjcm9sbFJvb3RFbCA9IHJvb3RFbDtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIHNjcm9sbEVsID0gb3B0aW9ucy5zY3JvbGw7XG4gICAgICBzY3JvbGxDdXN0b21GbiA9IG9wdGlvbnMuc2Nyb2xsRm47XG5cbiAgICAgIGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuICAgICAgICBzY3JvbGxFbCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHJvb3RFbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxheWVyc091dCA9IDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBzY3JvbGxFbDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBlbCA9IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgICAgcmVjdCA9IGdldFJlY3QoZWwpLFxuICAgICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tLFxuICAgICAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCxcbiAgICAgICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgICAgIGNhblNjcm9sbFkgPSB2b2lkIDAsXG4gICAgICAgICAgc2Nyb2xsV2lkdGggPSBlbC5zY3JvbGxXaWR0aCxcbiAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgICAgIHNjcm9sbFBvc1ggPSBlbC5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG5cbiAgICAgIGlmIChlbCA9PT0gd2luU2Nyb2xsZXIpIHtcbiAgICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAndmlzaWJsZScpO1xuICAgICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnKTtcbiAgICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2eCA9IGNhblNjcm9sbFggJiYgKE1hdGguYWJzKHJpZ2h0IC0geCkgPD0gc2VucyAmJiBzY3JvbGxQb3NYICsgd2lkdGggPCBzY3JvbGxXaWR0aCkgLSAoTWF0aC5hYnMobGVmdCAtIHgpIDw9IHNlbnMgJiYgISFzY3JvbGxQb3NYKTtcbiAgICAgIHZhciB2eSA9IGNhblNjcm9sbFkgJiYgKE1hdGguYWJzKGJvdHRvbSAtIHkpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWSArIGhlaWdodCA8IHNjcm9sbEhlaWdodCkgLSAoTWF0aC5hYnModG9wIC0geSkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1kpO1xuXG4gICAgICBpZiAoIWF1dG9TY3JvbGxzW2xheWVyc091dF0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGF5ZXJzT3V0OyBpKyspIHtcbiAgICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgICBhdXRvU2Nyb2xsc1tpXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCAhPSB2eCB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ICE9IHZ5IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgIT09IGVsKSB7XG4gICAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCA9IHZ4O1xuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ5ID0gdnk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuXG4gICAgICAgIGlmICh2eCAhPSAwIHx8IHZ5ICE9IDApIHtcbiAgICAgICAgICBzY3JvbGxUaGlzSW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbiAgICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGVtdWxhdGUgZHJhZyBvdmVyIGR1cmluZyBhdXRvc2Nyb2xsIChmYWxsYmFjayksIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuICAgICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgICBTb3J0YWJsZS5hY3RpdmUuX29uVG91Y2hNb3ZlKHRvdWNoRXZ0JDEpOyAvLyBUbyBtb3ZlIGdob3N0IGlmIGl0IGlzIHBvc2l0aW9uZWQgYWJzb2x1dGVseVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRYID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCAqIHNwZWVkIDogMDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY3JvbGxDdXN0b21GbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjcm9sbEJ5KGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZKTtcbiAgICAgICAgICB9LmJpbmQoe1xuICAgICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICAgIH0pLCAyNCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGF5ZXJzT3V0Kys7XG4gICAgfSB3aGlsZSAob3B0aW9ucy5idWJibGVTY3JvbGwgJiYgY3VycmVudFBhcmVudCAhPT0gd2luU2Nyb2xsZXIgJiYgKGN1cnJlbnRQYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChjdXJyZW50UGFyZW50LCBmYWxzZSkpKTtcblxuICAgIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3RcbiAgfSwgMzApO1xuXG4gIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChfcmVmKSB7XG4gICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZi5wdXRTb3J0YWJsZSxcbiAgICAgICAgZHJhZ0VsID0gX3JlZi5kcmFnRWwsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgIGhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYuaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgICAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gICAgaWYgKCFvcmlnaW5hbEV2ZW50KSByZXR1cm47XG4gICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZTtcbiAgICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgICB2YXIgdG91Y2ggPSBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID8gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IG9yaWdpbmFsRXZlbnQ7XG4gICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICAgIGlmICh0b1NvcnRhYmxlICYmICF0b1NvcnRhYmxlLmVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnc3BpbGwnKTtcbiAgICAgIHRoaXMub25TcGlsbCh7XG4gICAgICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBSZXZlcnQoKSB7fVxuXG4gIFJldmVydC5wcm90b3R5cGUgPSB7XG4gICAgc3RhcnRJbmRleDogbnVsbCxcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgICAgdmFyIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZjIub2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgICB0aGlzLnN0YXJ0SW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgICB9LFxuICAgIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjMpIHtcbiAgICAgIHZhciBkcmFnRWwgPSBfcmVmMy5kcmFnRWwsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICAgIHRoaXMuc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgICBwdXRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHRTaWJsaW5nID0gZ2V0Q2hpbGQodGhpcy5zb3J0YWJsZS5lbCwgdGhpcy5zdGFydEluZGV4LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5zb3J0YWJsZS5lbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0U2libGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuXG4gICAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgICAgcHV0U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcDogZHJvcFxuICB9O1xuXG4gIF9leHRlbmRzKFJldmVydCwge1xuICAgIHBsdWdpbk5hbWU6ICdyZXZlcnRPblNwaWxsJ1xuICB9KTtcblxuICBmdW5jdGlvbiBSZW1vdmUoKSB7fVxuXG4gIFJlbW92ZS5wcm90b3R5cGUgPSB7XG4gICAgb25TcGlsbDogZnVuY3Rpb24gb25TcGlsbChfcmVmNCkge1xuICAgICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWY0LnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIHBhcmVudFNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgZHJhZ0VsLnBhcmVudE5vZGUgJiYgZHJhZ0VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtcbiAgICAgIHBhcmVudFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9LFxuICAgIGRyb3A6IGRyb3BcbiAgfTtcblxuICBfZXh0ZW5kcyhSZW1vdmUsIHtcbiAgICBwbHVnaW5OYW1lOiAncmVtb3ZlT25TcGlsbCdcbiAgfSk7XG5cbiAgdmFyIGxhc3RTd2FwRWw7XG5cbiAgZnVuY3Rpb24gU3dhcFBsdWdpbigpIHtcbiAgICBmdW5jdGlvbiBTd2FwKCkge1xuICAgICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgICAgc3dhcENsYXNzOiAnc29ydGFibGUtc3dhcC1oaWdobGlnaHQnXG4gICAgICB9O1xuICAgIH1cblxuICAgIFN3YXAucHJvdG90eXBlID0ge1xuICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiBkcmFnU3RhcnQoX3JlZikge1xuICAgICAgICB2YXIgZHJhZ0VsID0gX3JlZi5kcmFnRWw7XG4gICAgICAgIGxhc3RTd2FwRWwgPSBkcmFnRWw7XG4gICAgICB9LFxuICAgICAgZHJhZ092ZXJWYWxpZDogZnVuY3Rpb24gZHJhZ092ZXJWYWxpZChfcmVmMikge1xuICAgICAgICB2YXIgY29tcGxldGVkID0gX3JlZjIuY29tcGxldGVkLFxuICAgICAgICAgICAgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgICAgICAgb25Nb3ZlID0gX3JlZjIub25Nb3ZlLFxuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICAgIGNoYW5nZWQgPSBfcmVmMi5jaGFuZ2VkLFxuICAgICAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgICBpZiAoIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc3dhcCkgcmV0dXJuO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLnNvcnRhYmxlLmVsLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICB2YXIgcHJldlN3YXBFbCA9IGxhc3RTd2FwRWw7XG5cbiAgICAgICAgICBpZiAob25Nb3ZlKHRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIG9wdGlvbnMuc3dhcENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgIGxhc3RTd2FwRWwgPSB0YXJnZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2U3dhcEVsICYmIHByZXZTd2FwRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHByZXZTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfSxcbiAgICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjMpIHtcbiAgICAgICAgdmFyIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjMuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlLFxuICAgICAgICAgICAgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsO1xuICAgICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBsYXN0U3dhcEVsICYmIHRvZ2dsZUNsYXNzKGxhc3RTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGxhc3RTd2FwRWwgJiYgKG9wdGlvbnMuc3dhcCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5vcHRpb25zLnN3YXApKSB7XG4gICAgICAgICAgaWYgKGRyYWdFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgICBzd2FwTm9kZXMoZHJhZ0VsLCBsYXN0U3dhcEVsKTtcbiAgICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgICAgbGFzdFN3YXBFbCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMoU3dhcCwge1xuICAgICAgcGx1Z2luTmFtZTogJ3N3YXAnLFxuICAgICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3dhcEl0ZW06IGxhc3RTd2FwRWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN3YXBOb2RlcyhuMSwgbjIpIHtcbiAgICB2YXIgcDEgPSBuMS5wYXJlbnROb2RlLFxuICAgICAgICBwMiA9IG4yLnBhcmVudE5vZGUsXG4gICAgICAgIGkxLFxuICAgICAgICBpMjtcbiAgICBpZiAoIXAxIHx8ICFwMiB8fCBwMS5pc0VxdWFsTm9kZShuMikgfHwgcDIuaXNFcXVhbE5vZGUobjEpKSByZXR1cm47XG4gICAgaTEgPSBpbmRleChuMSk7XG4gICAgaTIgPSBpbmRleChuMik7XG5cbiAgICBpZiAocDEuaXNFcXVhbE5vZGUocDIpICYmIGkxIDwgaTIpIHtcbiAgICAgIGkyKys7XG4gICAgfVxuXG4gICAgcDEuaW5zZXJ0QmVmb3JlKG4yLCBwMS5jaGlsZHJlbltpMV0pO1xuICAgIHAyLmluc2VydEJlZm9yZShuMSwgcDIuY2hpbGRyZW5baTJdKTtcbiAgfVxuXG4gIHZhciBtdWx0aURyYWdFbGVtZW50cyA9IFtdLFxuICAgICAgbXVsdGlEcmFnQ2xvbmVzID0gW10sXG4gICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0LFxuICAgICAgLy8gZm9yIHNlbGVjdGlvbiB3aXRoIG1vZGlmaWVyIGtleSBkb3duIChTSElGVClcbiAgbXVsdGlEcmFnU29ydGFibGUsXG4gICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlLFxuICAgICAgLy8gSW5pdGlhbCBtdWx0aS1kcmFnIGZvbGQgd2hlbiBkcmFnIHN0YXJ0ZWRcbiAgZm9sZGluZyA9IGZhbHNlLFxuICAgICAgLy8gRm9sZGluZyBhbnkgb3RoZXIgdGltZVxuICBkcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgICAgZHJhZ0VsJDEsXG4gICAgICBjbG9uZXNGcm9tUmVjdCxcbiAgICAgIGNsb25lc0hpZGRlbjtcblxuICBmdW5jdGlvbiBNdWx0aURyYWdQbHVnaW4oKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlEcmFnKHNvcnRhYmxlKSB7XG4gICAgICAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc29ydGFibGUub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIH1cblxuICAgICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICAgIG9uKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLl9jaGVja0tleVVwKTtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICAgIHNlbGVjdGVkQ2xhc3M6ICdzb3J0YWJsZS1zZWxlY3RlZCcsXG4gICAgICAgIG11bHRpRHJhZ0tleTogbnVsbCxcbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgICAgIHZhciBkYXRhID0gJyc7XG5cbiAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoICYmIG11bHRpRHJhZ1NvcnRhYmxlID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgICBkYXRhICs9ICghaSA/ICcnIDogJywgJykgKyBtdWx0aURyYWdFbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBkcmFnRWwudGV4dENvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBNdWx0aURyYWcucHJvdG90eXBlID0ge1xuICAgICAgbXVsdGlEcmFnS2V5RG93bjogZmFsc2UsXG4gICAgICBpc011bHRpRHJhZzogZmFsc2UsXG4gICAgICBkZWxheVN0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkZWxheVN0YXJ0R2xvYmFsKF9yZWYpIHtcbiAgICAgICAgdmFyIGRyYWdnZWQgPSBfcmVmLmRyYWdFbDtcbiAgICAgICAgZHJhZ0VsJDEgPSBkcmFnZ2VkO1xuICAgICAgfSxcbiAgICAgIGRlbGF5RW5kZWQ6IGZ1bmN0aW9uIGRlbGF5RW5kZWQoKSB7XG4gICAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSk7XG4gICAgICB9LFxuICAgICAgc2V0dXBDbG9uZTogZnVuY3Rpb24gc2V0dXBDbG9uZShfcmVmMikge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBfcmVmMi5zb3J0YWJsZSxcbiAgICAgICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG11bHRpRHJhZ0Nsb25lcy5wdXNoKGNsb25lKG11bHRpRHJhZ0VsZW1lbnRzW2ldKSk7XG4gICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnNvcnRhYmxlSW5kZXggPSBtdWx0aURyYWdFbGVtZW50c1tpXS5zb3J0YWJsZUluZGV4O1xuICAgICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcbiAgICAgICAgICB0b2dnbGVDbGFzcyhtdWx0aURyYWdDbG9uZXNbaV0sIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHNbaV0gPT09IGRyYWdFbCQxICYmIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3J0YWJsZS5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKF9yZWYzKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYzLnNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsID0gX3JlZjMucm9vdEVsLFxuICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjMuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICAgICAgY2FuY2VsID0gX3JlZjMuY2FuY2VsO1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgICBpbnNlcnRNdWx0aURyYWdDbG9uZXModHJ1ZSwgcm9vdEVsKTtcbiAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgnY2xvbmUnKTtcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNob3dDbG9uZTogZnVuY3Rpb24gc2hvd0Nsb25lKF9yZWY0KSB7XG4gICAgICAgIHZhciBjbG9uZU5vd1Nob3duID0gX3JlZjQuY2xvbmVOb3dTaG93bixcbiAgICAgICAgICAgIHJvb3RFbCA9IF9yZWY0LnJvb3RFbCxcbiAgICAgICAgICAgIGNhbmNlbCA9IF9yZWY0LmNhbmNlbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyhmYWxzZSwgcm9vdEVsKTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsb25lTm93U2hvd24oKTtcbiAgICAgICAgY2xvbmVzSGlkZGVuID0gZmFsc2U7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfSxcbiAgICAgIGhpZGVDbG9uZTogZnVuY3Rpb24gaGlkZUNsb25lKF9yZWY1KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjUuc29ydGFibGUsXG4gICAgICAgICAgICBjbG9uZU5vd0hpZGRlbiA9IF9yZWY1LmNsb25lTm93SGlkZGVuLFxuICAgICAgICAgICAgY2FuY2VsID0gX3JlZjUuY2FuY2VsO1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgY3NzKGNsb25lLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbG9uZU5vd0hpZGRlbigpO1xuICAgICAgICBjbG9uZXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBkcmFnU3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRyYWdTdGFydEdsb2JhbChfcmVmNikge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBfcmVmNi5zb3J0YWJsZTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcgJiYgbXVsdGlEcmFnU29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgIH0pOyAvLyBTb3J0IG11bHRpLWRyYWcgZWxlbWVudHNcblxuICAgICAgICBtdWx0aURyYWdFbGVtZW50cyA9IG11bHRpRHJhZ0VsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5zb3J0YWJsZUluZGV4IC0gYi5zb3J0YWJsZUluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmNykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgc29ydGFibGUgPSBfcmVmNy5zb3J0YWJsZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgLy8gQ2FwdHVyZSByZWN0cyxcbiAgICAgICAgICAvLyBoaWRlIG11bHRpIGRyYWcgZWxlbWVudHMgKGJ5IHBvc2l0aW9uaW5nIHRoZW0gYWJzb2x1dGUpLFxuICAgICAgICAgIC8vIHNldCBtdWx0aSBkcmFnIGVsZW1lbnRzIHJlY3RzIHRvIGRyYWdSZWN0LFxuICAgICAgICAgIC8vIHNob3cgbXVsdGkgZHJhZyBlbGVtZW50cyxcbiAgICAgICAgICAvLyBhbmltYXRlIHRvIHJlY3RzLFxuICAgICAgICAgIC8vIHVuc2V0IHJlY3RzICYgcmVtb3ZlIGZyb20gRE9NXG4gICAgICAgICAgc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgICAgY3NzKG11bHRpRHJhZ0VsZW1lbnQsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc29ydGFibGUuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gUmVtb3ZlIGFsbCBhdXhpbGlhcnkgbXVsdGlkcmFnIGl0ZW1zIGZyb20gZWwsIGlmIHNvcnRpbmcgZW5hYmxlZFxuXG5cbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRyYWdPdmVyOiBmdW5jdGlvbiBkcmFnT3ZlcihfcmVmOCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gX3JlZjgudGFyZ2V0LFxuICAgICAgICAgICAgY29tcGxldGVkID0gX3JlZjguY29tcGxldGVkLFxuICAgICAgICAgICAgY2FuY2VsID0gX3JlZjguY2FuY2VsO1xuXG4gICAgICAgIGlmIChmb2xkaW5nICYmIH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKHRhcmdldCkpIHtcbiAgICAgICAgICBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoX3JlZjkpIHtcbiAgICAgICAgdmFyIGZyb21Tb3J0YWJsZSA9IF9yZWY5LmZyb21Tb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbCA9IF9yZWY5LnJvb3RFbCxcbiAgICAgICAgICAgIHNvcnRhYmxlID0gX3JlZjkuc29ydGFibGUsXG4gICAgICAgICAgICBkcmFnUmVjdCA9IF9yZWY5LmRyYWdSZWN0O1xuXG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gU2V0dXAgdW5mb2xkIGFuaW1hdGlvblxuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgICByZWN0OiBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICAgIGZyb21Tb3J0YWJsZS5yZW1vdmVBbmltYXRpb25TdGF0ZShtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSwgcm9vdEVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMTApIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjEwLnNvcnRhYmxlLFxuICAgICAgICAgICAgaXNPd25lciA9IF9yZWYxMC5pc093bmVyLFxuICAgICAgICAgICAgaW5zZXJ0aW9uID0gX3JlZjEwLmluc2VydGlvbixcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjEwLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgICAgcGFyZW50RWwgPSBfcmVmMTAucGFyZW50RWwsXG4gICAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMC5wdXRTb3J0YWJsZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlOyAvLyBJZiBsZWF2aW5nIHNvcnQ6ZmFsc2Ugcm9vdCwgb3IgYWxyZWFkeSBmb2xkaW5nIC0gRm9sZCB0byBuZXcgbG9jYXRpb25cblxuICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiAmJiBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxICYmIChmb2xkaW5nIHx8ICFpc093bmVyICYmICFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnNvcnQgJiYgIXB1dFNvcnRhYmxlKSkge1xuICAgICAgICAgICAgLy8gRm9sZDogU2V0IGFsbCBtdWx0aSBkcmFnIGVsZW1lbnRzJ3MgcmVjdHMgdG8gZHJhZ0VsJ3MgcmVjdCB3aGVuIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGludmlzaWJsZVxuICAgICAgICAgICAgdmFyIGRyYWdSZWN0QWJzb2x1dGUgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0QWJzb2x1dGUpOyAvLyBNb3ZlIGVsZW1lbnQocykgdG8gZW5kIG9mIHBhcmVudEVsIHNvIHRoYXQgaXQgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggbXVsdGktZHJhZyBjbG9uZXMgaW5zZXJ0aW9uIGlmIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAgIC8vIHdoaWxlIGZvbGRpbmcsIGFuZCBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHRoZW0gYWdhaW4gYmVjYXVzZSBvbGQgc29ydGFibGUgd2lsbCBubyBsb25nZXIgYmUgZnJvbVNvcnRhYmxlXG5cbiAgICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gQ2xvbmVzIG11c3QgYmUgc2hvd24gKGFuZCBjaGVjayB0byByZW1vdmUgbXVsdGkgZHJhZ3MpIGFmdGVyIGZvbGRpbmcgd2hlbiBpbnRlcmZlcmluZyBtdWx0aURyYWdFbGVtZW50cyBhcmUgbW92ZWQgb3V0XG5cblxuICAgICAgICAgIGlmICghaXNPd25lcikge1xuICAgICAgICAgICAgLy8gT25seSByZW1vdmUgaWYgbm90IGZvbGRpbmcgKGZvbGRpbmcgd2lsbCByZW1vdmUgdGhlbSBhbnl3YXlzKVxuICAgICAgICAgICAgaWYgKCFmb2xkaW5nKSB7XG4gICAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHZhciBjbG9uZXNIaWRkZW5CZWZvcmUgPSBjbG9uZXNIaWRkZW47XG5cbiAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7IC8vIFVuZm9sZCBhbmltYXRpb24gZm9yIGNsb25lcyBpZiBzaG93aW5nIGZyb20gaGlkZGVuXG5cblxuICAgICAgICAgICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWNsb25lc0hpZGRlbiAmJiBjbG9uZXNIaWRkZW5CZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjbG9uZSxcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogY2xvbmVzRnJvbVJlY3RcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY2xvbmUuZnJvbVJlY3QgPSBjbG9uZXNGcm9tUmVjdDtcbiAgICAgICAgICAgICAgICAgIGNsb25lLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoc29ydGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlKF9yZWYxMSkge1xuICAgICAgICB2YXIgZHJhZ1JlY3QgPSBfcmVmMTEuZHJhZ1JlY3QsXG4gICAgICAgICAgICBpc093bmVyID0gX3JlZjExLmlzT3duZXIsXG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMS5hY3RpdmVTb3J0YWJsZTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuYW5pbWF0aW9uICYmICFpc093bmVyICYmIGFjdGl2ZVNvcnRhYmxlLm11bHRpRHJhZy5pc011bHRpRHJhZykge1xuICAgICAgICAgIGNsb25lc0Zyb21SZWN0ID0gX2V4dGVuZHMoe30sIGRyYWdSZWN0KTtcbiAgICAgICAgICB2YXIgZHJhZ01hdHJpeCA9IG1hdHJpeChkcmFnRWwkMSwgdHJ1ZSk7XG4gICAgICAgICAgY2xvbmVzRnJvbVJlY3QudG9wIC09IGRyYWdNYXRyaXguZjtcbiAgICAgICAgICBjbG9uZXNGcm9tUmVjdC5sZWZ0IC09IGRyYWdNYXRyaXguZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIGlmIChmb2xkaW5nKSB7XG4gICAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYxMikge1xuICAgICAgICB2YXIgZXZ0ID0gX3JlZjEyLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICByb290RWwgPSBfcmVmMTIucm9vdEVsLFxuICAgICAgICAgICAgcGFyZW50RWwgPSBfcmVmMTIucGFyZW50RWwsXG4gICAgICAgICAgICBzb3J0YWJsZSA9IF9yZWYxMi5zb3J0YWJsZSxcbiAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYxMi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgICAgICBvbGRJbmRleCA9IF9yZWYxMi5vbGRJbmRleCxcbiAgICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEyLnB1dFNvcnRhYmxlO1xuICAgICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICAgIGlmICghZXZ0KSByZXR1cm47XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBwYXJlbnRFbC5jaGlsZHJlbjsgLy8gTXVsdGktZHJhZyBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlEcmFnS2V5ICYmICF0aGlzLm11bHRpRHJhZ0tleURvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsJDEsIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSk7XG5cbiAgICAgICAgICBpZiAoIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSkge1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChkcmFnRWwkMSk7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIE1vZGlmaWVyIGFjdGl2YXRlZCwgc2VsZWN0IGZyb20gbGFzdCB0byBkcmFnRWxcblxuICAgICAgICAgICAgaWYgKGV2dC5zaGlmdEtleSAmJiBsYXN0TXVsdGlEcmFnU2VsZWN0ICYmIHNvcnRhYmxlLmVsLmNvbnRhaW5zKGxhc3RNdWx0aURyYWdTZWxlY3QpKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBpbmRleChsYXN0TXVsdGlEcmFnU2VsZWN0KSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4KGRyYWdFbCQxKTtcblxuICAgICAgICAgICAgICBpZiAofmxhc3RJbmRleCAmJiB+Y3VycmVudEluZGV4ICYmIGxhc3RJbmRleCAhPT0gY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBpbmNsdWRlIGxhc3RNdWx0aURyYWdTZWxlY3QgKHNlbGVjdCBpdCksIGluIGNhc2UgbW9kaWZpZWQgc2VsZWN0aW9uIGZyb20gbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gKGJ1dCBwcmV2aW91cyBzZWxlY3Rpb24gZXhpc3RlZClcbiAgICAgICAgICAgICAgICB2YXIgbiwgaTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICBuID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgbiA9IGxhc3RJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICh+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihjaGlsZHJlbltpXSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoY2hpbGRyZW5baV0sIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBkcmFnRWwkMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSB0b1NvcnRhYmxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UobXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSksIDEpO1xuICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IG51bGw7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTXVsdGktZHJhZyBkcm9wXG5cblxuICAgICAgICBpZiAoZHJhZ1N0YXJ0ZWQgJiYgdGhpcy5pc011bHRpRHJhZykge1xuICAgICAgICAgIC8vIERvIG5vdCBcInVuZm9sZFwiIGFmdGVyIGFyb3VuZCBkcmFnRWwgaWYgcmV2ZXJ0ZWRcbiAgICAgICAgICBpZiAoKHBhcmVudEVsW2V4cGFuZG9dLm9wdGlvbnMuc29ydCB8fCBwYXJlbnRFbCAhPT0gcm9vdEVsKSAmJiBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCQxKSxcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCA9IGluZGV4KGRyYWdFbCQxLCAnOm5vdCguJyArIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcgJiYgb3B0aW9ucy5hbmltYXRpb24pIGRyYWdFbCQxLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGRyYWdFbCQxLmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0O1xuICAgICAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gcmVjdDsgLy8gUHJlcGFyZSB1bmZvbGQgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgdG9Tb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHJlY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gLy8gTXVsdGkgZHJhZyBlbGVtZW50cyBhcmUgbm90IG5lY2Vzc2FyaWx5IHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9uIGRyb3AsIHNvIHRvIHJlaW5zZXJ0XG4gICAgICAgICAgICAgIC8vIHByb3Blcmx5IHRoZXkgbXVzdCBhbGwgYmUgcmVtb3ZlZFxuXG5cbiAgICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlblttdWx0aURyYWdJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCBjaGlsZHJlblttdWx0aURyYWdJbmRleF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCsrO1xuICAgICAgICAgICAgICB9KTsgLy8gSWYgaW5pdGlhbCBmb2xkaW5nIGlzIGRvbmUsIHRoZSBlbGVtZW50cyBtYXkgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9uIGJlY2F1c2UgdGhleSBhcmUgbm93XG4gICAgICAgICAgICAgIC8vIHVuZm9sZGluZyBhcm91bmQgZHJhZ0VsLCBldmVuIHRob3VnaCBkcmFnRWwgbWF5IG5vdCBoYXZlIGhpcyBpbmRleCBjaGFuZ2VkLCBzbyB1cGRhdGUgZXZlbnRcbiAgICAgICAgICAgICAgLy8gbXVzdCBiZSBmaXJlZCBoZXJlIGFzIFNvcnRhYmxlIHdpbGwgbm90LlxuXG4gICAgICAgICAgICAgIGlmIChvbGRJbmRleCA9PT0gaW5kZXgoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggIT09IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgndXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIE11c3QgYmUgZG9uZSBhZnRlciBjYXB0dXJpbmcgaW5kaXZpZHVhbCByZWN0cyAoc2Nyb2xsIGJhcilcblxuXG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSB0b1NvcnRhYmxlO1xuICAgICAgICB9IC8vIFJlbW92ZSBjbG9uZXMgaWYgbmVjZXNzYXJ5XG5cblxuICAgICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgY2xvbmUucGFyZW50Tm9kZSAmJiBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG51bGxpbmdHbG9iYWw6IGZ1bmN0aW9uIG51bGxpbmdHbG9iYWwoKSB7XG4gICAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95R2xvYmFsOiBmdW5jdGlvbiBkZXN0cm95R2xvYmFsKCkge1xuICAgICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuXG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0tleURvd24pO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgICAgfSxcbiAgICAgIF9kZXNlbGVjdE11bHRpRHJhZzogZnVuY3Rpb24gX2Rlc2VsZWN0TXVsdGlEcmFnKGV2dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRyYWdTdGFydGVkICE9PSBcInVuZGVmaW5lZFwiICYmIGRyYWdTdGFydGVkKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgc2VsZWN0aW9uIGlzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgIT09IHRoaXMuc29ydGFibGUpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiB0YXJnZXQgaXMgbm90IGl0ZW0gaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICAgIGlmIChldnQgJiYgY2xvc2VzdChldnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLnNvcnRhYmxlLmVsLCBmYWxzZSkpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiBsZWZ0IGNsaWNrXG5cbiAgICAgICAgaWYgKGV2dCAmJiBldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgd2hpbGUgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBlbCA9IG11bHRpRHJhZ0VsZW1lbnRzWzBdO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogdGhpcy5zb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICAgIG5hbWU6ICdkZXNlbGVjdCcsXG4gICAgICAgICAgICB0YXJnZXRFbDogZWwsXG4gICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY2hlY2tLZXlEb3duOiBmdW5jdGlvbiBfY2hlY2tLZXlEb3duKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY2hlY2tLZXlVcDogZnVuY3Rpb24gX2NoZWNrS2V5VXAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyhNdWx0aURyYWcsIHtcbiAgICAgIC8vIFN0YXRpYyBtZXRob2RzICYgcHJvcGVydGllc1xuICAgICAgcGx1Z2luTmFtZTogJ211bHRpRHJhZycsXG4gICAgICB1dGlsczoge1xuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgVGhlIGVsZW1lbnQgdG8gYmUgc2VsZWN0ZWRcclxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZWwpIHtcbiAgICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dO1xuICAgICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKSkgcmV0dXJuO1xuXG4gICAgICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICYmIG11bHRpRHJhZ1NvcnRhYmxlICE9PSBzb3J0YWJsZSkge1xuICAgICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuXG4gICAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIHRydWUpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIGRlc2VsZWN0ZWRcclxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIGRlc2VsZWN0KGVsKSB7XG4gICAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXSxcbiAgICAgICAgICAgICAgaW5kZXggPSBtdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKTtcbiAgICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCAhfmluZGV4KSByZXR1cm47XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9sZEluZGljaWVzID0gW10sXG4gICAgICAgICAgICBuZXdJbmRpY2llcyA9IFtdO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgb2xkSW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgaW5kZXg6IG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleFxuICAgICAgICAgIH0pOyAvLyBtdWx0aURyYWdFbGVtZW50cyB3aWxsIGFscmVhZHkgYmUgc29ydGVkIGlmIGZvbGRpbmdcblxuICAgICAgICAgIHZhciBuZXdJbmRleDtcblxuICAgICAgICAgIGlmIChmb2xkaW5nICYmIG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm9sZGluZykge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50LCAnOm5vdCguJyArIF90aGlzMy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld0luZGljaWVzLnB1c2goe1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtczogX3RvQ29uc3VtYWJsZUFycmF5KG11bHRpRHJhZ0VsZW1lbnRzKSxcbiAgICAgICAgICBjbG9uZXM6IFtdLmNvbmNhdChtdWx0aURyYWdDbG9uZXMpLFxuICAgICAgICAgIG9sZEluZGljaWVzOiBvbGRJbmRpY2llcyxcbiAgICAgICAgICBuZXdJbmRpY2llczogbmV3SW5kaWNpZXNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBvcHRpb25MaXN0ZW5lcnM6IHtcbiAgICAgICAgbXVsdGlEcmFnS2V5OiBmdW5jdGlvbiBtdWx0aURyYWdLZXkoa2V5KSB7XG4gICAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSAnY3RybCcpIHtcbiAgICAgICAgICAgIGtleSA9ICdDb250cm9sJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyKDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKGNsb25lc0luc2VydGVkLCByb290RWwpIHtcbiAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW211bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCArIChjbG9uZXNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIHRhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5zZXJ0IG11bHRpLWRyYWcgY2xvbmVzXHJcbiAgICogQHBhcmFtICB7W0Jvb2xlYW5dfSBlbGVtZW50c0luc2VydGVkICBXaGV0aGVyIHRoZSBtdWx0aS1kcmFnIGVsZW1lbnRzIGFyZSBpbnNlcnRlZFxyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSByb290RWxcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluc2VydE11bHRpRHJhZ0Nsb25lcyhlbGVtZW50c0luc2VydGVkLCByb290RWwpIHtcbiAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUsIGkpIHtcbiAgICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bY2xvbmUuc29ydGFibGVJbmRleCArIChlbGVtZW50c0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKSB7XG4gICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUgJiYgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgU29ydGFibGUubW91bnQobmV3IEF1dG9TY3JvbGxQbHVnaW4oKSk7XG4gIFNvcnRhYmxlLm1vdW50KFJlbW92ZSwgUmV2ZXJ0KTtcblxuICBTb3J0YWJsZS5tb3VudChuZXcgU3dhcFBsdWdpbigpKTtcbiAgU29ydGFibGUubW91bnQobmV3IE11bHRpRHJhZ1BsdWdpbigpKTtcblxuICByZXR1cm4gU29ydGFibGU7XG5cbn0pKTtcbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vbW9kdWxlcy91dGlscy5tanMnXG5pbXBvcnQgKiBhcyBzZWFyY2ggZnJvbSAnLi9tb2R1bGVzL3NlYXJjaC5tanMnXG5pbXBvcnQgdG9nZ2xlUHJlZmVyZW5jZXMgZnJvbSAnLi9tb2R1bGVzL3RvZ2dsZVByZWZlcmVuY2VzLm1qcydcbmltcG9ydCB1cmdlbnRBbm5vdW5jZW1lbnQgZnJvbSAnLi93ZWItY29tcG9uZW50cy91cmdlbnQtYW5ub3VuY2VtZW50Lm1qcydcbmltcG9ydCB7IFdDX2Fubm91bmNlbWVudHNXaWRnZXQgfSBmcm9tICcuL3dlYi1jb21wb25lbnRzL2Fubm91bmNlbWVudHMubWpzJ1xuaW1wb3J0ICogYXMgdW5yZWFkQW5ub3VuY2VtZW50cyBmcm9tICcuL21vZHVsZXMvdW5yZWFkQW5ub3VuY2VtZW50cy5tanMnXG5cbmNvbnN0IHBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYWluJykuaWQudG9Mb3dlckNhc2UoKVxuXG4vL2luaXQgd2ViIGNvbXBvbmVudHNcbmlmIChwYWdlID09PSAnZGFzaGJvYXJkJykge1xuICAgIHV0aWxzLmFwcGVuZFdpZGdldHModXRpbHMuZ2V0UHJlZmVyZW5jZXMoKSlcbn1cblxuaWYgKHBhZ2UgPT09ICdhY2NvdW50Jykge1xuICAgIHRvZ2dsZVByZWZlcmVuY2VzKClcbn1cblxuaWYgKHBhZ2UgPT09ICdhbm5vdW5jZW1lbnRzLW92ZXJ2aWV3Jykge1xuICAgIGNvbnN0IGFubm91bmNlbWVudExpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5ub3VuY2VtZW50cycpXG4gICAgYW5ub3VuY2VtZW50TGlzdC5yZW1vdmUoKVxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4gc2VjdGlvbicpLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhbm5vdW5jZW1lbnRzLXdpZGdldCcpKVxuICAgIFdDX2Fubm91bmNlbWVudHNXaWRnZXQocGFnZSlcbn1cblxuXG4vL2NoZWNrIGlmIGJyb3dzZXIgaXMgb25saW5lXG5pZiAobmF2aWdhdG9yLm9uTGluZSkge1xuICAgIC8vdXJnZW50IGFubm91bmNlbWVudHNcbiAgICBjb25zdCBzb2NrZXQgPSBpbygpXG5cbiAgICAvL3N1YnNjcmliZSB0byB1cmdlbnQtYW5ub3VuY2VtZW50c1xuICAgIHNvY2tldC5lbWl0KCdqb2luJywgcGFnZSlcblxuICAgIC8vb24gdXJnZW50LWFubm91bmNlbWVudCBob29rIHVwZGF0ZSBpbnRlcmZhY2UgKHNlZSBXQ191cmdlbnRBbm5vdW5jZW1lbnQpXG4gICAgc29ja2V0Lm9uKCd1cmdlbnQtYW5ub3VuY2VtZW50JywgYW5ub3VuY2VtZW50ID0+IHtcbiAgICAgICAgY29uc3QgdXJnZW50QW5ub3VuY2VtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndXJnZW50LWFubm91bmNlbWVudCcpXG5cbiAgICAgICAgaWYgKHV0aWxzLmV4aXN0cyhbdXJnZW50QW5ub3VuY2VtZW50XSkpIHtcbiAgICAgICAgICAgIHVyZ2VudEFubm91bmNlbWVudC5zZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnLCBhbm5vdW5jZW1lbnQudGl0bGUpXG4gICAgICAgICAgICB1cmdlbnRBbm5vdW5jZW1lbnQuc2V0QXR0cmlidXRlKCd1aWQnLCBhbm5vdW5jZW1lbnQubmV3c0l0ZW1JZClcbiAgICAgICAgfVxuICAgIH0pXG59XG5cblxuXG5cbi8vbWVudSBcbmNvbnN0IG1lbnVJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbnUtaWNvbicpXG5jb25zdCBtZW51ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbnUnKVxuXG5pZiAodXRpbHMuZXhpc3RzKFttZW51SWNvbiwgbWVudV0pKSB7XG5cbiAgICAvL3RvZ2dsZSBtZW51IChvbiBtb2JpbGUpXG4gICAgbWVudUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIG1lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnaGlkZScpXG4gICAgfSlcbn1cblxuXG5cblxuLy9zZWFyY2ggXG5jb25zdCBzZWFyY2hCYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VhcmNoLWJhcicpXG5jb25zdCBzZWFyY2hSZXNldEljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VhcmNoLXJlc2V0JylcbmNvbnN0IHNlYXJjaEljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2VhcmNoLWNvbnRhaW5lciBpbnB1dFt0eXBlPXN1Ym1pdF0nKVxuXG5pZiAodXRpbHMuZXhpc3RzKFtzZWFyY2hCYXIsIHNlYXJjaFJlc2V0SWNvbiwgc2VhcmNoSWNvbl0pKSB7XG5cbiAgICAvL2NvbnRyb2wgc2VhcmNoLXJlc2V0IGljb24gXG4gICAgc2VhcmNoQmFyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gc2VhcmNoLnNob3dSZXNldCgpKVxuICAgIHNlYXJjaEJhci5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4gc2VhcmNoLmhpZGVSZXNldCgpKVxuXG5cbiAgICAvL3Jlc2V0IHNlYXJjaCBpbnB1dFxuICAgIHNlYXJjaFJlc2V0SWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gc2VhcmNoLnJlc2V0KGUpKVxuXG5cbiAgICAvL2RlcGVuZGluZyBvbiBzZWFyY2gtcXVlcnkgZWl0aGVyIGdpdmUgZm9jdXMgdG8gc2VhcmNoYmFyIG9yIHN1Ym1pdCBzZWFyY2gtcXVlcnlcbiAgICBzZWFyY2hJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgIGlmIChzZWFyY2hCYXIudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHNlYXJjaC5mb2N1cyhlKVxuICAgICAgICB9XG4gICAgfSlcblxuXG4gICAgLy9saXN0ZW4gdG8ga2V5Ym9hcmQgaW5wdXRcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgICAgIHNlYXJjaC5mb2N1cyhlKSAvL2dpdmUgc2VhcmNoYmFyIGZvY3VzIGFuZCBoaWRlIHNlYXJjaC1yZXNldCBpY29uXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgIH0pXG59XG5cblxuLy91bnJlYWQgYW5ub3VuY2VtZW50IGluZGljYXRvciBpbiBtZW51XG5jb25zdCBhbm5vdW5jZW1lbnRNZW51SXRlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZW51LXByaW1hcnktbGlua3MgYTpsYXN0LW9mLXR5cGUnKVxuXG5pZiAodXRpbHMuZXhpc3RzKFthbm5vdW5jZW1lbnRNZW51SXRlbV0pICYmIHV0aWxzLnN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpKSB7XG4gICAgdW5yZWFkQW5ub3VuY2VtZW50cy5pbmRpY2F0ZShhbm5vdW5jZW1lbnRNZW51SXRlbSlcbn0iLCJjb25zdCBzZWFyY2hCYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VhcmNoLWJhcicpXG5jb25zdCBzZWFyY2hSZXNldEljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VhcmNoLXJlc2V0JylcblxuZXhwb3J0IGZ1bmN0aW9uIGZvY3VzKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBzZWFyY2hCYXIuZm9jdXMoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd1Jlc2V0KCkge1xuICAgIHNlYXJjaFJlc2V0SWNvbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVSZXNldCgpIHtcbiAgICBpZiAoc2VhcmNoQmFyLnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgIHNlYXJjaFJlc2V0SWNvbi5jbGFzc0xpc3QuYWRkKCdoaWRlJylcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldChlKSB7XG4gICAgc2VhcmNoQmFyLnZhbHVlID0gXCJcIlxuICAgIGZvY3VzKGUpXG59IiwiaW1wb3J0IHsgc2V0TG9jYWxTdG9yYWdlLCBnZXRMb2NhbFN0b3JhZ2UgfSBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLm1qcydcbmltcG9ydCBTb3J0YWJsZSBmcm9tICdzb3J0YWJsZWpzJ1xuXG5jb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYWNjb3VudCBmb3JtJylcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvZ2dsZVByZWZlcmVuY2VzKCkge1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpXG5cbiAgICBzZXRQcmVmZXJlbmNlcygpXG4gICAgc3RhdGVIYW5kbGVyKClcbiAgICBkcmFnSGFuZGxlcigpXG59XG5cbmZ1bmN0aW9uIHNldFByZWZlcmVuY2VzKCkge1xuICAgIGNvbnN0IHByZWZlcmVuY2VzID0gZ2V0TG9jYWxTdG9yYWdlKCdwcmVmZXJlbmNlcycpXG4gICAgaWYgKHByZWZlcmVuY2VzKSB7XG4gICAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9ICcnXG4gICAgICAgIHByZWZlcmVuY2VzLmZvckVhY2gocHJlZmVyZW5jZSA9PiBjb250YWluZXIuYXBwZW5kKGNyZWF0ZUxhYmVscyhwcmVmZXJlbmNlKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UHJlZmVyZW5jZXNPYmplY3QoKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhZ0hhbmRsZXIoKSB7XG4gICAgY29uc3QgcHJlZmVyZW5jZXNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcHJlZmVyZW5jZXMnKVxuXG4gICAgbmV3IFNvcnRhYmxlKHByZWZlcmVuY2VzQ29udGFpbmVyLCB7XG4gICAgICAgIGFuaW1hdGlvbjogMTUwLFxuICAgICAgICBvbkVuZDogKCkgPT4gc2V0UHJlZmVyZW5jZXNPYmplY3QoKVxuICAgIH0pXG59XG5cbi8vIFNhdmluZyBhbmQgY2hhbmdpbmcgcHJlZmVyZW5jZXMgXG5mdW5jdGlvbiBzZXRQcmVmZXJlbmNlc09iamVjdCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2FjY291bnQgZm9ybSBsYWJlbCcpXVxuICAgIGxldCBwcmVmZXJlbmNlcyA9IFtdXG5cbiAgICBpbnB1dHMuZm9yRWFjaChsYWJlbCA9PiB7XG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgY29uc3QgaWQgPSBsYWJlbC5pZFxuICAgICAgICBjb25zdCB0ZXh0ID0gbGFiZWwudGV4dENvbnRlbnRcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBsYWJlbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmNoZWNrZWRcblxuICAgICAgICAvLyBTZXQgTG9jYWxTdG9yYWdlXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHsgaWQ6IGlkLCBuYW1lOiB0ZXh0LCBzdGF0ZTogc3RhdGUgfVxuICAgICAgICBwcmVmZXJlbmNlcy5wdXNoKG9iamVjdClcbiAgICAgICAgc2V0TG9jYWxTdG9yYWdlKCdwcmVmZXJlbmNlcycsIHByZWZlcmVuY2VzKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJlZmVyZW5jZXNcbn1cblxuZnVuY3Rpb24gc3RhdGVIYW5kbGVyKCkge1xuICAgIGNvbnN0IGlucHV0cyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjYWNjb3VudCBmb3JtIGxhYmVsJyldXG4gICAgY29uc3QgZGF0YSA9IGdldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnKVxuXG4gICAgaW5wdXRzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICB1cGRhdGVTdGF0ZShkYXRhLCBsYWJlbClcblxuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAvLyBEYXRhXG4gICAgICAgICAgICBjb25zdCBpZCA9IGxhYmVsLmlkXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGV2ZW50LnRhcmdldC5jaGVja2VkXG5cbiAgICAgICAgICAgIC8vIENoYW5nZSBMb2NhbFN0b3JhZ2VcbiAgICAgICAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSBkYXRhLmZpbmQocHJlZmVyZW5jZSA9PiBwcmVmZXJlbmNlLmlkID09PSBpZClcbiAgICAgICAgICAgIHByZWZlcmVuY2Uuc3RhdGUgPSBzdGF0ZVxuICAgICAgICAgICAgc2V0TG9jYWxTdG9yYWdlKCdwcmVmZXJlbmNlcycsIGRhdGEpXG5cbiAgICAgICAgICAgIC8vIENoYW5nZSBzdGF0ZSB2aXN1YWx5XG4gICAgICAgICAgICBwcmVmZXJlbmNlLnN0YXRlID09PSBmYWxzZSA/IGxhYmVsLmNsYXNzTGlzdC5hZGQoJ29mZicpIDogbGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmJylcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShkYXRhLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcHJlZmVyZW5jZSA9IGRhdGEuZmluZChwcmVmZXJlbmNlID0+IHByZWZlcmVuY2UuaWQgPT09IGVsZW1lbnQuaWQpXG4gICAgcHJlZmVyZW5jZS5zdGF0ZSA9PT0gZmFsc2UgPyBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ29mZicpIDogZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdvZmYnKVxufVxuXG4vLyBSZWFyYW5naW5nIG9yZGVyXG5mdW5jdGlvbiBjcmVhdGVMYWJlbHMocHJlZmVyZW5jZSkge1xuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKVxuICAgIGxhYmVsLmlkID0gcHJlZmVyZW5jZS5pZFxuICAgIGxhYmVsLmRyYWdnYWJsZSA9IHRydWVcbiAgICBwcmVmZXJlbmNlLnN0YXRlID8gbGFiZWwuY2xhc3NOYW1lID0gJ29uJyA6IGxhYmVsLmNsYXNzTmFtZSA9ICdvZmYnXG5cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94J1xuICAgIGlucHV0LmNoZWNrZWQgPSBwcmVmZXJlbmNlLnN0YXRlXG5cbiAgICBsYWJlbC5hcHBlbmQoaW5wdXQpXG4gICAgbGFiZWwuYXBwZW5kKHByZWZlcmVuY2UubmFtZSlcblxuICAgIHJldHVybiBsYWJlbFxufSIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL21vZHVsZXMvdXRpbHMubWpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaW5kaWNhdGUoaXRlbSkge1xuICAgIGdldFVucmVhZCgpXG4gICAgICAgIC50aGVuKG51bWJlclVucmVhZCA9PiB7XG4gICAgICAgICAgICBpZiAobnVtYmVyVW5yZWFkID4gMCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgndW5yZWFkLWluZGljYXRvcicpXG4gICAgICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ251bWJlci11bnJlYWQnLCBudW1iZXJVbnJlYWQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndW5yZWFkLWluZGljYXRvcicpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG59XG5cblxuZnVuY3Rpb24gZ2V0QW5ub3VuY2VtZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgIH1cblxuICAgIHJldHVybiBmZXRjaCgnL2Fubm91bmNlbWVudHNsaXN0Jywgb3B0aW9ucykudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbn1cblxuZnVuY3Rpb24gZ2V0VW5yZWFkKCkge1xuICAgIGNvbnN0IHN0b3JlZEhpc3RvcnkgPSB1dGlscy5nZXRMb2NhbFN0b3JhZ2UoJ3JlYWQtaGlzdG9yeScpXG4gICAgY29uc3QgbnVtYmVyVW5yZWFkID0gZ2V0QW5ub3VuY2VtZW50cygpXG4gICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgW2Fubm91bmNlbWVudHMsIGNhdGVnb3JpZXNdID0ganNvblxuICAgICAgICAgICAgcmV0dXJuIGFubm91bmNlbWVudHNcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oYW5ub3VuY2VtZW50cyA9PiB7XG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZVbnJlYWQgPSAwXG4gICAgICAgICAgICBpZiAoc3RvcmVkSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIGFubm91bmNlbWVudHMuZm9yRWFjaChhbm5vdW5jZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3JlZEhpc3RvcnkuaW5jbHVkZXMoYW5ub3VuY2VtZW50Lm5ld3NJdGVtSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZlVucmVhZCsrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck9mVW5yZWFkXG4gICAgICAgIH0pXG4gICAgcmV0dXJuIG51bWJlclVucmVhZFxufSIsImltcG9ydCB7IFdDX3N0dWR5cHJvZ3Jlc3MgfSBmcm9tICcuLi93ZWItY29tcG9uZW50cy9zdHVkeS1wcm9ncmVzcy5tanMnXG5pbXBvcnQgeyBXQ19zY2hlZHVsZVdpZGdldCB9IGZyb20gJy4uL3dlYi1jb21wb25lbnRzL3NjaGVkdWxlLm1qcydcbmltcG9ydCB7IFdDX2NvdXJzZW92ZXJ2aWV3IH0gZnJvbSAnLi4vd2ViLWNvbXBvbmVudHMvY291cnNlLW92ZXJ2aWV3Lm1qcydcbmltcG9ydCB7IFdDX2Fubm91bmNlbWVudHNXaWRnZXQgfSBmcm9tICcuLi93ZWItY29tcG9uZW50cy9hbm5vdW5jZW1lbnRzLm1qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhbLi4udmFyaWFibGVzXSkge1xuICAgIGNvbnN0IGV4aXN0cyA9IHZhcmlhYmxlcy5ldmVyeSh2YXJpYWJsZSA9PiB2YXJpYWJsZSAhPSBudWxsKVxuICAgIHJldHVybiBleGlzdHNcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlKG5hbWUsIGl0ZW0pIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBKU09OLnN0cmluZ2lmeShpdGVtKSlcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlKGl0ZW0pIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShpdGVtKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JhZ2VBdmFpbGFibGUodHlwZSkgeyAvL3NvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSS9Vc2luZ190aGVfV2ViX1N0b3JhZ2VfQVBJXG4gICAgbGV0IHN0b3JhZ2VcbiAgICB0cnkge1xuICAgICAgICBzdG9yYWdlID0gd2luZG93W3R5cGVdXG4gICAgICAgIGxldCB4ID0gJ19fc3RvcmFnZV90ZXN0X18nXG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIChcbiAgICAgICAgICAgICAgICBlLmNvZGUgPT09IDIyIHx8XG4gICAgICAgICAgICAgICAgZS5jb2RlID09PSAxMDE0IHx8XG4gICAgICAgICAgICAgICAgZS5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJyB8fFxuICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJykgJiZcbiAgICAgICAgICAgIChzdG9yYWdlICYmIHN0b3JhZ2UubGVuZ3RoICE9PSAwKVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByZWZlcmVuY2VzKCkge1xuICAgIGxldCB3aWRnZXRFbGVtZW50c1xuXG4gICAgaWYgKHN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpKSB7XG4gICAgICAgIGNvbnN0IHByZWZlcmVuY2VzID0gZ2V0TG9jYWxTdG9yYWdlKCdwcmVmZXJlbmNlcycpXG4gICAgICAgIGlmIChwcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgd2lkZ2V0RWxlbWVudHMgPSBjaGVja2VyKHByZWZlcmVuY2VzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkZ2V0RWxlbWVudHMgPSBbJ2Fubm91bmNlbWVudHMtd2lkZ2V0JywgJ3N0dWR5LXByb2dyZXNzJywgJ2NvdXJzZS1vdmVydmlldycsICdzY2hlZHVsZS13aWRnZXQnXVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lkZ2V0RWxlbWVudHMgPSBbJ2Fubm91bmNlbWVudHMtd2lkZ2V0JywgJ3N0dWR5LXByb2dyZXNzJywgJ2NvdXJzZS1vdmVydmlldycsICdzY2hlZHVsZS13aWRnZXQnXVxuICAgIH1cblxuICAgIHJldHVybiB3aWRnZXRFbGVtZW50c1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kV2lkZ2V0cyh3aWRnZXQpIHtcbiAgICAvLyBSZW1vdmUgRUpTIHRlbXBsYXRlc1xuICAgIGNvbnN0IGRvbUVsZW1lbnRzID0gWydhbm5vdW5jZW1lbnRzJywgJ3N0dWR5LXByb2dyZXNzJywgJ2NvdXJzZS1vdmVydmlldycsICdzY2hlZHVsZSddXG4gICAgZG9tRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpLnJlbW92ZSgpKVxuXG4gICAgLy8gQWRkaW5nIHdpZGdldHNcbiAgICB3aWRnZXQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbiBzZWN0aW9uJykuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXRlbSkpXG5cbiAgICAgICAgaWYgKGl0ZW0gPT09ICdzdHVkeS1wcm9ncmVzcycpIHtcbiAgICAgICAgICAgIFdDX3N0dWR5cHJvZ3Jlc3MoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnY291cnNlLW92ZXJ2aWV3Jykge1xuICAgICAgICAgICAgV0NfY291cnNlb3ZlcnZpZXcoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnc2NoZWR1bGUtd2lkZ2V0Jykge1xuICAgICAgICAgICAgV0Nfc2NoZWR1bGVXaWRnZXQoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnYW5ub3VuY2VtZW50cy13aWRnZXQnKSB7XG4gICAgICAgICAgICBXQ19hbm5vdW5jZW1lbnRzV2lkZ2V0KCdkYXNoYm9hcmQnKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrZXIocHJlZmVyZW5jZXMpIHtcbiAgICBjb25zdCB3aWRnZXRFbGVtZW50cyA9IFtdXG5cbiAgICAvLyBBbm5vdW5jZW1lbnRzXG4gICAgcHJlZmVyZW5jZXMuZm9yRWFjaChwcmVmZXJlbmNlID0+IHtcbiAgICAgICAgcHJlZmVyZW5jZS5pZCA9IHBhcnNlSW50KHByZWZlcmVuY2UuaWQpXG5cbiAgICAgICAgaWYgKHByZWZlcmVuY2Uuc3RhdGUgJiYgcHJlZmVyZW5jZS5pZCA9PT0gMCkge1xuICAgICAgICAgICAgd2lkZ2V0RWxlbWVudHMucHVzaCgnYW5ub3VuY2VtZW50cy13aWRnZXQnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJlbmNlLnN0YXRlICYmIHByZWZlcmVuY2UuaWQgPT09IDEpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzLnB1c2goJ3N0dWR5LXByb2dyZXNzJylcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZmVyZW5jZS5zdGF0ZSAmJiBwcmVmZXJlbmNlLmlkID09PSAyKSB7XG4gICAgICAgICAgICB3aWRnZXRFbGVtZW50cy5wdXNoKCdjb3Vyc2Utb3ZlcnZpZXcnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJlbmNlLnN0YXRlICYmIHByZWZlcmVuY2UuaWQgPT09IDMpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzLnB1c2goJ3NjaGVkdWxlLXdpZGdldCcpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHdpZGdldEVsZW1lbnRzXG59IiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vbW9kdWxlcy91dGlscy5tanMnXG5cbmV4cG9ydCB7IGluaXQgYXMgV0NfYW5ub3VuY2VtZW50c1dpZGdldCB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuKjpmb2N1cyB7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cbmgyIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcblx0Zm9udC1mYW1pbHk6IFwiT3BlblNhbnMtUmVndWxhclwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXHRmb250LXdlaWdodDogbGlnaHRlcjtcblx0bGluZS1oZWlnaHQ6IDEuMTtcbn1cbnAge1xuXHRtYXJnaW46IDA7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQge1xuXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyICNhbm5vdW5jZW1lbnQtbGVnZW5kIHAge1xuXHRjb2xvcjogYmxhY2s7XG5cdGZvbnQtc2l6ZTogMTRweDtcblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRtYXJnaW4tcmlnaHQ6IDIwcHg7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcDpsYXN0LW9mLXR5cGUge1xuXHRtYXJnaW4tcmlnaHQ6IDA7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcDo6YmVmb3JlIHtcblx0Y29udGVudDogXCJcIjtcblx0aGVpZ2h0OiAxNXB4O1xuXHRtYXJnaW4tYm90dG9tOiAtMnB4O1xuXHR3aWR0aDogMTVweDtcblx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xuXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5PcGxlaWRpbmc6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNEQzE0M0M7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5GYWN1bHRlaXQ6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNEQ0I2MTQ7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5IdkE6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICMxNDlFREM7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5NZWRlemVnZ2Vuc2NoYXA6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICMxNERDNjk7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgYSB7XG5cdG1hcmdpbjogMCAwIDE1cHggMDtcblx0ZGlzcGxheTogYmxvY2s7XG5cdGNvbG9yOiBibGFjaztcblx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6aG92ZXIge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGMkYyO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6Zm9jdXMge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjREREREREO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQge1xuXHRtYXJnaW46IDA7XG5cdHBhZGRpbmc6IDVweCAwIDVweCAxMHB4O1xuXHRib3JkZXItbGVmdDogNXB4IHNvbGlkO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuT3BsZWlkaW5nIHtcblx0Ym9yZGVyLWNvbG9yOiAjREMxNDNDO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuRmFjdWx0ZWl0IHtcblx0Ym9yZGVyLWNvbG9yOiAjRENCNjE0O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuSHZBIHtcblx0Ym9yZGVyLWNvbG9yOiAjMTQ5RURDO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuTWVkZXplZ2dlbnNjaGFwIHtcblx0Ym9yZGVyLWNvbG9yOiAjMTREQzY5O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQgcDpmaXJzdC1vZi10eXBlIHtcbiAgICBmb250LWZhbWlseTogXCJPcGVuU2Fucy1Cb2xkXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLnJlYWQgLmFubm91bmNlbWVudCBwOmZpcnN0LW9mLXR5cGUge1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLVJlZ3VsYXJcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbn1cbi5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lciAuYW5ub3VuY2VtZW50IHA6bGFzdC1vZi10eXBlIHtcblx0Y29sb3I6ICM2NjY2NjY7XG5cdGZvbnQtc2l6ZTogMTRweDtcbn0gICAgXG4uYWxsQW5ub3VuY2VtZW50cyB7XG4gICAgbWFyZ2luLXRvcDogMzBweDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZGlzcGxheTogZmxleDtcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5hbGxBbm5vdW5jZW1lbnRzOmhvdmVyLFxuLmFsbEFubm91bmNlbWVudHM6Zm9jdXMge1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5hbGxBbm5vdW5jZW1lbnRzIGltZyB7XG4gICAgICAgIGhlaWdodDogMTJweDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG59XG48L3N0eWxlPlxuPGRpdiBpZD1cImFubm91bmNlbWVudHNcIj48L2Rpdj5cbjxoMj5NZWRlZGVsaW5nZW48L2gyPlxuPGRpdiBjbGFzcz1cImFubm91bmNlbWVudHMtY29udGFpbmVyXCI+XG5cdDxkaXYgaWQ9XCJhbm5vdW5jZW1lbnQtbGVnZW5kXCI+PC9kaXY+XG48L2Rpdj5cbjxhIGNsYXNzPVwiYWxsQW5ub3VuY2VtZW50c1wiIGhyZWY9XCIvYW5ub3VuY2VtZW50cy9cIiB0YXJnZXQ9XCJfc2VsZlwiPkFsbGUgbWVkZWRlbGluZ2VuXG5cdDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2E+YFxuXG5mdW5jdGlvbiBpbml0KHBhZ2VOYW1lKSB7XG4gICAgY2xhc3MgYW5ub3VuY2VtZW50TGlzdCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpXG5cbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0YSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oanNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFthbm5vdW5jZW1lbnRzLCBjYXRlZ29yaWVzXSA9IGpzb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVMZWdlbmRhKGNhdGVnb3JpZXMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWdlTmFtZSA9PT0gJ2Rhc2hib2FyZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm91bmNlbWVudHMuc3BsaWNlKDUsIGFubm91bmNlbWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQW5ub3VuY2VtZW50cyhhbm5vdW5jZW1lbnRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLmFubm91bmNlbWVudENvbnRhaW5lciA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuYW5ub3VuY2VtZW50cy1jb250YWluZXInKVxuICAgICAgICAgICAgdGhpcy5hbm5vdW5jZW1lbnRMZWdlbmQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI2Fubm91bmNlbWVudC1sZWdlbmQnKVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goJy9hbm5vdW5jZW1lbnRzbGlzdCcsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjcmVhdGVMZWdlbmRhKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChjYXQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VtZW50TGVnZW5kLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgYDxwIGNsYXNzPVwiJHtjYXR9XCI+JHtjYXR9PC9wPmApXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQW5ub3VuY2VtZW50cyhhbm5vdW5jZW1lbnRzKSB7XG4gICAgICAgICAgICBhbm5vdW5jZW1lbnRzLmZvckVhY2goYW5ub3VuY2VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlbWVudENvbnRhaW5lci5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGBcblx0XHRcdFx0PGEgaHJlZj1cIi9hbm5vdW5jZW1lbnRzLyR7YW5ub3VuY2VtZW50Lm5ld3NJdGVtSWR9XCIgdGFyZ2V0PVwiX3NlbGZcIiB1aWQ9XCIke2Fubm91bmNlbWVudC5uZXdzSXRlbUlkfVwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJhbm5vdW5jZW1lbnQgJHthbm5vdW5jZW1lbnQudGFnc1swXX1cIiBpZD1cIiR7YW5ub3VuY2VtZW50Lm5ld3NJdGVtSWR9XCI+XG4gICAgICAgICAgICAgICAgXHRcdDxwPiR7YW5ub3VuY2VtZW50LnRpdGxlfTwvcD5cbiAgICAgICAgICAgICAgICBcdFx0PHA+JHthbm5vdW5jZW1lbnQucHVibGlzaERhdGV9IC0gJHthbm5vdW5jZW1lbnQudGFnc1swXX08L3A+XG4gICAgICAgICAgIFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2E+YClcblxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5zdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRIaXN0b3J5ID0gdXRpbHMuZ2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRIaXN0b3J5ID0gc3RvcmVkSGlzdG9yeSA/IHN0b3JlZEhpc3RvcnkgOiBbXVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmFubm91bmNlbWVudENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhOmxhc3Qtb2YtdHlwZScpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZEhpc3RvcnkuaW5jbHVkZXMobGluay5nZXRBdHRyaWJ1dGUoJ3VpZCcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc0xpc3QuYWRkKCdyZWFkJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5zdG9yZShsaW5rKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmUoYW5ub3VuY2VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRIaXN0b3J5LnB1c2goYW5ub3VuY2VtZW50LmdldEF0dHJpYnV0ZSgndWlkJykpXG4gICAgICAgICAgICB1dGlscy5zZXRMb2NhbFN0b3JhZ2UoJ3JlYWQtaGlzdG9yeScsIHRoaXMucmVhZEhpc3RvcnkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdhbm5vdW5jZW1lbnRzLXdpZGdldCcsIGFubm91bmNlbWVudExpc3QpXG59IiwiZXhwb3J0IHsgaW5pdCBhcyBXQ19jb3Vyc2VvdmVydmlldyB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuaDIge1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNEREREREQ7XG4gICAgbWFyZ2luOiAwIDAgMTVweCAwO1xuXHRmb250LWZhbWlseTogXCJPcGVuU2Fucy1SZWd1bGFyXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG5cdGZvbnQtd2VpZ2h0OiBsaWdodGVyO1xuXHRsaW5lLWhlaWdodDogMS4xO1xufVxuXG5wIHtcblx0bWFyZ2luOiAwO1xufVxuXG4ubmF2aWdhdG9yIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjREREREREO1xuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZm9udC1zaXplOiAxNnB4O1xufVxuXG4ubmF2aWdhdG9yIHNwYW4gIHtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG59XG5cbi5uYXZpZ2F0b3IgaW1nIHtcbiAgICBwYWRkaW5nOiAxMHB4O1xufVxuXG4ubmF2aWdhdG9yIGltZzpub3QoLmRpc2FibGVkKSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ubmF2aWdhdG9yIGltZy5kaXNhYmxlZCB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgb3BhY2l0eTogLjU7XG59XG5cbi5jb3Vyc2Uge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMWZyO1xuICAgIGdyaWQtY29sdW1uLWdhcDogMjBweDtcbiAgICBwYWRkaW5nOiAxNXB4IDIwcHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNEREREREQ7XG59XG5cbi5jb3Vyc2UgcDpmaXJzdC1vZi10eXBlIHtcbiAgICBmb250LWZhbWlseTogXCJPcGVuU2Fucy1Cb2xkXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xufVxuXG4uY291cnNlIHVsIHtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbn1cblxuLmNvdXJzZSB1bCBsaSB7XG4gICAgZGlzcGxheTogaW5saW5lO1xufVxuXG4uY291cnNlIHVsIGxpOm5vdCg6bGFzdC1vZi10eXBlKTphZnRlciB7XG4gICAgY29udGVudDogXCIsIFwiO1xuICAgIHdoaXRlLXNwYWNlOiBwcmU7XG59XG5cbmEge1xuICAgIG1hcmdpbi10b3A6IDMwcHg7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuYTpob3ZlcixcbmE6Zm9jdXMge1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIG91dGxpbmU6IG5vbmU7XG59XG5cbmEgaW1nIHtcbiAgICBoZWlnaHQ6IDEycHg7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG59XG48L3N0eWxlPlxuXG48aDI+VmFra2Vub3ZlcnppY2h0PC9oMj5cblxuPGRpdiBjbGFzcz1cIm5hdmlnYXRvclwiPlxuICAgIDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LWxlZnQuc3ZnXCIgYWx0PVwiYXJyb3ctbGVmdFwiPjwvaW1nPlxuICAgIDxzcGFuPjwvc3Bhbj5cbiAgICA8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1yaWdodC5zdmdcIiBhbHQ9XCJhcnJvdy1yaWdodFwiPjwvaW1nPlxuPC9kaXY+XG5cbjxkaXYgaWQ9XCJjb3Vyc2Utb3ZlcnZpZXdcIj48L2Rpdj5cblxuPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vc2lzLmh2YS5ubC9cIj5Wb2xsZWRpZyBvdmVyemljaHRcbiAgICA8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1yaWdodC5zdmdcIiBhbHQ9XCJhcnJvdy1yaWdodFwiPjwvaW1nPlxuPC9hPlxuYFxuXG5mdW5jdGlvbiBpbml0KCkge1xuICAgIGNsYXNzIENvdXJzZU92ZXJ2aWV3IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIFNldHVwXG4gICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgICAgICAvLyBWYXJpYWJsZXNcbiAgICAgICAgICAgIHRoaXMuY291cnNlQ29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNjb3Vyc2Utb3ZlcnZpZXcnKVxuICAgICAgICAgICAgdGhpcy5jb3Vyc2VNb21lbnQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLm5hdmlnYXRvciBzcGFuJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dQcmV2aW91cyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdG9yIGltZzpmaXJzdC1vZi10eXBlJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0ID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5uYXZpZ2F0b3IgaW1nOmxhc3Qtb2YtdHlwZScpXG4gICAgICAgICAgICB0aGlzLnllYXJJbmRleCA9IDJcbiAgICAgICAgICAgIHRoaXMucXVhcnRlckluZGV4ID0gM1xuXG4gICAgICAgICAgICAvLyBEYXRhXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmdldERhdGEoKS50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVIYW5kbGVyKClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBqc29uW3RoaXMueWVhckluZGV4XS5xdWFydGVyc1t0aGlzLnF1YXJ0ZXJJbmRleF0uY291cnNlc1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ291cnNlT3ZlcnZpZXcoZGF0YSlcblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGpzb25cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIEV2ZW50TGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmFycm93UHJldmlvdXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm5hdmlnYXRlKCdwcmV2aW91cycpKVxuICAgICAgICAgICAgdGhpcy5hcnJvd05leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm5hdmlnYXRlKCduZXh0JykpXG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVOYXZpZ2F0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmNvdXJzZU1vbWVudC50ZXh0Q29udGVudCA9IGBKYWFyICR7dGhpcy55ZWFySW5kZXggKyAxfSAtIEJsb2sgJHt0aGlzLnF1YXJ0ZXJJbmRleCArIDF9YFxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlQ291cnNlT3ZlcnZpZXcoY291cnNlcykge1xuICAgICAgICAgICAgdGhpcy5jb3Vyc2VDb250YWluZXIudGV4dENvbnRlbnQgPSBcIlwiXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5hdmlnYXRvcigpXG5cbiAgICAgICAgICAgIGNvdXJzZXMuZm9yRWFjaChjb3Vyc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ2NvdXJzZScpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb3Vyc2VOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgY291cnNlTmFtZS50ZXh0Q29udGVudCA9IGNvdXJzZS5jb3Vyc2VcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kKGNvdXJzZU5hbWUpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKVxuICAgICAgICAgICAgICAgIGNvdXJzZS5sZWN0dXJlcnMuZm9yRWFjaChsZWN0dXJlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlYWNoZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpXG4gICAgICAgICAgICAgICAgICAgIGxlY3R1cmVyID09PSBcIlwiID8gdGVhY2hlci50ZXh0Q29udGVudCA9ICdHZWVuIHNwZWNpZmlla2UgZG9jZW50JyA6IHRlYWNoZXIudGV4dENvbnRlbnQgPSBsZWN0dXJlclxuICAgICAgICAgICAgICAgICAgICBsaXN0LmFwcGVuZCh0ZWFjaGVyKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZChsaXN0KVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb3Vyc2VDb250YWluZXIuYXBwZW5kKGRpdilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBuYXZpZ2F0ZShkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2aW91cycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWFydGVySW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhcnRlckluZGV4LS1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucXVhcnRlckluZGV4ID09PSAwICYmIHRoaXMueWVhckluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YXJ0ZXJJbmRleCA9IDNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFySW5kZXgtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVhcnRlckluZGV4IDwgMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YXJ0ZXJJbmRleCsrXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnF1YXJ0ZXJJbmRleCA9PT0gMyAmJiB0aGlzLnllYXJJbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFydGVySW5kZXggPSAwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhckluZGV4KytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGVIYW5kbGVyKClcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVt0aGlzLnllYXJJbmRleF0ucXVhcnRlcnNbdGhpcy5xdWFydGVySW5kZXhdLmNvdXJzZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ291cnNlT3ZlcnZpZXcoZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIG5hdmlnYXRlSGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMueWVhckluZGV4ID09PSAwICYmIHRoaXMucXVhcnRlckluZGV4ID09PSAwID9cbiAgICAgICAgICAgICAgICB0aGlzLmFycm93UHJldmlvdXMuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKSA6IHRoaXMuYXJyb3dQcmV2aW91cy5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpXG5cbiAgICAgICAgICAgIHRoaXMueWVhckluZGV4ID09PSAzICYmIHRoaXMucXVhcnRlckluZGV4ID09PSAzID9cbiAgICAgICAgICAgICAgICB0aGlzLmFycm93TmV4dC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpIDogdGhpcy5hcnJvd05leHQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyc1xuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCgnL2NvdXJzZW92ZXJ2aWV3Jywgb3B0aW9ucykudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY291cnNlLW92ZXJ2aWV3JywgQ291cnNlT3ZlcnZpZXcpXG59IiwiZXhwb3J0IHsgaW5pdCBhcyBXQ19zY2hlZHVsZVdpZGdldCB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuaDIge1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNEREREREQ7XG4gICAgbWFyZ2luOiAwIDAgMTVweCAwO1xuXHRmb250LWZhbWlseTogXCJPcGVuU2Fucy1SZWd1bGFyXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG5cdGZvbnQtd2VpZ2h0OiBsaWdodGVyO1xuXHRsaW5lLWhlaWdodDogMS4xO1xufVxuXG5wIHtcblx0bWFyZ2luOiAwO1xufVxuXG4ubmF2aWdhdG9yIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjREREREREO1xuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZm9udC1zaXplOiAxNnB4O1xufVxuXG4ubmF2aWdhdG9yIHNwYW4gIHtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG59XG5cbi5uYXZpZ2F0b3IgaW1nIHtcbiAgICBwYWRkaW5nOiAxMHB4O1xufVxuXG4ubmF2aWdhdG9yIGltZzpub3QoLmRpc2FibGVkKSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ubmF2aWdhdG9yIGltZy5kaXNhYmxlZCB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgb3BhY2l0eTogLjU7XG59XG5cbi5zY2hlZHVsZS1jb3Vyc2Uge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIDFmcjtcbiAgICBncmlkLWNvbHVtbi1nYXA6IDIwcHg7XG4gICAgZ3JpZC1yb3ctZ2FwOiA1cHg7XG4gICAgcGFkZGluZzogMTVweCAyMHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xufVxuXG4uc2NoZWR1bGUtY291cnNlIHA6Zmlyc3Qtb2YtdHlwZSxcbi5zY2hlZHVsZS1jb3Vyc2UgcDpudGgtb2YtdHlwZSgzKSB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtQm9sZFwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xufVxuXG5hIHtcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbmE6aG92ZXIsXG5hOmZvY3VzIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBvdXRsaW5lOiBub25lO1xufVxuXG5hIGltZyB7XG4gICAgaGVpZ2h0OiAxMnB4O1xuICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xufVxuPC9zdHlsZT5cbjxoMj5EYWdyb29zdGVyPC9oMj5cbjxkaXYgY2xhc3M9XCJuYXZpZ2F0b3JcIj5cblx0PGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctbGVmdC5zdmdcIiBhbHQ9XCJhcnJvdy1sZWZ0XCIgY2xhc3M9XCJkaXNhYmxlZFwiPjwvaW1nPlxuXHQ8c3Bhbj48L3NwYW4+XG5cdDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2Rpdj5cbjxkaXYgaWQ9XCJzY2hlZHVsZXMtY29udGFpbmVyXCI+PC9kaXY+XG48YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly9yb29zdGVyLmh2YS5ubC9zY2hlZHVsZVwiPlZvbGxlZGlnIHJvb3N0ZXJcblx0PGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvYT5cbmBcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjbGFzcyBzY2hlZHVsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpXG5cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpXG5cbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZ2V0RGF0YSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oanNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2NoZWR1bGUoanNvblswXSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0ganNvblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5uYXZpZ2F0b3InKVxuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXZpb3VzID0gdGhpcy5uYXZpZ2F0b3IucXVlcnlTZWxlY3RvcignaW1nOmZpcnN0LW9mLXR5cGUnKVxuICAgICAgICAgICAgdGhpcy5hcnJvd05leHQgPSB0aGlzLm5hdmlnYXRvci5xdWVyeVNlbGVjdG9yKCdpbWc6bGFzdC1vZi10eXBlJylcblxuICAgICAgICAgICAgdGhpcy5hcnJvd05leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm5hdmlnYXRlKCduZXh0JykpXG4gICAgICAgICAgICB0aGlzLmFycm93UHJldmlvdXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm5hdmlnYXRlKCdwcmV2aW91cycpKVxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKCcvc2NoZWR1bGUnLCBvcHRpb25zKS50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlU2NoZWR1bGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVzQ29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdzY2hlZHVsZXMtY29udGFpbmVyJylcbiAgICAgICAgICAgIHNjaGVkdWxlc0NvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCJcblxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0b3IucXVlcnlTZWxlY3Rvcignc3BhbicpLnRleHRDb250ZW50ID0gYCR7ZGF0YS5kYXl9LSR7ZGF0YS5tb250aH0tJHtkYXRhLnllYXJ9YFxuXG4gICAgICAgICAgICBkYXRhLnNjaGVkdWxlcy5mb3JFYWNoKHNjaGVkdWxlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc1Jvb20gPSBzY2hlZHVsZS5fZW1iZWRkZWQgPyBzY2hlZHVsZS5fZW1iZWRkZWQucm9vbXNbMF0uYWJicmV2aWF0aW9uIDogXCJHZWVuIGxva2FhbFwiXG5cbiAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdzY2hlZHVsZS1jb3Vyc2UnKVxuICAgICAgICAgICAgICAgIHNjaGVkdWxlc0NvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgdGltZS50ZXh0Q29udGVudCA9IGAke3NjaGVkdWxlLnN0YXJ0RGF0ZVRpbWUudGltZX0gLSAke3NjaGVkdWxlLmVuZERhdGVUaW1lLnRpbWV9YFxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCh0aW1lKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICAgICAgICAgIG5hbWUudGV4dENvbnRlbnQgPSBzY2hlZHVsZS5fbGlua3MuY291cnNlc1swXS50aXRsZVxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChuYW1lKVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICAgICAgICAgIHJvb20udGV4dENvbnRlbnQgPSBjbGFzc1Jvb21cbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQocm9vbSlcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRlYWNoZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgICAgICAgICB0ZWFjaGVyLnRleHRDb250ZW50ID0gc2NoZWR1bGUuX2xpbmtzLmxlY3R1cmVyc1swXS50aXRsZVxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCh0ZWFjaGVyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIG5hdmlnYXRlKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAncHJldmlvdXMnID8gdGhpcy5pbmRleC0tIDogdGhpcy5pbmRleCsrXG5cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPT09IDAgPyB0aGlzLmFycm93UHJldmlvdXMuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKSA6IHRoaXMuYXJyb3dQcmV2aW91cy5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpXG4gICAgICAgICAgICB0aGlzLmluZGV4ID09PSA0ID8gdGhpcy5hcnJvd05leHQuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKSA6IHRoaXMuYXJyb3dOZXh0LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZSh0aGlzLmRhdGFbdGhpcy5pbmRleF0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzY2hlZHVsZS13aWRnZXQnLCBzY2hlZHVsZSlcbn0iLCJleHBvcnQgeyBpbml0IGFzIFdDX3N0dWR5cHJvZ3Jlc3MgfVxuXG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJylcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbmgyIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcbiAgICBmb250LWZhbWlseTogXCJPcGVuU2Fucy1SZWd1bGFyXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG4gICAgZm9udC13ZWlnaHQ6IGxpZ2h0ZXI7XG4gICAgbGluZS1oZWlnaHQ6IDEuMTtcbn1cblxucCB7XG4gICAgbWFyZ2luOiAwO1xufVxuXG4jcmVjZW50LXJlc3VsdHMgZGl2IHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnIgYXV0bztcbiAgICBncmlkLXRlbXBsYXRlLXJvd3M6IDFmciBhdXRvO1xufVxuXG4jcmVjZW50LXJlc3VsdHMgZGl2Om5vdCg6bGFzdC1vZi10eXBlKSB7XG4gICAgbWFyZ2luLWJvdHRvbTogMTVweDtcbn1cblxuI3JlY2VudC1yZXN1bHRzIHNwYW4ge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIGdyaWQtY29sdW1uOiAxIC8gMjtcbiAgICBncmlkLXJvdzogMSAvIDM7XG4gICAgd2lkdGg6IDVweDtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbnNwYW4uc3VjY2VzcyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI1MTY3QTtcbn1cblxuc3Bhbi5mYWlsZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNEREREREQ7XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBwOm50aC1vZi10eXBlKDEpIHtcbiAgICBncmlkLWNvbHVtbjogMiAvIDM7XG4gICAgcGFkZGluZzogNHB4IDBweCAwcHggMTBweDtcbn1cblxuI3JlY2VudC1yZXN1bHRzIHA6bnRoLW9mLXR5cGUoMikge1xuICAgIGdyaWQtcm93OiAxIC8gMztcbiAgICBncmlkLWNvbHVtbjogMyAvIDQ7XG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xufVxuXG4jcmVjZW50LXJlc3VsdHMgcDpudGgtb2YtdHlwZSgzKSB7XG4gICAgcGFkZGluZzogMHB4IDBweCA0cHggMTBweDtcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgY29sb3I6ICM2NjY2NjY7XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBwOm50aC1vZi10eXBlKDEpLFxuI3JlY2VudC1yZXN1bHRzIHA6bnRoLW9mLXR5cGUoMikge1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLUJvbGRcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcblxufVxuXG4jcmVjZW50LXByb2dyZXNzIHtcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xufVxuXG4jcmVjZW50LXByb2dyZXNzIGRpdiB7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IGF1dG8gMWZyIGF1dG87XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgZGl2IHNwYW4ge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgd2lkdGg6IDVweDtcbn1cblxuI3JlY2VudC1wcm9ncmVzcyBwIHtcbiAgICBwYWRkaW5nOiA1cHggMHB4O1xufVxuXG4jcmVjZW50LXByb2dyZXNzIHA6Zmlyc3Qtb2YtdHlwZSB7XG4gICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xufVxuXG4jcmVjZW50LXByb2dyZXNzIC5jdXJyZW50LXllYXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNEREREREQ7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciBzcGFuIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjUxNjdBO1xufVxuXG4jcmVjZW50LXByb2dyZXNzIC5jdXJyZW50LXllYXIgcCB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtQm9sZFwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xufVxuXG4jcmVjZW50LXByb2dyZXNzIC5jdXJyZW50LXllYXIgcDpsYXN0LW9mLXR5cGUge1xuICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XG59XG5cbmEge1xuICAgIG1hcmdpbi10b3A6IDMwcHg7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuYTpob3ZlcixcbmE6Zm9jdXMge1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIG91dGxpbmU6IG5vbmU7XG59XG5cbmEgaW1nIHtcbiAgICBoZWlnaHQ6IDEycHg7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG59XG48L3N0eWxlPlxuXG48aDI+U3R1ZGllcmVzdWx0YXRlbiBlbiAtdm9vcnRnYW5nPC9oMj5cblxuPGRpdiBpZD1cInJlY2VudC1yZXN1bHRzXCI+PC9kaXY+XG48ZGl2IGlkPVwicmVjZW50LXByb2dyZXNzXCI+PC9kaXY+XG5cbjxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL3Npcy5odmEubmwvXCI+QWxsZSByZXN1bHRhdGVuIGluIFNJU1xuICAgIDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2E+XG5gXG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gICAgY2xhc3MgU3R1ZHlQcm9ncmVzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBTZXR1cFxuICAgICAgICAgICAgc3VwZXIoKVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSlcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKCkudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmVzdWx0cywgcHJvZ3Jlc3NdID0ganNvblxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRDb21wb25lbnQocmVzdWx0cylcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzQ29tcG9uZW50KHByb2dyZXNzKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzQ29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNyZWNlbnQtcmVzdWx0cycpXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQ29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNyZWNlbnQtcHJvZ3Jlc3MnKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3Jlc3NDb21wb25lbnQocmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmN1cnJlbnRZZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdjdXJyZW50LXllYXInKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gYFxuICAgICAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8cD5MZWVyamFhciAke3Jlc3VsdC5zdHVkeVllYXJ9PC9wPlxuICAgICAgICAgICAgICAgIDxwPiR7cmVzdWx0LnN0dWR5cG9pbnRzLmFjaGlldmVkfS8ke3Jlc3VsdC5zdHVkeXBvaW50cy5hdmFpbGFibGV9IHN0dWRpZXB1bnRlbjwvcD5gXG5cbiAgICAgICAgICAgICAgICAvLyBJbnNlcnRBZGphY2VudEh0bWxcbiAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBlbmdpbmUgdWl0em9la2VuIHZvb3IgV2ViY29tcG9uZW50c1xuXG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0NvbnRhaW5lci5hcHBlbmQoZGl2KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmVzdWx0Q29tcG9uZW50KHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhcmVudCBjb250YWluZXJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgICAgICAgICAgbGV0IGluZGljYXRvclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmdyYWRlID09PSAnbnVtYmVyJyAmJiByZXN1bHQuZ3JhZGUgPj0gNS41IHx8IHJlc3VsdC5ncmFkZSA9PT0gJ1YnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciA9IGA8c3BhbiBjbGFzcz1cInN1Y2Nlc3NcIj48L3NwYW4+YFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdC5ncmFkZSA9PT0gJ251bWJlcicgJiYgcmVzdWx0LmdyYWRlIDwgNS41IHx8IHJlc3VsdC5ncmFkZSA9PT0gJy0nIHx8IHJlc3VsdC5ncmFkZSA9PT0gJ0dSJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3IgPSBgPHNwYW4gY2xhc3M9XCJmYWlsZWRcIj48L3NwYW4+YFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gYFxuICAgICAgICAgICAgICAgICR7aW5kaWNhdG9yfVxuICAgICAgICAgICAgICAgIDxwPiR7cmVzdWx0Ll9saW5rcy5jb3Vyc2UudGl0bGV9PC9wPlxuICAgICAgICAgICAgICAgIDxwPiR7cmVzdWx0LmdyYWRlfTwvcD5cbiAgICAgICAgICAgICAgICA8cD4ke3Jlc3VsdC5mdWxsRGF0ZX08L3A+XG4gICAgICAgICAgICAgICAgYFxuXG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzQ29udGFpbmVyLmFwcGVuZChkaXYpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyc1xuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCgnL3N0dWR5cHJvZ3Jlc3MnLCBvcHRpb25zKS50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdHVkeS1wcm9ncmVzcycsIFN0dWR5UHJvZ3Jlc3MpXG59IiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vbW9kdWxlcy91dGlscy5tanMnXG5cbmV4cG9ydCB7IHRlbXBsYXRlIGFzIFdDX3VyZ2VudEFubm91bmNlbWVudCB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuICAgIGRpdiB7XG4gICAgICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDUwcHg7XG4gICAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogNTBweDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0VDRTdGQTtcbiAgICB9XG4gICAgZGl2LmhpZGUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IC05OTk5cHg7XG4gICAgfVxuICAgIHAge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgICAgICBqdXN0aWZ5LXNlbGY6IHN0YXJ0O1xuICAgIH1cbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQyNXB4KSB7XG4gICAgICAgIHAge1xuICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGltZyB7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDIwcHg7XG4gICAgICAgIGdyaWQtY29sdW1uOiAyIC8gMztcbiAgICAgICAganVzdGlmeS1zZWxmOiBlbmQ7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG48L3N0eWxlPlxuPGRpdiBjbGFzcz1cImhpZGVcIj5cbiAgICA8cD48L3A+XG4gICAgPGltZyBzcmM9XCIuL21lZGlhL2ljb25zL25vdGlmaWNhdGlvbi1leGl0LnN2Z1wiIGFsdD1cImhpZGUgbm90aWZpY2F0aW9uXCI+XG48L2Rpdj5gXG5cblxuXG5jbGFzcyB1cmdlbnRBbm5vdW5jZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSlcbiAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ3AnKS50ZXh0Q29udGVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtZXNzYWdlJylcbiAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgICAgIHRoaXMuc3RvcmUoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gWyd1aWQnXVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9IG5ld1ZhbHVlICYmIG5ld1ZhbHVlICE9IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVpZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd1aWQnKVxuICAgICAgICAgICAgaWYgKHV0aWxzLnN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkSGlzdG9yeSA9IHV0aWxzLmdldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JylcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3JlZEhpc3RvcnkuaW5jbHVkZXModWlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRlbnQoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdwJykudGV4dENvbnRlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWVzc2FnZScpXG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKVxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYWluJykuY2xhc3NMaXN0LmFkZCgnc2hvd3NOb3RpZmljYXRpb24nKVxuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5jbGFzc0xpc3QuYWRkKCdoaWRlJylcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbicpLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3dzTm90aWZpY2F0aW9uJylcbiAgICB9XG5cbiAgICBzdG9yZSgpIHtcbiAgICAgICAgaWYgKHV0aWxzLnN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRIaXN0b3J5ID0gdXRpbHMuZ2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknKVxuICAgICAgICAgICAgY29uc3QgcmVhZEhpc3RvcnkgPSBzdG9yZWRIaXN0b3J5ID8gc3RvcmVkSGlzdG9yeSA6IFtdXG5cbiAgICAgICAgICAgIHJlYWRIaXN0b3J5LnB1c2godGhpcy5nZXRBdHRyaWJ1dGUoJ3VpZCcpKVxuICAgICAgICAgICAgdXRpbHMuc2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknLCByZWFkSGlzdG9yeSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgndXJnZW50LWFubm91bmNlbWVudCcsIHVyZ2VudEFubm91bmNlbWVudCkiXX0="}