{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/sortablejs/Sortable.js","src/js/index.js","src/js/modules/drag-and-drop.mjs","src/js/modules/notify.mjs","src/js/modules/search.mjs","src/js/modules/togglePreferences.mjs","src/js/modules/unreadAnnouncements.mjs","src/js/modules/utils.mjs","src/js/web-components/announcements.mjs","src/js/web-components/course-overview.mjs","src/js/web-components/schedule.mjs","src/js/web-components/study-progress.mjs","src/js/web-components/urgent-announcement.mjs"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7nHA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEA,IAAM,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAuB,MAAvB,EAA+B,EAA/B,CAAkC,WAAlC,EAAb,C,CAEA;;AACA,IAAI,IAAI,KAAK,WAAb,EAA0B;AACtB,EAAA,KAAK,CAAC,aAAN,CAAoB,KAAK,CAAC,cAAN,EAApB,EADsB,CAGtB;AACH;;AAED,IAAI,IAAI,KAAK,SAAb,EAAwB;AACpB;AACH;;AAED,IAAI,IAAI,KAAK,wBAAb,EAAuC;AACnC,MAAM,gBAAgB,GAAG,QAAQ,CAAC,cAAT,CAAwB,eAAxB,CAAzB;AACA,EAAA,gBAAgB,CAAC,MAAjB;AACA,EAAA,QAAQ,CAAC,aAAT,CAAuB,cAAvB,EAAuC,MAAvC,CAA8C,QAAQ,CAAC,aAAT,CAAuB,sBAAvB,CAA9C;AACA,6CAAuB,IAAvB;AACH,C,CAGD;;;AACA,IAAI,SAAS,CAAC,MAAd,EAAsB;AAClB;AACA,MAAM,MAAM,GAAG,EAAE,EAAjB,CAFkB,CAIlB;;AACA,EAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EA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","file":"index.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**!\n * Sortable 1.10.2\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Sortable = factory());\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var version = \"1.10.2\";\n\n  function userAgent(pattern) {\n    if (typeof window !== 'undefined' && window.navigator) {\n      return !!\n      /*@__PURE__*/\n      navigator.userAgent.match(pattern);\n    }\n  }\n\n  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\n  var Edge = userAgent(/Edge/i);\n  var FireFox = userAgent(/firefox/i);\n  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\n  var IOS = userAgent(/iP(ad|od|hone)/i);\n  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\n  var captureMode = {\n    capture: false,\n    passive: false\n  };\n\n  function on(el, event, fn) {\n    el.addEventListener(event, fn, !IE11OrLess && captureMode);\n  }\n\n  function off(el, event, fn) {\n    el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n  }\n\n  function matches(\n  /**HTMLElement*/\n  el,\n  /**String*/\n  selector) {\n    if (!selector) return;\n    selector[0] === '>' && (selector = selector.substring(1));\n\n    if (el) {\n      try {\n        if (el.matches) {\n          return el.matches(selector);\n        } else if (el.msMatchesSelector) {\n          return el.msMatchesSelector(selector);\n        } else if (el.webkitMatchesSelector) {\n          return el.webkitMatchesSelector(selector);\n        }\n      } catch (_) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  function getParentOrHost(el) {\n    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n  }\n\n  function closest(\n  /**HTMLElement*/\n  el,\n  /**String*/\n  selector,\n  /**HTMLElement*/\n  ctx, includeCTX) {\n    if (el) {\n      ctx = ctx || document;\n\n      do {\n        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n          return el;\n        }\n\n        if (el === ctx) break;\n        /* jshint boss:true */\n      } while (el = getParentOrHost(el));\n    }\n\n    return null;\n  }\n\n  var R_SPACE = /\\s+/g;\n\n  function toggleClass(el, name, state) {\n    if (el && name) {\n      if (el.classList) {\n        el.classList[state ? 'add' : 'remove'](name);\n      } else {\n        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n      }\n    }\n  }\n\n  function css(el, prop, val) {\n    var style = el && el.style;\n\n    if (style) {\n      if (val === void 0) {\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n          val = document.defaultView.getComputedStyle(el, '');\n        } else if (el.currentStyle) {\n          val = el.currentStyle;\n        }\n\n        return prop === void 0 ? val : val[prop];\n      } else {\n        if (!(prop in style) && prop.indexOf('webkit') === -1) {\n          prop = '-webkit-' + prop;\n        }\n\n        style[prop] = val + (typeof val === 'string' ? '' : 'px');\n      }\n    }\n  }\n\n  function matrix(el, selfOnly) {\n    var appliedTransforms = '';\n\n    if (typeof el === 'string') {\n      appliedTransforms = el;\n    } else {\n      do {\n        var transform = css(el, 'transform');\n\n        if (transform && transform !== 'none') {\n          appliedTransforms = transform + ' ' + appliedTransforms;\n        }\n        /* jshint boss:true */\n\n      } while (!selfOnly && (el = el.parentNode));\n    }\n\n    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n    /*jshint -W056 */\n\n    return matrixFn && new matrixFn(appliedTransforms);\n  }\n\n  function find(ctx, tagName, iterator) {\n    if (ctx) {\n      var list = ctx.getElementsByTagName(tagName),\n          i = 0,\n          n = list.length;\n\n      if (iterator) {\n        for (; i < n; i++) {\n          iterator(list[i], i);\n        }\n      }\n\n      return list;\n    }\n\n    return [];\n  }\n\n  function getWindowScrollingElement() {\n    var scrollingElement = document.scrollingElement;\n\n    if (scrollingElement) {\n      return scrollingElement;\n    } else {\n      return document.documentElement;\n    }\n  }\n  /**\r\n   * Returns the \"bounding client rect\" of given element\r\n   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\r\n   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\r\n   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\r\n   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\r\n   * @param  {[HTMLElement]} container              The parent the element will be placed in\r\n   * @return {Object}                               The boundingClientRect of el, with specified adjustments\r\n   */\n\n\n  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n    if (!el.getBoundingClientRect && el !== window) return;\n    var elRect, top, left, bottom, right, height, width;\n\n    if (el !== window && el !== getWindowScrollingElement()) {\n      elRect = el.getBoundingClientRect();\n      top = elRect.top;\n      left = elRect.left;\n      bottom = elRect.bottom;\n      right = elRect.right;\n      height = elRect.height;\n      width = elRect.width;\n    } else {\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      height = window.innerHeight;\n      width = window.innerWidth;\n    }\n\n    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n      // Adjust for translate()\n      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n      // Not needed on <= IE11\n\n      if (!IE11OrLess) {\n        do {\n          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n            top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n            left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n            bottom = top + elRect.height;\n            right = left + elRect.width;\n            break;\n          }\n          /* jshint boss:true */\n\n        } while (container = container.parentNode);\n      }\n    }\n\n    if (undoScale && el !== window) {\n      // Adjust for scale()\n      var elMatrix = matrix(container || el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d;\n\n      if (elMatrix) {\n        top /= scaleY;\n        left /= scaleX;\n        width /= scaleX;\n        height /= scaleY;\n        bottom = top + height;\n        right = left + width;\n      }\n    }\n\n    return {\n      top: top,\n      left: left,\n      bottom: bottom,\n      right: right,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Checks if a side of an element is scrolled past a side of its parents\r\n   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\r\n   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\r\n   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\r\n   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n   */\n\n\n  function isScrolledPast(el, elSide, parentSide) {\n    var parent = getParentAutoScrollElement(el, true),\n        elSideVal = getRect(el)[elSide];\n    /* jshint boss:true */\n\n    while (parent) {\n      var parentSideVal = getRect(parent)[parentSide],\n          visible = void 0;\n\n      if (parentSide === 'top' || parentSide === 'left') {\n        visible = elSideVal >= parentSideVal;\n      } else {\n        visible = elSideVal <= parentSideVal;\n      }\n\n      if (!visible) return parent;\n      if (parent === getWindowScrollingElement()) break;\n      parent = getParentAutoScrollElement(parent, false);\n    }\n\n    return false;\n  }\n  /**\r\n   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n   * and non-draggable elements\r\n   * @param  {HTMLElement} el       The parent element\r\n   * @param  {Number} childNum      The index of the child\r\n   * @param  {Object} options       Parent Sortable's options\r\n   * @return {HTMLElement}          The child at index childNum, or null if not found\r\n   */\n\n\n  function getChild(el, childNum, options) {\n    var currentChild = 0,\n        i = 0,\n        children = el.children;\n\n    while (i < children.length) {\n      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {\n        if (currentChild === childNum) {\n          return children[i];\n        }\n\n        currentChild++;\n      }\n\n      i++;\n    }\n\n    return null;\n  }\n  /**\r\n   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n   * @param  {HTMLElement} el       Parent element\r\n   * @param  {selector} selector    Any other elements that should be ignored\r\n   * @return {HTMLElement}          The last child, ignoring ghostEl\r\n   */\n\n\n  function lastChild(el, selector) {\n    var last = el.lastElementChild;\n\n    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n      last = last.previousElementSibling;\n    }\n\n    return last || null;\n  }\n  /**\r\n   * Returns the index of an element within its parent for a selected set of\r\n   * elements\r\n   * @param  {HTMLElement} el\r\n   * @param  {selector} selector\r\n   * @return {number}\r\n   */\n\n\n  function index(el, selector) {\n    var index = 0;\n\n    if (!el || !el.parentNode) {\n      return -1;\n    }\n    /* jshint boss:true */\n\n\n    while (el = el.previousElementSibling) {\n      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n        index++;\n      }\n    }\n\n    return index;\n  }\n  /**\r\n   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\r\n   * The value is returned in real pixels.\r\n   * @param  {HTMLElement} el\r\n   * @return {Array}             Offsets in the format of [left, top]\r\n   */\n\n\n  function getRelativeScrollOffset(el) {\n    var offsetLeft = 0,\n        offsetTop = 0,\n        winScroller = getWindowScrollingElement();\n\n    if (el) {\n      do {\n        var elMatrix = matrix(el),\n            scaleX = elMatrix.a,\n            scaleY = elMatrix.d;\n        offsetLeft += el.scrollLeft * scaleX;\n        offsetTop += el.scrollTop * scaleY;\n      } while (el !== winScroller && (el = el.parentNode));\n    }\n\n    return [offsetLeft, offsetTop];\n  }\n  /**\r\n   * Returns the index of the object within the given array\r\n   * @param  {Array} arr   Array that may or may not hold the object\r\n   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\r\n   * @return {Number}      The index of the object in the array, or -1\r\n   */\n\n\n  function indexOfObject(arr, obj) {\n    for (var i in arr) {\n      if (!arr.hasOwnProperty(i)) continue;\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n      }\n    }\n\n    return -1;\n  }\n\n  function getParentAutoScrollElement(el, includeSelf) {\n    // skip to window\n    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n    var elem = el;\n    var gotSelf = false;\n\n    do {\n      // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n        var elemCSS = css(elem);\n\n        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n          if (gotSelf || includeSelf) return elem;\n          gotSelf = true;\n        }\n      }\n      /* jshint boss:true */\n\n    } while (elem = elem.parentNode);\n\n    return getWindowScrollingElement();\n  }\n\n  function extend(dst, src) {\n    if (dst && src) {\n      for (var key in src) {\n        if (src.hasOwnProperty(key)) {\n          dst[key] = src[key];\n        }\n      }\n    }\n\n    return dst;\n  }\n\n  function isRectEqual(rect1, rect2) {\n    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n  }\n\n  var _throttleTimeout;\n\n  function throttle(callback, ms) {\n    return function () {\n      if (!_throttleTimeout) {\n        var args = arguments,\n            _this = this;\n\n        if (args.length === 1) {\n          callback.call(_this, args[0]);\n        } else {\n          callback.apply(_this, args);\n        }\n\n        _throttleTimeout = setTimeout(function () {\n          _throttleTimeout = void 0;\n        }, ms);\n      }\n    };\n  }\n\n  function cancelThrottle() {\n    clearTimeout(_throttleTimeout);\n    _throttleTimeout = void 0;\n  }\n\n  function scrollBy(el, x, y) {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n\n  function clone(el) {\n    var Polymer = window.Polymer;\n    var $ = window.jQuery || window.Zepto;\n\n    if (Polymer && Polymer.dom) {\n      return Polymer.dom(el).cloneNode(true);\n    } else if ($) {\n      return $(el).clone(true)[0];\n    } else {\n      return el.cloneNode(true);\n    }\n  }\n\n  function setRect(el, rect) {\n    css(el, 'position', 'absolute');\n    css(el, 'top', rect.top);\n    css(el, 'left', rect.left);\n    css(el, 'width', rect.width);\n    css(el, 'height', rect.height);\n  }\n\n  function unsetRect(el) {\n    css(el, 'position', '');\n    css(el, 'top', '');\n    css(el, 'left', '');\n    css(el, 'width', '');\n    css(el, 'height', '');\n  }\n\n  var expando = 'Sortable' + new Date().getTime();\n\n  function AnimationStateManager() {\n    var animationStates = [],\n        animationCallbackId;\n    return {\n      captureAnimationState: function captureAnimationState() {\n        animationStates = [];\n        if (!this.options.animation) return;\n        var children = [].slice.call(this.el.children);\n        children.forEach(function (child) {\n          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n          animationStates.push({\n            target: child,\n            rect: getRect(child)\n          });\n\n          var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n          if (child.thisAnimationDuration) {\n            var childMatrix = matrix(child, true);\n\n            if (childMatrix) {\n              fromRect.top -= childMatrix.f;\n              fromRect.left -= childMatrix.e;\n            }\n          }\n\n          child.fromRect = fromRect;\n        });\n      },\n      addAnimationState: function addAnimationState(state) {\n        animationStates.push(state);\n      },\n      removeAnimationState: function removeAnimationState(target) {\n        animationStates.splice(indexOfObject(animationStates, {\n          target: target\n        }), 1);\n      },\n      animateAll: function animateAll(callback) {\n        var _this = this;\n\n        if (!this.options.animation) {\n          clearTimeout(animationCallbackId);\n          if (typeof callback === 'function') callback();\n          return;\n        }\n\n        var animating = false,\n            animationTime = 0;\n        animationStates.forEach(function (state) {\n          var time = 0,\n              target = state.target,\n              fromRect = target.fromRect,\n              toRect = getRect(target),\n              prevFromRect = target.prevFromRect,\n              prevToRect = target.prevToRect,\n              animatingRect = state.rect,\n              targetMatrix = matrix(target, true);\n\n          if (targetMatrix) {\n            // Compensate for current animation\n            toRect.top -= targetMatrix.f;\n            toRect.left -= targetMatrix.e;\n          }\n\n          target.toRect = toRect;\n\n          if (target.thisAnimationDuration) {\n            // Could also check if animatingRect is between fromRect and toRect\n            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n              // If returning to same place as started from animation and on same axis\n              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n            }\n          } // if fromRect != toRect: animate\n\n\n          if (!isRectEqual(toRect, fromRect)) {\n            target.prevFromRect = fromRect;\n            target.prevToRect = toRect;\n\n            if (!time) {\n              time = _this.options.animation;\n            }\n\n            _this.animate(target, animatingRect, toRect, time);\n          }\n\n          if (time) {\n            animating = true;\n            animationTime = Math.max(animationTime, time);\n            clearTimeout(target.animationResetTimer);\n            target.animationResetTimer = setTimeout(function () {\n              target.animationTime = 0;\n              target.prevFromRect = null;\n              target.fromRect = null;\n              target.prevToRect = null;\n              target.thisAnimationDuration = null;\n            }, time);\n            target.thisAnimationDuration = time;\n          }\n        });\n        clearTimeout(animationCallbackId);\n\n        if (!animating) {\n          if (typeof callback === 'function') callback();\n        } else {\n          animationCallbackId = setTimeout(function () {\n            if (typeof callback === 'function') callback();\n          }, animationTime);\n        }\n\n        animationStates = [];\n      },\n      animate: function animate(target, currentRect, toRect, duration) {\n        if (duration) {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          var elMatrix = matrix(this.el),\n              scaleX = elMatrix && elMatrix.a,\n              scaleY = elMatrix && elMatrix.d,\n              translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n              translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n          target.animatingX = !!translateX;\n          target.animatingY = !!translateY;\n          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n          repaint(target); // repaint\n\n          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n          css(target, 'transform', 'translate3d(0,0,0)');\n          typeof target.animated === 'number' && clearTimeout(target.animated);\n          target.animated = setTimeout(function () {\n            css(target, 'transition', '');\n            css(target, 'transform', '');\n            target.animated = false;\n            target.animatingX = false;\n            target.animatingY = false;\n          }, duration);\n        }\n      }\n    };\n  }\n\n  function repaint(target) {\n    return target.offsetWidth;\n  }\n\n  function calculateRealTime(animatingRect, fromRect, toRect, options) {\n    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n  }\n\n  var plugins = [];\n  var defaults = {\n    initializeByDefault: true\n  };\n  var PluginManager = {\n    mount: function mount(plugin) {\n      // Set default static properties\n      for (var option in defaults) {\n        if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n          plugin[option] = defaults[option];\n        }\n      }\n\n      plugins.push(plugin);\n    },\n    pluginEvent: function pluginEvent(eventName, sortable, evt) {\n      var _this = this;\n\n      this.eventCanceled = false;\n\n      evt.cancel = function () {\n        _this.eventCanceled = true;\n      };\n\n      var eventNameGlobal = eventName + 'Global';\n      plugins.forEach(function (plugin) {\n        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n        if (sortable[plugin.pluginName][eventNameGlobal]) {\n          sortable[plugin.pluginName][eventNameGlobal](_objectSpread({\n            sortable: sortable\n          }, evt));\n        } // Only fire plugin event if plugin is enabled in this sortable,\n        // and plugin has event defined\n\n\n        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n          sortable[plugin.pluginName][eventName](_objectSpread({\n            sortable: sortable\n          }, evt));\n        }\n      });\n    },\n    initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n      plugins.forEach(function (plugin) {\n        var pluginName = plugin.pluginName;\n        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n        var initialized = new plugin(sortable, el, sortable.options);\n        initialized.sortable = sortable;\n        initialized.options = sortable.options;\n        sortable[pluginName] = initialized; // Add default options from plugin\n\n        _extends(defaults, initialized.defaults);\n      });\n\n      for (var option in sortable.options) {\n        if (!sortable.options.hasOwnProperty(option)) continue;\n        var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n        if (typeof modified !== 'undefined') {\n          sortable.options[option] = modified;\n        }\n      }\n    },\n    getEventProperties: function getEventProperties(name, sortable) {\n      var eventProperties = {};\n      plugins.forEach(function (plugin) {\n        if (typeof plugin.eventProperties !== 'function') return;\n\n        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n      });\n      return eventProperties;\n    },\n    modifyOption: function modifyOption(sortable, name, value) {\n      var modifiedValue;\n      plugins.forEach(function (plugin) {\n        // Plugin must exist on the Sortable\n        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n        }\n      });\n      return modifiedValue;\n    }\n  };\n\n  function dispatchEvent(_ref) {\n    var sortable = _ref.sortable,\n        rootEl = _ref.rootEl,\n        name = _ref.name,\n        targetEl = _ref.targetEl,\n        cloneEl = _ref.cloneEl,\n        toEl = _ref.toEl,\n        fromEl = _ref.fromEl,\n        oldIndex = _ref.oldIndex,\n        newIndex = _ref.newIndex,\n        oldDraggableIndex = _ref.oldDraggableIndex,\n        newDraggableIndex = _ref.newDraggableIndex,\n        originalEvent = _ref.originalEvent,\n        putSortable = _ref.putSortable,\n        extraEventProperties = _ref.extraEventProperties;\n    sortable = sortable || rootEl && rootEl[expando];\n    if (!sortable) return;\n    var evt,\n        options = sortable.options,\n        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\n      evt = new CustomEvent(name, {\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    evt.to = toEl || rootEl;\n    evt.from = fromEl || rootEl;\n    evt.item = targetEl || rootEl;\n    evt.clone = cloneEl;\n    evt.oldIndex = oldIndex;\n    evt.newIndex = newIndex;\n    evt.oldDraggableIndex = oldDraggableIndex;\n    evt.newDraggableIndex = newDraggableIndex;\n    evt.originalEvent = originalEvent;\n    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n    var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));\n\n    for (var option in allEventProperties) {\n      evt[option] = allEventProperties[option];\n    }\n\n    if (rootEl) {\n      rootEl.dispatchEvent(evt);\n    }\n\n    if (options[onName]) {\n      options[onName].call(sortable, evt);\n    }\n  }\n\n  var pluginEvent = function pluginEvent(eventName, sortable) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        originalEvent = _ref.evt,\n        data = _objectWithoutProperties(_ref, [\"evt\"]);\n\n    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({\n      dragEl: dragEl,\n      parentEl: parentEl,\n      ghostEl: ghostEl,\n      rootEl: rootEl,\n      nextEl: nextEl,\n      lastDownEl: lastDownEl,\n      cloneEl: cloneEl,\n      cloneHidden: cloneHidden,\n      dragStarted: moved,\n      putSortable: putSortable,\n      activeSortable: Sortable.active,\n      originalEvent: originalEvent,\n      oldIndex: oldIndex,\n      oldDraggableIndex: oldDraggableIndex,\n      newIndex: newIndex,\n      newDraggableIndex: newDraggableIndex,\n      hideGhostForTarget: _hideGhostForTarget,\n      unhideGhostForTarget: _unhideGhostForTarget,\n      cloneNowHidden: function cloneNowHidden() {\n        cloneHidden = true;\n      },\n      cloneNowShown: function cloneNowShown() {\n        cloneHidden = false;\n      },\n      dispatchSortableEvent: function dispatchSortableEvent(name) {\n        _dispatchEvent({\n          sortable: sortable,\n          name: name,\n          originalEvent: originalEvent\n        });\n      }\n    }, data));\n  };\n\n  function _dispatchEvent(info) {\n    dispatchEvent(_objectSpread({\n      putSortable: putSortable,\n      cloneEl: cloneEl,\n      targetEl: dragEl,\n      rootEl: rootEl,\n      oldIndex: oldIndex,\n      oldDraggableIndex: oldDraggableIndex,\n      newIndex: newIndex,\n      newDraggableIndex: newDraggableIndex\n    }, info));\n  }\n\n  var dragEl,\n      parentEl,\n      ghostEl,\n      rootEl,\n      nextEl,\n      lastDownEl,\n      cloneEl,\n      cloneHidden,\n      oldIndex,\n      newIndex,\n      oldDraggableIndex,\n      newDraggableIndex,\n      activeGroup,\n      putSortable,\n      awaitingDragStarted = false,\n      ignoreNextClick = false,\n      sortables = [],\n      tapEvt,\n      touchEvt,\n      lastDx,\n      lastDy,\n      tapDistanceLeft,\n      tapDistanceTop,\n      moved,\n      lastTarget,\n      lastDirection,\n      pastFirstInvertThresh = false,\n      isCircumstantialInvert = false,\n      targetMoveDistance,\n      // For positioning ghost absolutely\n  ghostRelativeParent,\n      ghostRelativeParentInitialScroll = [],\n      // (left, top)\n  _silent = false,\n      savedInputChecked = [];\n  /** @const */\n\n  var documentExists = typeof document !== 'undefined',\n      PositionGhostAbsolutely = IOS,\n      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n      // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n      supportCssPointerEvents = function () {\n    if (!documentExists) return; // false when <= IE11\n\n    if (IE11OrLess) {\n      return false;\n    }\n\n    var el = document.createElement('x');\n    el.style.cssText = 'pointer-events:auto';\n    return el.style.pointerEvents === 'auto';\n  }(),\n      _detectDirection = function _detectDirection(el, options) {\n    var elCSS = css(el),\n        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n        child1 = getChild(el, 0, options),\n        child2 = getChild(el, 1, options),\n        firstChildCSS = child1 && css(child1),\n        secondChildCSS = child2 && css(child2),\n        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n    if (elCSS.display === 'flex') {\n      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n    }\n\n    if (elCSS.display === 'grid') {\n      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n    }\n\n    if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n      var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n    }\n\n    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n  },\n      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n        dragElOppLength = vertical ? dragRect.width : dragRect.height,\n        targetS1Opp = vertical ? targetRect.left : targetRect.top,\n        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n        targetOppLength = vertical ? targetRect.width : targetRect.height;\n    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n  },\n\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n    var ret;\n    sortables.some(function (sortable) {\n      if (lastChild(sortable)) return;\n      var rect = getRect(sortable),\n          threshold = sortable[expando].options.emptyInsertThreshold,\n          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return ret = sortable;\n      }\n    });\n    return ret;\n  },\n      _prepareGroup = function _prepareGroup(options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === 'clone') {\n          return value;\n        } else if (typeof value === 'function') {\n          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n        } else {\n          var otherGroup = (pull ? to : from).options.group.name;\n          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n        }\n      };\n    }\n\n    var group = {};\n    var originalGroup = options.group;\n\n    if (!originalGroup || _typeof(originalGroup) != 'object') {\n      originalGroup = {\n        name: originalGroup\n      };\n    }\n\n    group.name = originalGroup.name;\n    group.checkPull = toFn(originalGroup.pull, true);\n    group.checkPut = toFn(originalGroup.put);\n    group.revertClone = originalGroup.revertClone;\n    options.group = group;\n  },\n      _hideGhostForTarget = function _hideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', 'none');\n    }\n  },\n      _unhideGhostForTarget = function _unhideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', '');\n    }\n  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\n  if (documentExists) {\n    document.addEventListener('click', function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    }, true);\n  }\n\n  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n    if (dragEl) {\n      evt = evt.touches ? evt.touches[0] : evt;\n\n      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n      if (nearest) {\n        // Create imitation event\n        var event = {};\n\n        for (var i in evt) {\n          if (evt.hasOwnProperty(i)) {\n            event[i] = evt[i];\n          }\n        }\n\n        event.target = event.rootEl = nearest;\n        event.preventDefault = void 0;\n        event.stopPropagation = void 0;\n\n        nearest[expando]._onDragOver(event);\n      }\n    }\n  };\n\n  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n    if (dragEl) {\n      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n    }\n  };\n  /**\n   * @class  Sortable\n   * @param  {HTMLElement}  el\n   * @param  {Object}       [options]\n   */\n\n\n  function Sortable(el, options) {\n    if (!(el && el.nodeType && el.nodeType === 1)) {\n      throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n    }\n\n    this.el = el; // root element\n\n    this.options = options = _extends({}, options); // Export instance\n\n    el[expando] = this;\n    var defaults = {\n      group: null,\n      sort: true,\n      disabled: false,\n      store: null,\n      handle: null,\n      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n      swapThreshold: 1,\n      // percentage; 0 <= x <= 1\n      invertSwap: false,\n      // invert always\n      invertedSwapThreshold: null,\n      // will be set to same as swapThreshold if default\n      removeCloneOnHide: true,\n      direction: function direction() {\n        return _detectDirection(el, this.options);\n      },\n      ghostClass: 'sortable-ghost',\n      chosenClass: 'sortable-chosen',\n      dragClass: 'sortable-drag',\n      ignore: 'a, img',\n      filter: null,\n      preventOnFilter: true,\n      animation: 0,\n      easing: null,\n      setData: function setData(dataTransfer, dragEl) {\n        dataTransfer.setData('Text', dragEl.textContent);\n      },\n      dropBubble: false,\n      dragoverBubble: false,\n      dataIdAttr: 'data-id',\n      delay: 0,\n      delayOnTouchOnly: false,\n      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n      forceFallback: false,\n      fallbackClass: 'sortable-fallback',\n      fallbackOnBody: false,\n      fallbackTolerance: 0,\n      fallbackOffset: {\n        x: 0,\n        y: 0\n      },\n      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,\n      emptyInsertThreshold: 5\n    };\n    PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n    for (var name in defaults) {\n      !(name in options) && (options[name] = defaults[name]);\n    }\n\n    _prepareGroup(options); // Bind all private methods\n\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    } // Setup drag mode\n\n\n    this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n    if (this.nativeDraggable) {\n      // Touch start threshold cannot be greater than the native dragstart threshold\n      this.options.touchStartThreshold = 1;\n    } // Bind events\n\n\n    if (options.supportPointer) {\n      on(el, 'pointerdown', this._onTapStart);\n    } else {\n      on(el, 'mousedown', this._onTapStart);\n      on(el, 'touchstart', this._onTapStart);\n    }\n\n    if (this.nativeDraggable) {\n      on(el, 'dragover', this);\n      on(el, 'dragenter', this);\n    }\n\n    sortables.push(this.el); // Restore sorting\n\n    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n    _extends(this, AnimationStateManager());\n  }\n\n  Sortable.prototype =\n  /** @lends Sortable.prototype */\n  {\n    constructor: Sortable,\n    _isOutsideThisEl: function _isOutsideThisEl(target) {\n      if (!this.el.contains(target) && target !== this.el) {\n        lastTarget = null;\n      }\n    },\n    _getDirection: function _getDirection(evt, target) {\n      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n    },\n    _onTapStart: function _onTapStart(\n    /** Event|TouchEvent */\n    evt) {\n      if (!evt.cancelable) return;\n\n      var _this = this,\n          el = this.el,\n          options = this.options,\n          preventOnFilter = options.preventOnFilter,\n          type = evt.type,\n          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n          target = (touch || evt).target,\n          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n          filter = options.filter;\n\n      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n      if (dragEl) {\n        return;\n      }\n\n      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n        return; // only left button and enabled\n      } // cancel dnd if original target is content editable\n\n\n      if (originalTarget.isContentEditable) {\n        return;\n      }\n\n      target = closest(target, options.draggable, el, false);\n\n      if (target && target.animated) {\n        return;\n      }\n\n      if (lastDownEl === target) {\n        // Ignoring duplicate `down`\n        return;\n      } // Get the index of the dragged element within its parent\n\n\n      oldIndex = index(target);\n      oldDraggableIndex = index(target, options.draggable); // Check filter\n\n      if (typeof filter === 'function') {\n        if (filter.call(this, evt, target, this)) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: originalTarget,\n            name: 'filter',\n            targetEl: target,\n            toEl: el,\n            fromEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          preventOnFilter && evt.cancelable && evt.preventDefault();\n          return; // cancel dnd\n        }\n      } else if (filter) {\n        filter = filter.split(',').some(function (criteria) {\n          criteria = closest(originalTarget, criteria.trim(), el, false);\n\n          if (criteria) {\n            _dispatchEvent({\n              sortable: _this,\n              rootEl: criteria,\n              name: 'filter',\n              targetEl: target,\n              fromEl: el,\n              toEl: el\n            });\n\n            pluginEvent('filter', _this, {\n              evt: evt\n            });\n            return true;\n          }\n        });\n\n        if (filter) {\n          preventOnFilter && evt.cancelable && evt.preventDefault();\n          return; // cancel dnd\n        }\n      }\n\n      if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n        return;\n      } // Prepare `dragstart`\n\n\n      this._prepareDragStart(evt, touch, target);\n    },\n    _prepareDragStart: function _prepareDragStart(\n    /** Event */\n    evt,\n    /** Touch */\n    touch,\n    /** HTMLElement */\n    target) {\n      var _this = this,\n          el = _this.el,\n          options = _this.options,\n          ownerDocument = el.ownerDocument,\n          dragStartFn;\n\n      if (target && !dragEl && target.parentNode === el) {\n        var dragRect = getRect(target);\n        rootEl = el;\n        dragEl = target;\n        parentEl = dragEl.parentNode;\n        nextEl = dragEl.nextSibling;\n        lastDownEl = target;\n        activeGroup = options.group;\n        Sortable.dragged = dragEl;\n        tapEvt = {\n          target: dragEl,\n          clientX: (touch || evt).clientX,\n          clientY: (touch || evt).clientY\n        };\n        tapDistanceLeft = tapEvt.clientX - dragRect.left;\n        tapDistanceTop = tapEvt.clientY - dragRect.top;\n        this._lastX = (touch || evt).clientX;\n        this._lastY = (touch || evt).clientY;\n        dragEl.style['will-change'] = 'all';\n\n        dragStartFn = function dragStartFn() {\n          pluginEvent('delayEnded', _this, {\n            evt: evt\n          });\n\n          if (Sortable.eventCanceled) {\n            _this._onDrop();\n\n            return;\n          } // Delayed drag has been triggered\n          // we can re-enable the events: touchmove/mousemove\n\n\n          _this._disableDelayedDragEvents();\n\n          if (!FireFox && _this.nativeDraggable) {\n            dragEl.draggable = true;\n          } // Bind the events: dragstart/dragend\n\n\n          _this._triggerDragStart(evt, touch); // Drag start event\n\n\n          _dispatchEvent({\n            sortable: _this,\n            name: 'choose',\n            originalEvent: evt\n          }); // Chosen item\n\n\n          toggleClass(dragEl, options.chosenClass, true);\n        }; // Disable \"draggable\"\n\n\n        options.ignore.split(',').forEach(function (criteria) {\n          find(dragEl, criteria.trim(), _disableDraggable);\n        });\n        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'mouseup', _this._onDrop);\n        on(ownerDocument, 'touchend', _this._onDrop);\n        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n        if (FireFox && this.nativeDraggable) {\n          this.options.touchStartThreshold = 4;\n          dragEl.draggable = true;\n        }\n\n        pluginEvent('delayStart', this, {\n          evt: evt\n        }); // Delay is impossible for native DnD in Edge or IE\n\n        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n          if (Sortable.eventCanceled) {\n            this._onDrop();\n\n            return;\n          } // If the user moves the pointer or let go the click or touch\n          // before the delay has been reached:\n          // disable the delayed drag\n\n\n          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n        } else {\n          dragStartFn();\n        }\n      }\n    },\n    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n    /** TouchEvent|PointerEvent **/\n    e) {\n      var touch = e.touches ? e.touches[0] : e;\n\n      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n        this._disableDelayedDrag();\n      }\n    },\n    _disableDelayedDrag: function _disableDelayedDrag() {\n      dragEl && _disableDraggable(dragEl);\n      clearTimeout(this._dragStartTimer);\n\n      this._disableDelayedDragEvents();\n    },\n    _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n      var ownerDocument = this.el.ownerDocument;\n      off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n      off(ownerDocument, 'touchend', this._disableDelayedDrag);\n      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n    },\n    _triggerDragStart: function _triggerDragStart(\n    /** Event */\n    evt,\n    /** Touch */\n    touch) {\n      touch = touch || evt.pointerType == 'touch' && evt;\n\n      if (!this.nativeDraggable || touch) {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._onTouchMove);\n        } else if (touch) {\n          on(document, 'touchmove', this._onTouchMove);\n        } else {\n          on(document, 'mousemove', this._onTouchMove);\n        }\n      } else {\n        on(dragEl, 'dragend', this);\n        on(rootEl, 'dragstart', this._onDragStart);\n      }\n\n      try {\n        if (document.selection) {\n          // Timeout neccessary for IE9\n          _nextTick(function () {\n            document.selection.empty();\n          });\n        } else {\n          window.getSelection().removeAllRanges();\n        }\n      } catch (err) {}\n    },\n    _dragStarted: function _dragStarted(fallback, evt) {\n\n      awaitingDragStarted = false;\n\n      if (rootEl && dragEl) {\n        pluginEvent('dragStarted', this, {\n          evt: evt\n        });\n\n        if (this.nativeDraggable) {\n          on(document, 'dragover', _checkOutsideTargetEl);\n        }\n\n        var options = this.options; // Apply effect\n\n        !fallback && toggleClass(dragEl, options.dragClass, false);\n        toggleClass(dragEl, options.ghostClass, true);\n        Sortable.active = this;\n        fallback && this._appendGhost(); // Drag start event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'start',\n          originalEvent: evt\n        });\n      } else {\n        this._nulling();\n      }\n    },\n    _emulateDragOver: function _emulateDragOver() {\n      if (touchEvt) {\n        this._lastX = touchEvt.clientX;\n        this._lastY = touchEvt.clientY;\n\n        _hideGhostForTarget();\n\n        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        var parent = target;\n\n        while (target && target.shadowRoot) {\n          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n          if (target === parent) break;\n          parent = target;\n        }\n\n        dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n        if (parent) {\n          do {\n            if (parent[expando]) {\n              var inserted = void 0;\n              inserted = parent[expando]._onDragOver({\n                clientX: touchEvt.clientX,\n                clientY: touchEvt.clientY,\n                target: target,\n                rootEl: parent\n              });\n\n              if (inserted && !this.options.dragoverBubble) {\n                break;\n              }\n            }\n\n            target = parent; // store last element\n          }\n          /* jshint boss:true */\n          while (parent = parent.parentNode);\n        }\n\n        _unhideGhostForTarget();\n      }\n    },\n    _onTouchMove: function _onTouchMove(\n    /**TouchEvent*/\n    evt) {\n      if (tapEvt) {\n        var options = this.options,\n            fallbackTolerance = options.fallbackTolerance,\n            fallbackOffset = options.fallbackOffset,\n            touch = evt.touches ? evt.touches[0] : evt,\n            ghostMatrix = ghostEl && matrix(ghostEl, true),\n            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n        if (!Sortable.active && !awaitingDragStarted) {\n          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n            return;\n          }\n\n          this._onDragStart(evt, true);\n        }\n\n        if (ghostEl) {\n          if (ghostMatrix) {\n            ghostMatrix.e += dx - (lastDx || 0);\n            ghostMatrix.f += dy - (lastDy || 0);\n          } else {\n            ghostMatrix = {\n              a: 1,\n              b: 0,\n              c: 0,\n              d: 1,\n              e: dx,\n              f: dy\n            };\n          }\n\n          var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n          css(ghostEl, 'webkitTransform', cssMatrix);\n          css(ghostEl, 'mozTransform', cssMatrix);\n          css(ghostEl, 'msTransform', cssMatrix);\n          css(ghostEl, 'transform', cssMatrix);\n          lastDx = dx;\n          lastDy = dy;\n          touchEvt = touch;\n        }\n\n        evt.cancelable && evt.preventDefault();\n      }\n    },\n    _appendGhost: function _appendGhost() {\n      // Bug if using scale(): https://stackoverflow.com/questions/2637058\n      // Not being adjusted for\n      if (!ghostEl) {\n        var container = this.options.fallbackOnBody ? document.body : rootEl,\n            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n            options = this.options; // Position absolutely\n\n        if (PositionGhostAbsolutely) {\n          // Get relatively positioned parent\n          ghostRelativeParent = container;\n\n          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n            ghostRelativeParent = ghostRelativeParent.parentNode;\n          }\n\n          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n            rect.top += ghostRelativeParent.scrollTop;\n            rect.left += ghostRelativeParent.scrollLeft;\n          } else {\n            ghostRelativeParent = getWindowScrollingElement();\n          }\n\n          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n        }\n\n        ghostEl = dragEl.cloneNode(true);\n        toggleClass(ghostEl, options.ghostClass, false);\n        toggleClass(ghostEl, options.fallbackClass, true);\n        toggleClass(ghostEl, options.dragClass, true);\n        css(ghostEl, 'transition', '');\n        css(ghostEl, 'transform', '');\n        css(ghostEl, 'box-sizing', 'border-box');\n        css(ghostEl, 'margin', 0);\n        css(ghostEl, 'top', rect.top);\n        css(ghostEl, 'left', rect.left);\n        css(ghostEl, 'width', rect.width);\n        css(ghostEl, 'height', rect.height);\n        css(ghostEl, 'opacity', '0.8');\n        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n        css(ghostEl, 'zIndex', '100000');\n        css(ghostEl, 'pointerEvents', 'none');\n        Sortable.ghost = ghostEl;\n        container.appendChild(ghostEl); // Set transform-origin\n\n        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n      }\n    },\n    _onDragStart: function _onDragStart(\n    /**Event*/\n    evt,\n    /**boolean*/\n    fallback) {\n      var _this = this;\n\n      var dataTransfer = evt.dataTransfer;\n      var options = _this.options;\n      pluginEvent('dragStart', this, {\n        evt: evt\n      });\n\n      if (Sortable.eventCanceled) {\n        this._onDrop();\n\n        return;\n      }\n\n      pluginEvent('setupClone', this);\n\n      if (!Sortable.eventCanceled) {\n        cloneEl = clone(dragEl);\n        cloneEl.draggable = false;\n        cloneEl.style['will-change'] = '';\n\n        this._hideClone();\n\n        toggleClass(cloneEl, this.options.chosenClass, false);\n        Sortable.clone = cloneEl;\n      } // #1143: IFrame support workaround\n\n\n      _this.cloneId = _nextTick(function () {\n        pluginEvent('clone', _this);\n        if (Sortable.eventCanceled) return;\n\n        if (!_this.options.removeCloneOnHide) {\n          rootEl.insertBefore(cloneEl, dragEl);\n        }\n\n        _this._hideClone();\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'clone'\n        });\n      });\n      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n      if (fallback) {\n        ignoreNextClick = true;\n        _this._loopId = setInterval(_this._emulateDragOver, 50);\n      } else {\n        // Undo what was set in _prepareDragStart before drag started\n        off(document, 'mouseup', _this._onDrop);\n        off(document, 'touchend', _this._onDrop);\n        off(document, 'touchcancel', _this._onDrop);\n\n        if (dataTransfer) {\n          dataTransfer.effectAllowed = 'move';\n          options.setData && options.setData.call(_this, dataTransfer, dragEl);\n        }\n\n        on(document, 'drop', _this); // #1276 fix:\n\n        css(dragEl, 'transform', 'translateZ(0)');\n      }\n\n      awaitingDragStarted = true;\n      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n      on(document, 'selectstart', _this);\n      moved = true;\n\n      if (Safari) {\n        css(document.body, 'user-select', 'none');\n      }\n    },\n    // Returns true - if no further action is needed (either inserted or another condition)\n    _onDragOver: function _onDragOver(\n    /**Event*/\n    evt) {\n      var el = this.el,\n          target = evt.target,\n          dragRect,\n          targetRect,\n          revert,\n          options = this.options,\n          group = options.group,\n          activeSortable = Sortable.active,\n          isOwner = activeGroup === group,\n          canSort = options.sort,\n          fromSortable = putSortable || activeSortable,\n          vertical,\n          _this = this,\n          completedFired = false;\n\n      if (_silent) return;\n\n      function dragOverEvent(name, extra) {\n        pluginEvent(name, _this, _objectSpread({\n          evt: evt,\n          isOwner: isOwner,\n          axis: vertical ? 'vertical' : 'horizontal',\n          revert: revert,\n          dragRect: dragRect,\n          targetRect: targetRect,\n          canSort: canSort,\n          fromSortable: fromSortable,\n          target: target,\n          completed: completed,\n          onMove: function onMove(target, after) {\n            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n          },\n          changed: changed\n        }, extra));\n      } // Capture animation state\n\n\n      function capture() {\n        dragOverEvent('dragOverAnimationCapture');\n\n        _this.captureAnimationState();\n\n        if (_this !== fromSortable) {\n          fromSortable.captureAnimationState();\n        }\n      } // Return invocation when dragEl is inserted (or completed)\n\n\n      function completed(insertion) {\n        dragOverEvent('dragOverCompleted', {\n          insertion: insertion\n        });\n\n        if (insertion) {\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n          if (isOwner) {\n            activeSortable._hideClone();\n          } else {\n            activeSortable._showClone(_this);\n          }\n\n          if (_this !== fromSortable) {\n            // Set ghost class to new sortable's ghost class\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n            toggleClass(dragEl, options.ghostClass, true);\n          }\n\n          if (putSortable !== _this && _this !== Sortable.active) {\n            putSortable = _this;\n          } else if (_this === Sortable.active && putSortable) {\n            putSortable = null;\n          } // Animation\n\n\n          if (fromSortable === _this) {\n            _this._ignoreWhileAnimating = target;\n          }\n\n          _this.animateAll(function () {\n            dragOverEvent('dragOverAnimationComplete');\n            _this._ignoreWhileAnimating = null;\n          });\n\n          if (_this !== fromSortable) {\n            fromSortable.animateAll();\n            fromSortable._ignoreWhileAnimating = null;\n          }\n        } // Null lastTarget if it is not inside a previously swapped element\n\n\n        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n          lastTarget = null;\n        } // no bubbling and not fallback\n\n\n        if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n          !insertion && nearestEmptyInsertDetectEvent(evt);\n        }\n\n        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n        return completedFired = true;\n      } // Call when dragEl has been inserted\n\n\n      function changed() {\n        newIndex = index(dragEl);\n        newDraggableIndex = index(dragEl, options.draggable);\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'change',\n          toEl: el,\n          newIndex: newIndex,\n          newDraggableIndex: newDraggableIndex,\n          originalEvent: evt\n        });\n      }\n\n      if (evt.preventDefault !== void 0) {\n        evt.cancelable && evt.preventDefault();\n      }\n\n      target = closest(target, options.draggable, el, true);\n      dragOverEvent('dragOver');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n        return completed(false);\n      }\n\n      ignoreNextClick = false;\n\n      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n        vertical = this._getDirection(evt, target) === 'vertical';\n        dragRect = getRect(dragEl);\n        dragOverEvent('dragOverValid');\n        if (Sortable.eventCanceled) return completedFired;\n\n        if (revert) {\n          parentEl = rootEl; // actualization\n\n          capture();\n\n          this._hideClone();\n\n          dragOverEvent('revert');\n\n          if (!Sortable.eventCanceled) {\n            if (nextEl) {\n              rootEl.insertBefore(dragEl, nextEl);\n            } else {\n              rootEl.appendChild(dragEl);\n            }\n          }\n\n          return completed(true);\n        }\n\n        var elLastChild = lastChild(el, options.draggable);\n\n        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n          // If already at end of list: Do not insert\n          if (elLastChild === dragEl) {\n            return completed(false);\n          } // assign target only if condition is true\n\n\n          if (elLastChild && el === evt.target) {\n            target = elLastChild;\n          }\n\n          if (target) {\n            targetRect = getRect(target);\n          }\n\n          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n            capture();\n            el.appendChild(dragEl);\n            parentEl = el; // actualization\n\n            changed();\n            return completed(true);\n          }\n        } else if (target.parentNode === el) {\n          targetRect = getRect(target);\n          var direction = 0,\n              targetBeforeFirstSwap,\n              differentLevel = dragEl.parentNode !== el,\n              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n              side1 = vertical ? 'top' : 'left',\n              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n          if (lastTarget !== target) {\n            targetBeforeFirstSwap = targetRect[side1];\n            pastFirstInvertThresh = false;\n            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n          }\n\n          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n          var sibling;\n\n          if (direction !== 0) {\n            // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n            var dragIndex = index(dragEl);\n\n            do {\n              dragIndex -= direction;\n              sibling = parentEl.children[dragIndex];\n            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n          } // If dragEl is already beside target: Do not insert\n\n\n          if (direction === 0 || sibling === target) {\n            return completed(false);\n          }\n\n          lastTarget = target;\n          lastDirection = direction;\n          var nextSibling = target.nextElementSibling,\n              after = false;\n          after = direction === 1;\n\n          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n          if (moveVector !== false) {\n            if (moveVector === 1 || moveVector === -1) {\n              after = moveVector === 1;\n            }\n\n            _silent = true;\n            setTimeout(_unsilent, 30);\n            capture();\n\n            if (after && !nextSibling) {\n              el.appendChild(dragEl);\n            } else {\n              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n            } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n            if (scrolledPastTop) {\n              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n            }\n\n            parentEl = dragEl.parentNode; // actualization\n            // must be done before animation\n\n            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n            }\n\n            changed();\n            return completed(true);\n          }\n        }\n\n        if (el.contains(dragEl)) {\n          return completed(false);\n        }\n      }\n\n      return false;\n    },\n    _ignoreWhileAnimating: null,\n    _offMoveEvents: function _offMoveEvents() {\n      off(document, 'mousemove', this._onTouchMove);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'pointermove', this._onTouchMove);\n      off(document, 'dragover', nearestEmptyInsertDetectEvent);\n      off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n      off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n    },\n    _offUpEvents: function _offUpEvents() {\n      var ownerDocument = this.el.ownerDocument;\n      off(ownerDocument, 'mouseup', this._onDrop);\n      off(ownerDocument, 'touchend', this._onDrop);\n      off(ownerDocument, 'pointerup', this._onDrop);\n      off(ownerDocument, 'touchcancel', this._onDrop);\n      off(document, 'selectstart', this);\n    },\n    _onDrop: function _onDrop(\n    /**Event*/\n    evt) {\n      var el = this.el,\n          options = this.options; // Get the index of the dragged element within its parent\n\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      pluginEvent('drop', this, {\n        evt: evt\n      });\n      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      if (Sortable.eventCanceled) {\n        this._nulling();\n\n        return;\n      }\n\n      awaitingDragStarted = false;\n      isCircumstantialInvert = false;\n      pastFirstInvertThresh = false;\n      clearInterval(this._loopId);\n      clearTimeout(this._dragStartTimer);\n\n      _cancelNextTick(this.cloneId);\n\n      _cancelNextTick(this._dragStartId); // Unbind events\n\n\n      if (this.nativeDraggable) {\n        off(document, 'drop', this);\n        off(el, 'dragstart', this._onDragStart);\n      }\n\n      this._offMoveEvents();\n\n      this._offUpEvents();\n\n      if (Safari) {\n        css(document.body, 'user-select', '');\n      }\n\n      css(dragEl, 'transform', '');\n\n      if (evt) {\n        if (moved) {\n          evt.cancelable && evt.preventDefault();\n          !options.dropBubble && evt.stopPropagation();\n        }\n\n        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n          // Remove clone(s)\n          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n        }\n\n        if (dragEl) {\n          if (this.nativeDraggable) {\n            off(dragEl, 'dragend', this);\n          }\n\n          _disableDraggable(dragEl);\n\n          dragEl.style['will-change'] = ''; // Remove classes\n          // ghostClass is added in dragStarted\n\n          if (moved && !awaitingDragStarted) {\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n          }\n\n          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'unchoose',\n            toEl: parentEl,\n            newIndex: null,\n            newDraggableIndex: null,\n            originalEvent: evt\n          });\n\n          if (rootEl !== parentEl) {\n            if (newIndex >= 0) {\n              // Add event\n              _dispatchEvent({\n                rootEl: parentEl,\n                name: 'add',\n                toEl: parentEl,\n                fromEl: rootEl,\n                originalEvent: evt\n              }); // Remove event\n\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'remove',\n                toEl: parentEl,\n                originalEvent: evt\n              }); // drag from one list and drop into another\n\n\n              _dispatchEvent({\n                rootEl: parentEl,\n                name: 'sort',\n                toEl: parentEl,\n                fromEl: rootEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n\n            putSortable && putSortable.save();\n          } else {\n            if (newIndex !== oldIndex) {\n              if (newIndex >= 0) {\n                // drag & drop within the same list\n                _dispatchEvent({\n                  sortable: this,\n                  name: 'update',\n                  toEl: parentEl,\n                  originalEvent: evt\n                });\n\n                _dispatchEvent({\n                  sortable: this,\n                  name: 'sort',\n                  toEl: parentEl,\n                  originalEvent: evt\n                });\n              }\n            }\n          }\n\n          if (Sortable.active) {\n            /* jshint eqnull:true */\n            if (newIndex == null || newIndex === -1) {\n              newIndex = oldIndex;\n              newDraggableIndex = oldDraggableIndex;\n            }\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'end',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // Save sorting\n\n\n            this.save();\n          }\n        }\n      }\n\n      this._nulling();\n    },\n    _nulling: function _nulling() {\n      pluginEvent('nulling', this);\n      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n      savedInputChecked.forEach(function (el) {\n        el.checked = true;\n      });\n      savedInputChecked.length = lastDx = lastDy = 0;\n    },\n    handleEvent: function handleEvent(\n    /**Event*/\n    evt) {\n      switch (evt.type) {\n        case 'drop':\n        case 'dragend':\n          this._onDrop(evt);\n\n          break;\n\n        case 'dragenter':\n        case 'dragover':\n          if (dragEl) {\n            this._onDragOver(evt);\n\n            _globalDragOver(evt);\n          }\n\n          break;\n\n        case 'selectstart':\n          evt.preventDefault();\n          break;\n      }\n    },\n\n    /**\n     * Serializes the item into an array of string.\n     * @returns {String[]}\n     */\n    toArray: function toArray() {\n      var order = [],\n          el,\n          children = this.el.children,\n          i = 0,\n          n = children.length,\n          options = this.options;\n\n      for (; i < n; i++) {\n        el = children[i];\n\n        if (closest(el, options.draggable, this.el, false)) {\n          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n        }\n      }\n\n      return order;\n    },\n\n    /**\n     * Sorts the elements according to the array.\n     * @param  {String[]}  order  order of the items\n     */\n    sort: function sort(order) {\n      var items = {},\n          rootEl = this.el;\n      this.toArray().forEach(function (id, i) {\n        var el = rootEl.children[i];\n\n        if (closest(el, this.options.draggable, rootEl, false)) {\n          items[id] = el;\n        }\n      }, this);\n      order.forEach(function (id) {\n        if (items[id]) {\n          rootEl.removeChild(items[id]);\n          rootEl.appendChild(items[id]);\n        }\n      });\n    },\n\n    /**\n     * Save the current sorting\n     */\n    save: function save() {\n      var store = this.options.store;\n      store && store.set && store.set(this);\n    },\n\n    /**\n     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n     * @param   {HTMLElement}  el\n     * @param   {String}       [selector]  default: `options.draggable`\n     * @returns {HTMLElement|null}\n     */\n    closest: function closest$1(el, selector) {\n      return closest(el, selector || this.options.draggable, this.el, false);\n    },\n\n    /**\n     * Set/get option\n     * @param   {string} name\n     * @param   {*}      [value]\n     * @returns {*}\n     */\n    option: function option(name, value) {\n      var options = this.options;\n\n      if (value === void 0) {\n        return options[name];\n      } else {\n        var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n        if (typeof modifiedValue !== 'undefined') {\n          options[name] = modifiedValue;\n        } else {\n          options[name] = value;\n        }\n\n        if (name === 'group') {\n          _prepareGroup(options);\n        }\n      }\n    },\n\n    /**\n     * Destroy\n     */\n    destroy: function destroy() {\n      pluginEvent('destroy', this);\n      var el = this.el;\n      el[expando] = null;\n      off(el, 'mousedown', this._onTapStart);\n      off(el, 'touchstart', this._onTapStart);\n      off(el, 'pointerdown', this._onTapStart);\n\n      if (this.nativeDraggable) {\n        off(el, 'dragover', this);\n        off(el, 'dragenter', this);\n      } // Remove draggable attributes\n\n\n      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n        el.removeAttribute('draggable');\n      });\n\n      this._onDrop();\n\n      this._disableDelayedDragEvents();\n\n      sortables.splice(sortables.indexOf(this.el), 1);\n      this.el = el = null;\n    },\n    _hideClone: function _hideClone() {\n      if (!cloneHidden) {\n        pluginEvent('hideClone', this);\n        if (Sortable.eventCanceled) return;\n        css(cloneEl, 'display', 'none');\n\n        if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n          cloneEl.parentNode.removeChild(cloneEl);\n        }\n\n        cloneHidden = true;\n      }\n    },\n    _showClone: function _showClone(putSortable) {\n      if (putSortable.lastPutMode !== 'clone') {\n        this._hideClone();\n\n        return;\n      }\n\n      if (cloneHidden) {\n        pluginEvent('showClone', this);\n        if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n        if (rootEl.contains(dragEl) && !this.options.group.revertClone) {\n          rootEl.insertBefore(cloneEl, dragEl);\n        } else if (nextEl) {\n          rootEl.insertBefore(cloneEl, nextEl);\n        } else {\n          rootEl.appendChild(cloneEl);\n        }\n\n        if (this.options.group.revertClone) {\n          this.animate(dragEl, cloneEl);\n        }\n\n        css(cloneEl, 'display', '');\n        cloneHidden = false;\n      }\n    }\n  };\n\n  function _globalDragOver(\n  /**Event*/\n  evt) {\n    if (evt.dataTransfer) {\n      evt.dataTransfer.dropEffect = 'move';\n    }\n\n    evt.cancelable && evt.preventDefault();\n  }\n\n  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n    var evt,\n        sortable = fromEl[expando],\n        onMoveFn = sortable.options.onMove,\n        retVal; // Support for new CustomEvent feature\n\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\n      evt = new CustomEvent('move', {\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      evt = document.createEvent('Event');\n      evt.initEvent('move', true, true);\n    }\n\n    evt.to = toEl;\n    evt.from = fromEl;\n    evt.dragged = dragEl;\n    evt.draggedRect = dragRect;\n    evt.related = targetEl || toEl;\n    evt.relatedRect = targetRect || getRect(toEl);\n    evt.willInsertAfter = willInsertAfter;\n    evt.originalEvent = originalEvent;\n    fromEl.dispatchEvent(evt);\n\n    if (onMoveFn) {\n      retVal = onMoveFn.call(sortable, evt, originalEvent);\n    }\n\n    return retVal;\n  }\n\n  function _disableDraggable(el) {\n    el.draggable = false;\n  }\n\n  function _unsilent() {\n    _silent = false;\n  }\n\n  function _ghostIsLast(evt, vertical, sortable) {\n    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n    var spacer = 10;\n    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n  }\n\n  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n        targetLength = vertical ? targetRect.height : targetRect.width,\n        targetS1 = vertical ? targetRect.top : targetRect.left,\n        targetS2 = vertical ? targetRect.bottom : targetRect.right,\n        invert = false;\n\n    if (!invertSwap) {\n      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n        // check if past first invert threshold on side opposite of lastDirection\n        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n          // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n          pastFirstInvertThresh = true;\n        }\n\n        if (!pastFirstInvertThresh) {\n          // dragEl shadow (target move distance shadow)\n          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n          : mouseOnAxis > targetS2 - targetMoveDistance) {\n            return -lastDirection;\n          }\n        } else {\n          invert = true;\n        }\n      } else {\n        // Regular\n        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n          return _getInsertDirection(target);\n        }\n      }\n    }\n\n    invert = invert || invertSwap;\n\n    if (invert) {\n      // Invert of regular\n      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * Gets the direction dragEl must be swapped relative to target in order to make it\n   * seem that dragEl has been \"inserted\" into that element's position\n   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n   * @return {Number}                   Direction dragEl must be swapped\n   */\n\n\n  function _getInsertDirection(target) {\n    if (index(dragEl) < index(target)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * Generate id\n   * @param   {HTMLElement} el\n   * @returns {String}\n   * @private\n   */\n\n\n  function _generateId(el) {\n    var str = el.tagName + el.className + el.src + el.href + el.textContent,\n        i = str.length,\n        sum = 0;\n\n    while (i--) {\n      sum += str.charCodeAt(i);\n    }\n\n    return sum.toString(36);\n  }\n\n  function _saveInputCheckedState(root) {\n    savedInputChecked.length = 0;\n    var inputs = root.getElementsByTagName('input');\n    var idx = inputs.length;\n\n    while (idx--) {\n      var el = inputs[idx];\n      el.checked && savedInputChecked.push(el);\n    }\n  }\n\n  function _nextTick(fn) {\n    return setTimeout(fn, 0);\n  }\n\n  function _cancelNextTick(id) {\n    return clearTimeout(id);\n  } // Fixed #973:\n\n\n  if (documentExists) {\n    on(document, 'touchmove', function (evt) {\n      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n        evt.preventDefault();\n      }\n    });\n  } // Export utils\n\n\n  Sortable.utils = {\n    on: on,\n    off: off,\n    css: css,\n    find: find,\n    is: function is(el, selector) {\n      return !!closest(el, selector, el, false);\n    },\n    extend: extend,\n    throttle: throttle,\n    closest: closest,\n    toggleClass: toggleClass,\n    clone: clone,\n    index: index,\n    nextTick: _nextTick,\n    cancelNextTick: _cancelNextTick,\n    detectDirection: _detectDirection,\n    getChild: getChild\n  };\n  /**\n   * Get the Sortable instance of an element\n   * @param  {HTMLElement} element The element\n   * @return {Sortable|undefined}         The instance of Sortable\n   */\n\n  Sortable.get = function (element) {\n    return element[expando];\n  };\n  /**\n   * Mount a plugin to Sortable\n   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n   */\n\n\n  Sortable.mount = function () {\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n\n    if (plugins[0].constructor === Array) plugins = plugins[0];\n    plugins.forEach(function (plugin) {\n      if (!plugin.prototype || !plugin.prototype.constructor) {\n        throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n      }\n\n      if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);\n      PluginManager.mount(plugin);\n    });\n  };\n  /**\n   * Create sortable instance\n   * @param {HTMLElement}  el\n   * @param {Object}      [options]\n   */\n\n\n  Sortable.create = function (el, options) {\n    return new Sortable(el, options);\n  }; // Export\n\n\n  Sortable.version = version;\n\n  var autoScrolls = [],\n      scrollEl,\n      scrollRootEl,\n      scrolling = false,\n      lastAutoScrollX,\n      lastAutoScrollY,\n      touchEvt$1,\n      pointerElemChangedInterval;\n\n  function AutoScrollPlugin() {\n    function AutoScroll() {\n      this.defaults = {\n        scroll: true,\n        scrollSensitivity: 30,\n        scrollSpeed: 10,\n        bubbleScroll: true\n      }; // Bind all private methods\n\n      for (var fn in this) {\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n          this[fn] = this[fn].bind(this);\n        }\n      }\n    }\n\n    AutoScroll.prototype = {\n      dragStarted: function dragStarted(_ref) {\n        var originalEvent = _ref.originalEvent;\n\n        if (this.sortable.nativeDraggable) {\n          on(document, 'dragover', this._handleAutoScroll);\n        } else {\n          if (this.options.supportPointer) {\n            on(document, 'pointermove', this._handleFallbackAutoScroll);\n          } else if (originalEvent.touches) {\n            on(document, 'touchmove', this._handleFallbackAutoScroll);\n          } else {\n            on(document, 'mousemove', this._handleFallbackAutoScroll);\n          }\n        }\n      },\n      dragOverCompleted: function dragOverCompleted(_ref2) {\n        var originalEvent = _ref2.originalEvent;\n\n        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n        if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n          this._handleAutoScroll(originalEvent);\n        }\n      },\n      drop: function drop() {\n        if (this.sortable.nativeDraggable) {\n          off(document, 'dragover', this._handleAutoScroll);\n        } else {\n          off(document, 'pointermove', this._handleFallbackAutoScroll);\n          off(document, 'touchmove', this._handleFallbackAutoScroll);\n          off(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n\n        clearPointerElemChangedInterval();\n        clearAutoScrolls();\n        cancelThrottle();\n      },\n      nulling: function nulling() {\n        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n        autoScrolls.length = 0;\n      },\n      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n        this._handleAutoScroll(evt, true);\n      },\n      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n        var _this = this;\n\n        var x = (evt.touches ? evt.touches[0] : evt).clientX,\n            y = (evt.touches ? evt.touches[0] : evt).clientY,\n            elem = document.elementFromPoint(x, y);\n        touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n        // Edge's autoscroll seems too conditional,\n        // MACOS Safari does not have autoscroll,\n        // Firefox and Chrome are good\n\n        if (fallback || Edge || IE11OrLess || Safari) {\n          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n          var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n            pointerElemChangedInterval = setInterval(function () {\n              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n              if (newElem !== ogElemScroller) {\n                ogElemScroller = newElem;\n                clearAutoScrolls();\n              }\n\n              autoScroll(evt, _this.options, newElem, fallback);\n            }, 10);\n            lastAutoScrollX = x;\n            lastAutoScrollY = y;\n          }\n        } else {\n          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n            clearAutoScrolls();\n            return;\n          }\n\n          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n        }\n      }\n    };\n    return _extends(AutoScroll, {\n      pluginName: 'scroll',\n      initializeByDefault: true\n    });\n  }\n\n  function clearAutoScrolls() {\n    autoScrolls.forEach(function (autoScroll) {\n      clearInterval(autoScroll.pid);\n    });\n    autoScrolls = [];\n  }\n\n  function clearPointerElemChangedInterval() {\n    clearInterval(pointerElemChangedInterval);\n  }\n\n  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n    if (!options.scroll) return;\n    var x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        sens = options.scrollSensitivity,\n        speed = options.scrollSpeed,\n        winScroller = getWindowScrollingElement();\n    var scrollThisInstance = false,\n        scrollCustomFn; // New scroll root, set scrollEl\n\n    if (scrollRootEl !== rootEl) {\n      scrollRootEl = rootEl;\n      clearAutoScrolls();\n      scrollEl = options.scroll;\n      scrollCustomFn = options.scrollFn;\n\n      if (scrollEl === true) {\n        scrollEl = getParentAutoScrollElement(rootEl, true);\n      }\n    }\n\n    var layersOut = 0;\n    var currentParent = scrollEl;\n\n    do {\n      var el = currentParent,\n          rect = getRect(el),\n          top = rect.top,\n          bottom = rect.bottom,\n          left = rect.left,\n          right = rect.right,\n          width = rect.width,\n          height = rect.height,\n          canScrollX = void 0,\n          canScrollY = void 0,\n          scrollWidth = el.scrollWidth,\n          scrollHeight = el.scrollHeight,\n          elCSS = css(el),\n          scrollPosX = el.scrollLeft,\n          scrollPosY = el.scrollTop;\n\n      if (el === winScroller) {\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n      } else {\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n      }\n\n      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n      if (!autoScrolls[layersOut]) {\n        for (var i = 0; i <= layersOut; i++) {\n          if (!autoScrolls[i]) {\n            autoScrolls[i] = {};\n          }\n        }\n      }\n\n      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n        autoScrolls[layersOut].el = el;\n        autoScrolls[layersOut].vx = vx;\n        autoScrolls[layersOut].vy = vy;\n        clearInterval(autoScrolls[layersOut].pid);\n\n        if (vx != 0 || vy != 0) {\n          scrollThisInstance = true;\n          /* jshint loopfunc:true */\n\n          autoScrolls[layersOut].pid = setInterval(function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n            }\n\n            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n            if (typeof scrollCustomFn === 'function') {\n              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({\n            layer: layersOut\n          }), 24);\n        }\n      }\n\n      layersOut++;\n    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n  }, 30);\n\n  var drop = function drop(_ref) {\n    var originalEvent = _ref.originalEvent,\n        putSortable = _ref.putSortable,\n        dragEl = _ref.dragEl,\n        activeSortable = _ref.activeSortable,\n        dispatchSortableEvent = _ref.dispatchSortableEvent,\n        hideGhostForTarget = _ref.hideGhostForTarget,\n        unhideGhostForTarget = _ref.unhideGhostForTarget;\n    if (!originalEvent) return;\n    var toSortable = putSortable || activeSortable;\n    hideGhostForTarget();\n    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n    var target = document.elementFromPoint(touch.clientX, touch.clientY);\n    unhideGhostForTarget();\n\n    if (toSortable && !toSortable.el.contains(target)) {\n      dispatchSortableEvent('spill');\n      this.onSpill({\n        dragEl: dragEl,\n        putSortable: putSortable\n      });\n    }\n  };\n\n  function Revert() {}\n\n  Revert.prototype = {\n    startIndex: null,\n    dragStart: function dragStart(_ref2) {\n      var oldDraggableIndex = _ref2.oldDraggableIndex;\n      this.startIndex = oldDraggableIndex;\n    },\n    onSpill: function onSpill(_ref3) {\n      var dragEl = _ref3.dragEl,\n          putSortable = _ref3.putSortable;\n      this.sortable.captureAnimationState();\n\n      if (putSortable) {\n        putSortable.captureAnimationState();\n      }\n\n      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n      if (nextSibling) {\n        this.sortable.el.insertBefore(dragEl, nextSibling);\n      } else {\n        this.sortable.el.appendChild(dragEl);\n      }\n\n      this.sortable.animateAll();\n\n      if (putSortable) {\n        putSortable.animateAll();\n      }\n    },\n    drop: drop\n  };\n\n  _extends(Revert, {\n    pluginName: 'revertOnSpill'\n  });\n\n  function Remove() {}\n\n  Remove.prototype = {\n    onSpill: function onSpill(_ref4) {\n      var dragEl = _ref4.dragEl,\n          putSortable = _ref4.putSortable;\n      var parentSortable = putSortable || this.sortable;\n      parentSortable.captureAnimationState();\n      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n      parentSortable.animateAll();\n    },\n    drop: drop\n  };\n\n  _extends(Remove, {\n    pluginName: 'removeOnSpill'\n  });\n\n  var lastSwapEl;\n\n  function SwapPlugin() {\n    function Swap() {\n      this.defaults = {\n        swapClass: 'sortable-swap-highlight'\n      };\n    }\n\n    Swap.prototype = {\n      dragStart: function dragStart(_ref) {\n        var dragEl = _ref.dragEl;\n        lastSwapEl = dragEl;\n      },\n      dragOverValid: function dragOverValid(_ref2) {\n        var completed = _ref2.completed,\n            target = _ref2.target,\n            onMove = _ref2.onMove,\n            activeSortable = _ref2.activeSortable,\n            changed = _ref2.changed,\n            cancel = _ref2.cancel;\n        if (!activeSortable.options.swap) return;\n        var el = this.sortable.el,\n            options = this.options;\n\n        if (target && target !== el) {\n          var prevSwapEl = lastSwapEl;\n\n          if (onMove(target) !== false) {\n            toggleClass(target, options.swapClass, true);\n            lastSwapEl = target;\n          } else {\n            lastSwapEl = null;\n          }\n\n          if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n            toggleClass(prevSwapEl, options.swapClass, false);\n          }\n        }\n\n        changed();\n        completed(true);\n        cancel();\n      },\n      drop: function drop(_ref3) {\n        var activeSortable = _ref3.activeSortable,\n            putSortable = _ref3.putSortable,\n            dragEl = _ref3.dragEl;\n        var toSortable = putSortable || this.sortable;\n        var options = this.options;\n        lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n        if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n          if (dragEl !== lastSwapEl) {\n            toSortable.captureAnimationState();\n            if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n            swapNodes(dragEl, lastSwapEl);\n            toSortable.animateAll();\n            if (toSortable !== activeSortable) activeSortable.animateAll();\n          }\n        }\n      },\n      nulling: function nulling() {\n        lastSwapEl = null;\n      }\n    };\n    return _extends(Swap, {\n      pluginName: 'swap',\n      eventProperties: function eventProperties() {\n        return {\n          swapItem: lastSwapEl\n        };\n      }\n    });\n  }\n\n  function swapNodes(n1, n2) {\n    var p1 = n1.parentNode,\n        p2 = n2.parentNode,\n        i1,\n        i2;\n    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n    i1 = index(n1);\n    i2 = index(n2);\n\n    if (p1.isEqualNode(p2) && i1 < i2) {\n      i2++;\n    }\n\n    p1.insertBefore(n2, p1.children[i1]);\n    p2.insertBefore(n1, p2.children[i2]);\n  }\n\n  var multiDragElements = [],\n      multiDragClones = [],\n      lastMultiDragSelect,\n      // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n      initialFolding = false,\n      // Initial multi-drag fold when drag started\n  folding = false,\n      // Folding any other time\n  dragStarted = false,\n      dragEl$1,\n      clonesFromRect,\n      clonesHidden;\n\n  function MultiDragPlugin() {\n    function MultiDrag(sortable) {\n      // Bind all private methods\n      for (var fn in this) {\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n          this[fn] = this[fn].bind(this);\n        }\n      }\n\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n\n      on(document, 'keydown', this._checkKeyDown);\n      on(document, 'keyup', this._checkKeyUp);\n      this.defaults = {\n        selectedClass: 'sortable-selected',\n        multiDragKey: null,\n        setData: function setData(dataTransfer, dragEl) {\n          var data = '';\n\n          if (multiDragElements.length && multiDragSortable === sortable) {\n            multiDragElements.forEach(function (multiDragElement, i) {\n              data += (!i ? '' : ', ') + multiDragElement.textContent;\n            });\n          } else {\n            data = dragEl.textContent;\n          }\n\n          dataTransfer.setData('Text', data);\n        }\n      };\n    }\n\n    MultiDrag.prototype = {\n      multiDragKeyDown: false,\n      isMultiDrag: false,\n      delayStartGlobal: function delayStartGlobal(_ref) {\n        var dragged = _ref.dragEl;\n        dragEl$1 = dragged;\n      },\n      delayEnded: function delayEnded() {\n        this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n      },\n      setupClone: function setupClone(_ref2) {\n        var sortable = _ref2.sortable,\n            cancel = _ref2.cancel;\n        if (!this.isMultiDrag) return;\n\n        for (var i = 0; i < multiDragElements.length; i++) {\n          multiDragClones.push(clone(multiDragElements[i]));\n          multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n          multiDragClones[i].draggable = false;\n          multiDragClones[i].style['will-change'] = '';\n          toggleClass(multiDragClones[i], this.options.selectedClass, false);\n          multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n        }\n\n        sortable._hideClone();\n\n        cancel();\n      },\n      clone: function clone(_ref3) {\n        var sortable = _ref3.sortable,\n            rootEl = _ref3.rootEl,\n            dispatchSortableEvent = _ref3.dispatchSortableEvent,\n            cancel = _ref3.cancel;\n        if (!this.isMultiDrag) return;\n\n        if (!this.options.removeCloneOnHide) {\n          if (multiDragElements.length && multiDragSortable === sortable) {\n            insertMultiDragClones(true, rootEl);\n            dispatchSortableEvent('clone');\n            cancel();\n          }\n        }\n      },\n      showClone: function showClone(_ref4) {\n        var cloneNowShown = _ref4.cloneNowShown,\n            rootEl = _ref4.rootEl,\n            cancel = _ref4.cancel;\n        if (!this.isMultiDrag) return;\n        insertMultiDragClones(false, rootEl);\n        multiDragClones.forEach(function (clone) {\n          css(clone, 'display', '');\n        });\n        cloneNowShown();\n        clonesHidden = false;\n        cancel();\n      },\n      hideClone: function hideClone(_ref5) {\n        var _this = this;\n\n        var sortable = _ref5.sortable,\n            cloneNowHidden = _ref5.cloneNowHidden,\n            cancel = _ref5.cancel;\n        if (!this.isMultiDrag) return;\n        multiDragClones.forEach(function (clone) {\n          css(clone, 'display', 'none');\n\n          if (_this.options.removeCloneOnHide && clone.parentNode) {\n            clone.parentNode.removeChild(clone);\n          }\n        });\n        cloneNowHidden();\n        clonesHidden = true;\n        cancel();\n      },\n      dragStartGlobal: function dragStartGlobal(_ref6) {\n        var sortable = _ref6.sortable;\n\n        if (!this.isMultiDrag && multiDragSortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n        }\n\n        multiDragElements.forEach(function (multiDragElement) {\n          multiDragElement.sortableIndex = index(multiDragElement);\n        }); // Sort multi-drag elements\n\n        multiDragElements = multiDragElements.sort(function (a, b) {\n          return a.sortableIndex - b.sortableIndex;\n        });\n        dragStarted = true;\n      },\n      dragStarted: function dragStarted(_ref7) {\n        var _this2 = this;\n\n        var sortable = _ref7.sortable;\n        if (!this.isMultiDrag) return;\n\n        if (this.options.sort) {\n          // Capture rects,\n          // hide multi drag elements (by positioning them absolute),\n          // set multi drag elements rects to dragRect,\n          // show multi drag elements,\n          // animate to rects,\n          // unset rects & remove from DOM\n          sortable.captureAnimationState();\n\n          if (this.options.animation) {\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              css(multiDragElement, 'position', 'absolute');\n            });\n            var dragRect = getRect(dragEl$1, false, true, true);\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              setRect(multiDragElement, dragRect);\n            });\n            folding = true;\n            initialFolding = true;\n          }\n        }\n\n        sortable.animateAll(function () {\n          folding = false;\n          initialFolding = false;\n\n          if (_this2.options.animation) {\n            multiDragElements.forEach(function (multiDragElement) {\n              unsetRect(multiDragElement);\n            });\n          } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n          if (_this2.options.sort) {\n            removeMultiDragElements();\n          }\n        });\n      },\n      dragOver: function dragOver(_ref8) {\n        var target = _ref8.target,\n            completed = _ref8.completed,\n            cancel = _ref8.cancel;\n\n        if (folding && ~multiDragElements.indexOf(target)) {\n          completed(false);\n          cancel();\n        }\n      },\n      revert: function revert(_ref9) {\n        var fromSortable = _ref9.fromSortable,\n            rootEl = _ref9.rootEl,\n            sortable = _ref9.sortable,\n            dragRect = _ref9.dragRect;\n\n        if (multiDragElements.length > 1) {\n          // Setup unfold animation\n          multiDragElements.forEach(function (multiDragElement) {\n            sortable.addAnimationState({\n              target: multiDragElement,\n              rect: folding ? getRect(multiDragElement) : dragRect\n            });\n            unsetRect(multiDragElement);\n            multiDragElement.fromRect = dragRect;\n            fromSortable.removeAnimationState(multiDragElement);\n          });\n          folding = false;\n          insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n        }\n      },\n      dragOverCompleted: function dragOverCompleted(_ref10) {\n        var sortable = _ref10.sortable,\n            isOwner = _ref10.isOwner,\n            insertion = _ref10.insertion,\n            activeSortable = _ref10.activeSortable,\n            parentEl = _ref10.parentEl,\n            putSortable = _ref10.putSortable;\n        var options = this.options;\n\n        if (insertion) {\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n          if (isOwner) {\n            activeSortable._hideClone();\n          }\n\n          initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n          if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n            // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n            var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n              // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n              parentEl.appendChild(multiDragElement);\n            });\n            folding = true;\n          } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n          if (!isOwner) {\n            // Only remove if not folding (folding will remove them anyways)\n            if (!folding) {\n              removeMultiDragElements();\n            }\n\n            if (multiDragElements.length > 1) {\n              var clonesHiddenBefore = clonesHidden;\n\n              activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n              if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n                multiDragClones.forEach(function (clone) {\n                  activeSortable.addAnimationState({\n                    target: clone,\n                    rect: clonesFromRect\n                  });\n                  clone.fromRect = clonesFromRect;\n                  clone.thisAnimationDuration = null;\n                });\n              }\n            } else {\n              activeSortable._showClone(sortable);\n            }\n          }\n        }\n      },\n      dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n        var dragRect = _ref11.dragRect,\n            isOwner = _ref11.isOwner,\n            activeSortable = _ref11.activeSortable;\n        multiDragElements.forEach(function (multiDragElement) {\n          multiDragElement.thisAnimationDuration = null;\n        });\n\n        if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n          clonesFromRect = _extends({}, dragRect);\n          var dragMatrix = matrix(dragEl$1, true);\n          clonesFromRect.top -= dragMatrix.f;\n          clonesFromRect.left -= dragMatrix.e;\n        }\n      },\n      dragOverAnimationComplete: function dragOverAnimationComplete() {\n        if (folding) {\n          folding = false;\n          removeMultiDragElements();\n        }\n      },\n      drop: function drop(_ref12) {\n        var evt = _ref12.originalEvent,\n            rootEl = _ref12.rootEl,\n            parentEl = _ref12.parentEl,\n            sortable = _ref12.sortable,\n            dispatchSortableEvent = _ref12.dispatchSortableEvent,\n            oldIndex = _ref12.oldIndex,\n            putSortable = _ref12.putSortable;\n        var toSortable = putSortable || this.sortable;\n        if (!evt) return;\n        var options = this.options,\n            children = parentEl.children; // Multi-drag selection\n\n        if (!dragStarted) {\n          if (options.multiDragKey && !this.multiDragKeyDown) {\n            this._deselectMultiDrag();\n          }\n\n          toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n          if (!~multiDragElements.indexOf(dragEl$1)) {\n            multiDragElements.push(dragEl$1);\n            dispatchEvent({\n              sortable: sortable,\n              rootEl: rootEl,\n              name: 'select',\n              targetEl: dragEl$1,\n              originalEvt: evt\n            }); // Modifier activated, select from last to dragEl\n\n            if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n              var lastIndex = index(lastMultiDragSelect),\n                  currentIndex = index(dragEl$1);\n\n              if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n                // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n                // (but previous selection existed)\n                var n, i;\n\n                if (currentIndex > lastIndex) {\n                  i = lastIndex;\n                  n = currentIndex;\n                } else {\n                  i = currentIndex;\n                  n = lastIndex + 1;\n                }\n\n                for (; i < n; i++) {\n                  if (~multiDragElements.indexOf(children[i])) continue;\n                  toggleClass(children[i], options.selectedClass, true);\n                  multiDragElements.push(children[i]);\n                  dispatchEvent({\n                    sortable: sortable,\n                    rootEl: rootEl,\n                    name: 'select',\n                    targetEl: children[i],\n                    originalEvt: evt\n                  });\n                }\n              }\n            } else {\n              lastMultiDragSelect = dragEl$1;\n            }\n\n            multiDragSortable = toSortable;\n          } else {\n            multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n            lastMultiDragSelect = null;\n            dispatchEvent({\n              sortable: sortable,\n              rootEl: rootEl,\n              name: 'deselect',\n              targetEl: dragEl$1,\n              originalEvt: evt\n            });\n          }\n        } // Multi-drag drop\n\n\n        if (dragStarted && this.isMultiDrag) {\n          // Do not \"unfold\" after around dragEl if reverted\n          if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n            var dragRect = getRect(dragEl$1),\n                multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n            if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n            toSortable.captureAnimationState();\n\n            if (!initialFolding) {\n              if (options.animation) {\n                dragEl$1.fromRect = dragRect;\n                multiDragElements.forEach(function (multiDragElement) {\n                  multiDragElement.thisAnimationDuration = null;\n\n                  if (multiDragElement !== dragEl$1) {\n                    var rect = folding ? getRect(multiDragElement) : dragRect;\n                    multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                    toSortable.addAnimationState({\n                      target: multiDragElement,\n                      rect: rect\n                    });\n                  }\n                });\n              } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n              // properly they must all be removed\n\n\n              removeMultiDragElements();\n              multiDragElements.forEach(function (multiDragElement) {\n                if (children[multiDragIndex]) {\n                  parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n                } else {\n                  parentEl.appendChild(multiDragElement);\n                }\n\n                multiDragIndex++;\n              }); // If initial folding is done, the elements may have changed position because they are now\n              // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n              // must be fired here as Sortable will not.\n\n              if (oldIndex === index(dragEl$1)) {\n                var update = false;\n                multiDragElements.forEach(function (multiDragElement) {\n                  if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                    update = true;\n                    return;\n                  }\n                });\n\n                if (update) {\n                  dispatchSortableEvent('update');\n                }\n              }\n            } // Must be done after capturing individual rects (scroll bar)\n\n\n            multiDragElements.forEach(function (multiDragElement) {\n              unsetRect(multiDragElement);\n            });\n            toSortable.animateAll();\n          }\n\n          multiDragSortable = toSortable;\n        } // Remove clones if necessary\n\n\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n          multiDragClones.forEach(function (clone) {\n            clone.parentNode && clone.parentNode.removeChild(clone);\n          });\n        }\n      },\n      nullingGlobal: function nullingGlobal() {\n        this.isMultiDrag = dragStarted = false;\n        multiDragClones.length = 0;\n      },\n      destroyGlobal: function destroyGlobal() {\n        this._deselectMultiDrag();\n\n        off(document, 'pointerup', this._deselectMultiDrag);\n        off(document, 'mouseup', this._deselectMultiDrag);\n        off(document, 'touchend', this._deselectMultiDrag);\n        off(document, 'keydown', this._checkKeyDown);\n        off(document, 'keyup', this._checkKeyUp);\n      },\n      _deselectMultiDrag: function _deselectMultiDrag(evt) {\n        if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n        if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n        if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n        if (evt && evt.button !== 0) return;\n\n        while (multiDragElements.length) {\n          var el = multiDragElements[0];\n          toggleClass(el, this.options.selectedClass, false);\n          multiDragElements.shift();\n          dispatchEvent({\n            sortable: this.sortable,\n            rootEl: this.sortable.el,\n            name: 'deselect',\n            targetEl: el,\n            originalEvt: evt\n          });\n        }\n      },\n      _checkKeyDown: function _checkKeyDown(evt) {\n        if (evt.key === this.options.multiDragKey) {\n          this.multiDragKeyDown = true;\n        }\n      },\n      _checkKeyUp: function _checkKeyUp(evt) {\n        if (evt.key === this.options.multiDragKey) {\n          this.multiDragKeyDown = false;\n        }\n      }\n    };\n    return _extends(MultiDrag, {\n      // Static methods & properties\n      pluginName: 'multiDrag',\n      utils: {\n        /**\r\n         * Selects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be selected\r\n         */\n        select: function select(el) {\n          var sortable = el.parentNode[expando];\n          if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n          if (multiDragSortable && multiDragSortable !== sortable) {\n            multiDragSortable.multiDrag._deselectMultiDrag();\n\n            multiDragSortable = sortable;\n          }\n\n          toggleClass(el, sortable.options.selectedClass, true);\n          multiDragElements.push(el);\n        },\n\n        /**\r\n         * Deselects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be deselected\r\n         */\n        deselect: function deselect(el) {\n          var sortable = el.parentNode[expando],\n              index = multiDragElements.indexOf(el);\n          if (!sortable || !sortable.options.multiDrag || !~index) return;\n          toggleClass(el, sortable.options.selectedClass, false);\n          multiDragElements.splice(index, 1);\n        }\n      },\n      eventProperties: function eventProperties() {\n        var _this3 = this;\n\n        var oldIndicies = [],\n            newIndicies = [];\n        multiDragElements.forEach(function (multiDragElement) {\n          oldIndicies.push({\n            multiDragElement: multiDragElement,\n            index: multiDragElement.sortableIndex\n          }); // multiDragElements will already be sorted if folding\n\n          var newIndex;\n\n          if (folding && multiDragElement !== dragEl$1) {\n            newIndex = -1;\n          } else if (folding) {\n            newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n          } else {\n            newIndex = index(multiDragElement);\n          }\n\n          newIndicies.push({\n            multiDragElement: multiDragElement,\n            index: newIndex\n          });\n        });\n        return {\n          items: _toConsumableArray(multiDragElements),\n          clones: [].concat(multiDragClones),\n          oldIndicies: oldIndicies,\n          newIndicies: newIndicies\n        };\n      },\n      optionListeners: {\n        multiDragKey: function multiDragKey(key) {\n          key = key.toLowerCase();\n\n          if (key === 'ctrl') {\n            key = 'Control';\n          } else if (key.length > 1) {\n            key = key.charAt(0).toUpperCase() + key.substr(1);\n          }\n\n          return key;\n        }\n      }\n    });\n  }\n\n  function insertMultiDragElements(clonesInserted, rootEl) {\n    multiDragElements.forEach(function (multiDragElement, i) {\n      var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n      if (target) {\n        rootEl.insertBefore(multiDragElement, target);\n      } else {\n        rootEl.appendChild(multiDragElement);\n      }\n    });\n  }\n  /**\r\n   * Insert multi-drag clones\r\n   * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n   * @param  {HTMLElement} rootEl\r\n   */\n\n\n  function insertMultiDragClones(elementsInserted, rootEl) {\n    multiDragClones.forEach(function (clone, i) {\n      var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n      if (target) {\n        rootEl.insertBefore(clone, target);\n      } else {\n        rootEl.appendChild(clone);\n      }\n    });\n  }\n\n  function removeMultiDragElements() {\n    multiDragElements.forEach(function (multiDragElement) {\n      if (multiDragElement === dragEl$1) return;\n      multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n    });\n  }\n\n  Sortable.mount(new AutoScrollPlugin());\n  Sortable.mount(Remove, Revert);\n\n  Sortable.mount(new SwapPlugin());\n  Sortable.mount(new MultiDragPlugin());\n\n  return Sortable;\n\n}));\n","import * as utils from './modules/utils.mjs'\nimport * as search from './modules/search.mjs'\nimport togglePreferences from './modules/togglePreferences.mjs'\nimport urgentAnnouncement from './web-components/urgent-announcement.mjs'\nimport { WC_announcementsWidget } from './web-components/announcements.mjs'\nimport * as unreadAnnouncements from './modules/unreadAnnouncements.mjs'\nimport * as notify from './modules/notify.mjs'\nimport dragAndDrop from './modules/drag-and-drop.mjs'\n\nconst page = document.querySelector('main').id.toLowerCase()\n\n//init web components\nif (page === 'dashboard') {\n    utils.appendWidgets(utils.getPreferences())\n\n    // dragAndDrop()\n}\n\nif (page === 'account') {\n    togglePreferences()\n}\n\nif (page === 'announcements-overview') {\n    const announcementList = document.getElementById('announcements')\n    announcementList.remove()\n    document.querySelector('main section').append(document.createElement('announcements-widget'))\n    WC_announcementsWidget(page)\n}\n\n\n//check if browser is online\nif (navigator.onLine) {\n    //urgent announcements\n    const socket = io()\n\n    //subscribe to urgent-announcements\n    socket.emit('join', page)\n\n    //on urgent-announcement hook update interface (see WC_urgentAnnouncement)\n    socket.on('urgent-announcement', announcement => {\n        const urgentAnnouncement = document.querySelector('urgent-announcement')\n\n        if (utils.exists([urgentAnnouncement])) {\n            urgentAnnouncement.setAttribute('message', announcement.content)\n            urgentAnnouncement.setAttribute('uid', announcement.newsItemId)\n        }\n\n        if ('Notification' in window) {\n            navigator.serviceWorker.ready //wait for sw to be ready\n                .then(registration => {\n                    Notification.requestPermission(status => {\n                        notify.displayNotification(announcement.title, announcement.content)\n                    })\n                })\n        }\n    })\n}\n\n\n\n\n//menu \nconst menuIcon = document.getElementById('menu-icon')\nconst menu = document.getElementById('menu')\n\nif (utils.exists([menuIcon, menu])) {\n\n    //toggle menu (on mobile)\n    menuIcon.addEventListener('click', () => {\n        menu.classList.toggle('hide')\n    })\n}\n\n\n\n\n//search \nconst searchBar = document.getElementById('search-bar')\nconst searchResetIcon = document.getElementById('search-reset')\nconst searchIcon = document.querySelector('#search-container input[type=submit]')\n\nif (utils.exists([searchBar, searchResetIcon, searchIcon])) {\n\n    //control search-reset icon \n    searchBar.addEventListener('focus', () => search.showReset())\n    searchBar.addEventListener('blur', () => search.hideReset())\n\n\n    //reset search input\n    searchResetIcon.addEventListener('click', e => search.reset(e))\n\n\n    //depending on search-query either give focus to searchbar or submit search-query\n    searchIcon.addEventListener('click', e => {\n        if (searchBar.value === \"\") {\n            search.focus(e)\n        }\n    })\n\n\n    //listen to keyboard input\n    document.addEventListener('keypress', e => {\n        switch (e.key) {\n            case \"/\":\n                search.focus(e) //give searchbar focus and hide search-reset icon\n                break\n        }\n    })\n}\n\n\n//unread announcement indicator in menu\nconst announcementMenuItem = document.querySelector('#menu-primary-links a:last-of-type')\n\nif (utils.exists([announcementMenuItem]) && utils.storageAvailable('localStorage')) {\n    unreadAnnouncements.indicate(announcementMenuItem)\n}","import Sortable from 'sortablejs'\n\nexport default function dragAndDrop() {\n    const widgetContainer = document.querySelector('#widget-container')\n\n    new Sortable(widgetContainer, {\n        animation: 150,\n        onStart: (event) => console.log(event),\n        onEnd: (event) => console.log(event)\n    })\n}","export function displayNotification(title, body) {\n    if (Notification.permission === 'granted') {\n        navigator.serviceWorker.getRegistration().then(reg => {\n            const options = {\n                body,\n                icon: './media/icons/hva-logo-purple.svg',\n                vibrate: [100, 50, 100],\n                data: {\n                    timestamp: Date.now()\n                },\n                actions: [{\n                        action: 'goto',\n                        title: 'Go to HvA Portal',\n                        icon: './media/icons/hva-logo-purple.svg'\n                    },\n                    {\n                        action: 'close',\n                        title: 'Close notification',\n                        icon: './media/icons/hva-logo-purple.svg'\n                    },\n                ]\n            }\n            reg.showNotification(title, options)\n        })\n    }\n}","const searchBar = document.getElementById('search-bar')\nconst searchResetIcon = document.getElementById('search-reset')\n\nexport function focus(e) {\n    e.preventDefault()\n    searchBar.focus()\n}\n\nexport function showReset() {\n    searchResetIcon.classList.remove('hide')\n}\n\nexport function hideReset() {\n    if (searchBar.value === \"\") {\n        searchResetIcon.classList.add('hide')\n    }\n}\n\nexport function reset(e) {\n    searchBar.value = \"\"\n    focus(e)\n}","import { setLocalStorage, getLocalStorage } from '../modules/utils.mjs'\nimport Sortable from 'sortablejs'\n\nconst container = document.querySelector('#account form')\nexport default function togglePreferences() {\n    container.classList.remove('disabled')\n\n    getPreferences()\n    stateHandler()\n    dragHandler()\n}\n\nfunction getPreferences() {\n    const preferences = getLocalStorage('preferences')\n    if (preferences) {\n        container.textContent = ''\n        preferences.forEach(preference => container.append(createLabels(preference)))\n    } else {\n        setPreferencesObject()\n    }\n}\n\nfunction dragHandler() {\n    const preferencesContainer = document.querySelector('#preferences')\n\n    new Sortable(preferencesContainer, {\n        draggable: \".on\",\n        animation: 150,\n        onStart: (event) => addStylingToDropZones(event),\n        onEnd: (event) => {\n            removeStylingFromDropZones(event)\n            setPreferencesObject()\n        }\n    })\n}\n\nfunction addStylingToDropZones(event) {\n    const dragLocations = [...event.target.querySelectorAll('label:not(.sortable-chosen)')]\n    dragLocations.forEach(location => location.classList.add('optional-location'))\n}\n\nfunction removeStylingFromDropZones(event) {\n    const dragLocations = [...event.target.querySelectorAll('label:not(.sortable-chosen)')]\n    dragLocations.forEach(location => location.classList.remove('optional-location'))\n}\n\n// Saving and changing preferences \nfunction setPreferencesObject() {\n    const inputs = [...document.querySelectorAll('#account form label')]\n    let preferences = []\n\n    inputs.forEach(label => {\n        // Data\n        const id = label.id\n        const text = label.textContent\n        const state = label.querySelector('input').checked\n\n        // Set LocalStorage\n        const object = { id: id, name: text, state: state }\n        preferences.push(object)\n        setLocalStorage('preferences', preferences)\n    })\n\n    return preferences\n}\n\nfunction stateHandler() {\n    const inputs = [...document.querySelectorAll('#account form label')]\n    const data = getLocalStorage('preferences')\n\n    inputs.forEach(label => {\n        updateState(data, label)\n\n        label.addEventListener('change', event => {\n            // Data\n            const id = label.id\n            const state = event.target.checked\n\n            // Change LocalStorage\n            const preference = data.find(preference => preference.id === id)\n            preference.state = state\n            setLocalStorage('preferences', data)\n\n            // Change state visualy\n            if (preference.state) {\n                label.classList.add('on')\n                label.classList.remove('off')\n            } else {\n                label.classList.add('off')\n                label.classList.remove('on')\n                container.appendChild(label)\n                setPreferencesObject()\n            }\n        })\n    })\n}\n\nfunction updateState(data, element) {\n    const preference = data.find(preference => preference.id === element.id)\n    preference.state ? element.classList.remove('off') : element.classList.add('on')\n}\n\n// Rearanging order\nfunction createLabels(preference) {\n    const label = document.createElement('label')\n    label.id = preference.id\n    preference.state ? label.className = 'on' : label.className = 'off'\n\n    label.setAttribute('represents', preference.id)\n\n    const input = document.createElement('input')\n    input.type = 'checkbox'\n    input.checked = preference.state\n\n    label.append(input)\n    label.append(preference.name)\n\n    return label\n}","import * as utils from '../modules/utils.mjs'\n\nexport function indicate(item) {\n    getUnread()\n        .then(numberUnread => {\n            if (numberUnread > 0) {\n                item.classList.add('unread-indicator')\n                item.setAttribute('number-unread', numberUnread)\n            }\n        })\n}\n\n\nfunction getAnnouncements() {\n    const options = {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n    }\n\n    return fetch('/announcementslist', options).then(res => res.json())\n}\n\nfunction getUnread() {\n    const storedHistory = utils.getLocalStorage('read-history')\n    const numberUnread = getAnnouncements()\n        .then(json => {\n            const [announcements, categories] = json\n            return announcements\n        })\n        .then(announcements => {\n            let numberOfUnread = 0\n            if (storedHistory) {\n                announcements.forEach(announcement => {\n                    if (!storedHistory.includes(announcement.newsItemId)) {\n                        numberOfUnread++\n                    }\n                })\n            } else {\n                document.querySelector('#menu-primary-links a:last-of-type').classList.add('unread-indicator')\n                document.querySelector('#menu-primary-links a:last-of-type').setAttribute('number-unread', announcements.length)\n            }\n            return numberOfUnread\n        })\n    return numberUnread\n}","import { WC_studyprogress } from '../web-components/study-progress.mjs'\nimport { WC_scheduleWidget } from '../web-components/schedule.mjs'\nimport { WC_courseoverview } from '../web-components/course-overview.mjs'\nimport { WC_announcementsWidget } from '../web-components/announcements.mjs'\n\nexport function exists([...variables]) {\n    const exists = variables.every(variable => variable != null)\n    return exists\n}\n\n\nexport function setLocalStorage(name, item) {\n    localStorage.setItem(name, JSON.stringify(item))\n}\n\n\nexport function getLocalStorage(item) {\n    return JSON.parse(localStorage.getItem(item))\n}\n\nexport function storageAvailable(type) { //source: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n    let storage\n    try {\n        storage = window[type]\n        let x = '__storage_test__'\n        storage.setItem(x, x)\n        storage.removeItem(x)\n        return true\n    } catch (e) {\n        return e instanceof DOMException && (\n                e.code === 22 ||\n                e.code === 1014 ||\n                e.name === 'QuotaExceededError' ||\n                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            (storage && storage.length !== 0)\n    }\n}\n\nexport function getPreferences() {\n    let widgetElements\n\n    if (storageAvailable('localStorage')) {\n        const preferences = getLocalStorage('preferences')\n        if (preferences) {\n            widgetElements = checker(preferences)\n        } else {\n            widgetElements = ['announcements-widget', 'study-progress', 'course-overview', 'schedule-widget']\n        }\n    } else {\n        widgetElements = ['announcements-widget', 'study-progress', 'course-overview', 'schedule-widget']\n    }\n\n    return widgetElements\n}\n\nexport function appendWidgets(widget) {\n    // Remove EJS templates\n    const domElements = ['announcements', 'study-progress', 'course-overview', 'schedule']\n    domElements.forEach(element => document.getElementById(element).remove())\n\n    // Adding widgets\n    widget.forEach(item => {\n        document.querySelector('#widget-container').append(document.createElement(item))\n\n        if (item === 'study-progress') {\n            WC_studyprogress()\n        }\n        if (item === 'course-overview') {\n            WC_courseoverview()\n        }\n        if (item === 'schedule-widget') {\n            WC_scheduleWidget()\n        }\n        if (item === 'announcements-widget') {\n            WC_announcementsWidget('dashboard')\n        }\n    })\n}\n\nexport function checker(preferences) {\n    const widgetElements = []\n\n    // Announcements\n    preferences.forEach(preference => {\n        preference.id = parseInt(preference.id)\n\n        if (preference.state && preference.id === 0) {\n            widgetElements.push('announcements-widget')\n        }\n        if (preference.state && preference.id === 1) {\n            widgetElements.push('study-progress')\n        }\n        if (preference.state && preference.id === 2) {\n            widgetElements.push('course-overview')\n        }\n        if (preference.state && preference.id === 3) {\n            widgetElements.push('schedule-widget')\n        }\n    })\n\n    return widgetElements\n}","import * as utils from '../modules/utils.mjs'\n\nexport { init as WC_announcementsWidget }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\n*:focus {\n    outline: none;\n}\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\np {\n\tmargin: 0;\n}\n.announcements-container #announcement-legend {\n\tmargin-bottom: 20px;\n}\n.announcements-container #announcement-legend p {\n\tcolor: black;\n\tfont-size: 14px;\n\tdisplay: inline-block;\n\tmargin-right: 20px;\n}\n.announcements-container #announcement-legend p:last-of-type {\n\tmargin-right: 0;\n}\n.announcements-container #announcement-legend p::before {\n\tcontent: \"\";\n\theight: 15px;\n\tmargin-bottom: -2px;\n\twidth: 15px;\n\tmargin-right: 10px;\n\tdisplay: inline-block;\n}\n.announcements-container #announcement-legend p.Opleiding::before {\n\tbackground-color: #DC143C;\n}\n.announcements-container #announcement-legend p.Faculteit::before {\n\tbackground-color: #DCB614;\n}\n.announcements-container #announcement-legend p.HvA::before {\n\tbackground-color: #149EDC;\n}\n.announcements-container #announcement-legend p.Medezeggenschap::before {\n\tbackground-color: #14DC69;\n}\n.announcements-container a {\n\tmargin: 0 0 15px 0;\n\tdisplay: block;\n\tcolor: black;\n\ttext-decoration: none;\n}\n.announcements-container a:hover {\n\tbackground-color: #F2F2F2;\n}\n.announcements-container a:focus {\n\tbackground-color: #DDDDDD;\n}\n.announcements-container .announcement {\n\tmargin: 0;\n\tpadding: 5px 0 5px 10px;\n\tborder-left: 5px solid;\n}\n.announcements-container .announcement.Opleiding {\n\tborder-color: #DC143C;\n}\n.announcements-container .announcement.Faculteit {\n\tborder-color: #DCB614;\n}\n.announcements-container .announcement.HvA {\n\tborder-color: #149EDC;\n}\n.announcements-container .announcement.Medezeggenschap {\n\tborder-color: #14DC69;\n}\n.announcements-container .announcement p:first-of-type {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n.announcements-container .read .announcement p:first-of-type {\n    font-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n}\n.announcements-container .announcement p:last-of-type {\n\tcolor: #666666;\n\tfont-size: 14px;\n}    \n.allAnnouncements {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n\talign-items: center;\n}\n.allAnnouncements:hover,\n.allAnnouncements:focus {\n        text-decoration: underline;\n}\n.allAnnouncements.hide {\n    position: absolute;\n    left: -9999px;\n}\n.allAnnouncements img {\n        height: 12px;\n        margin-left: 20px;\n}\n</style>\n<div id=\"announcements\"></div>\n<h2>Mededelingen</h2>\n<div class=\"announcements-container\">\n\t<div id=\"announcement-legend\"></div>\n</div>\n<a class=\"allAnnouncements\" href=\"/announcements/\" target=\"_self\">Alle mededelingen\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>`\n\nfunction init(pageName) {\n    class announcementList extends HTMLElement {\n        constructor() {\n            super()\n\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.getData()\n                .then(json => {\n                    const [announcements, categories] = json\n                    this.createLegenda(categories)\n                    if (pageName === 'dashboard') {\n                        announcements.splice(5, announcements.length)\n                    }\n                    this.appendAnnouncements(announcements)\n                })\n            this.announcementContainer = this.shadowRoot.querySelector('.announcements-container')\n            this.announcementLegend = this.shadowRoot.querySelector('#announcement-legend')\n\n            if (pageName === 'announcements-overview') {\n                console.log('ja')\n                this.shadowRoot.querySelector('.allAnnouncements').classList.add('hide')\n            }\n        }\n\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/announcementslist', options).then(res => res.json())\n        }\n\n        createLegenda(categories) {\n            categories.forEach(cat => {\n                this.announcementLegend.insertAdjacentHTML('beforeend', `<p class=\"${cat}\">${cat}</p>`)\n            })\n        }\n\n        appendAnnouncements(announcements) {\n            announcements.forEach(announcement => {\n                this.announcementContainer.insertAdjacentHTML('beforeend', `\n\t\t\t\t<a href=\"/announcements/${announcement.newsItemId}\" target=\"_self\" uid=\"${announcement.newsItemId}\">\n\t\t\t\t\t<div class=\"announcement ${announcement.tags[0]}\" id=\"${announcement.newsItemId}\">\n                \t\t<p>${announcement.title}</p>\n                \t\t<p>${announcement.publishDate} - ${announcement.tags[0]}</p>\n           \t\t\t</div>\n\t\t\t\t</a>`)\n\n                if (utils.storageAvailable('localStorage')) {\n                    const storedHistory = utils.getLocalStorage('read-history')\n                    this.readHistory = storedHistory ? storedHistory : []\n\n                    const link = this.announcementContainer.querySelector('a:last-of-type')\n\n                    if (this.readHistory.includes(link.getAttribute('uid'))) {\n                        link.classList.add('read')\n                    }\n                    link.addEventListener('click', () => this.store(link))\n                }\n            })\n        }\n\n        store(announcement) {\n            this.readHistory.push(announcement.getAttribute('uid'))\n            utils.setLocalStorage('read-history', this.readHistory)\n        }\n    }\n\n    window.customElements.define('announcements-widget', announcementList)\n}","export { init as WC_courseoverview }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\n\np {\n\tmargin: 0;\n}\n\n.navigator {\n    background-color: #DDDDDD;\n    padding: 5px 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color: #25167A;\n    font-size: 16px;\n}\n\n.navigator span  {\n    cursor: default;\n}\n\n.navigator img {\n    padding: 10px;\n}\n\n.navigator img:not(.disabled) {\n    cursor: pointer;\n}\n\n.navigator img.disabled {\n    pointer-events: none;\n    opacity: .5;\n}\n\n.course {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    grid-column-gap: 20px;\n    padding: 15px 20px;\n    border-bottom: 1px solid #DDDDDD;\n}\n\n.course p:first-of-type {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n    align-self: center;\n}\n\n.course ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    align-self: center;\n}\n\n.course ul li {\n    display: inline;\n}\n\n.course ul li:not(:last-of-type):after {\n    content: \", \";\n    white-space: pre;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n</style>\n\n<h2>Vakkenoverzicht</h2>\n\n<div class=\"navigator\">\n    <img src=\"/media/icons/arrow-left.svg\" alt=\"arrow-left\"></img>\n    <span></span>\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</div>\n\n<div id=\"course-overview\"></div>\n\n<a target=\"_blank\" href=\"https://sis.hva.nl/\">Volledig overzicht\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class CourseOverview extends HTMLElement {\n        constructor() {\n            // Setup\n            super()\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            // Variables\n            this.courseContainer = this.shadowRoot.querySelector('#course-overview')\n            this.courseMoment = this.shadowRoot.querySelector('.navigator span')\n            this.arrowPrevious = this.shadowRoot.querySelector('.navigator img:first-of-type')\n            this.arrowNext = this.shadowRoot.querySelector('.navigator img:last-of-type')\n            this.yearIndex = 2\n            this.quarterIndex = 3\n\n            // Data\n            this.data = this.getData().then(json => {\n                this.navigateHandler()\n\n                const data = json[this.yearIndex].quarters[this.quarterIndex].courses\n                this.updateCourseOverview(data)\n\n                this.data = json\n            })\n\n            // EventListeners\n            this.arrowPrevious.addEventListener('click', () => this.navigate('previous'))\n            this.arrowNext.addEventListener('click', () => this.navigate('next'))\n        }\n\n        updateNavigator() {\n            this.courseMoment.textContent = `Jaar ${this.yearIndex + 1} - Blok ${this.quarterIndex + 1}`\n        }\n\n        updateCourseOverview(courses) {\n            this.courseContainer.textContent = \"\"\n            this.updateNavigator()\n\n            courses.forEach(course => {\n                const div = document.createElement('div')\n                div.classList.add('course')\n\n                const courseName = document.createElement('p')\n                courseName.textContent = course.course\n                div.append(courseName)\n\n                const list = document.createElement('ul')\n                course.lecturers.forEach(lecturer => {\n                    const teacher = document.createElement('li')\n                    lecturer === \"\" ? teacher.textContent = 'Geen specifieke docent' : teacher.textContent = lecturer\n                    list.append(teacher)\n                })\n                div.append(list)\n\n                this.courseContainer.append(div)\n            })\n        }\n\n        navigate(direction) {\n            if (direction === 'previous') {\n                if (this.quarterIndex > 0) {\n                    this.quarterIndex--\n                } else if (this.quarterIndex === 0 && this.yearIndex > 0) {\n                    this.quarterIndex = 3\n                    this.yearIndex--\n                }\n            }\n\n            if (direction === 'next') {\n                if (this.quarterIndex < 3) {\n                    this.quarterIndex++\n                } else if (this.quarterIndex === 3 && this.yearIndex < 3) {\n                    this.quarterIndex = 0\n                    this.yearIndex++\n                }\n            }\n\n            this.navigateHandler()\n\n            const data = this.data[this.yearIndex].quarters[this.quarterIndex].courses\n            this.updateCourseOverview(data)\n        }\n\n        navigateHandler() {\n            this.yearIndex === 0 && this.quarterIndex === 0 ?\n                this.arrowPrevious.classList.add('disabled') : this.arrowPrevious.classList.remove('disabled')\n\n            this.yearIndex === 3 && this.quarterIndex === 3 ?\n                this.arrowNext.classList.add('disabled') : this.arrowNext.classList.remove('disabled')\n        }\n\n        // Helpers\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/courseoverview', options).then(res => res.json())\n        }\n    }\n\n    customElements.define('course-overview', CourseOverview)\n}","export { init as WC_scheduleWidget }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\n\np {\n\tmargin: 0;\n}\n\n.navigator {\n    background-color: #DDDDDD;\n    padding: 5px 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color: #25167A;\n    font-size: 16px;\n}\n\n.navigator span  {\n    cursor: default;\n}\n\n.navigator img {\n    padding: 10px;\n}\n\n.navigator img:not(.disabled) {\n    cursor: pointer;\n}\n\n.navigator img.disabled {\n    pointer-events: none;\n    opacity: .5;\n}\n\n.schedule-course {\n    display: grid;\n    grid-template-columns: auto 1fr;\n    grid-column-gap: 20px;\n    grid-row-gap: 5px;\n    padding: 15px 20px;\n    border-bottom: 1px solid #DDDDDD;\n}\n\n.schedule-course p:first-of-type,\n.schedule-course p:nth-of-type(3) {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n</style>\n<h2>Dagrooster</h2>\n<div class=\"navigator\">\n\t<img src=\"/media/icons/arrow-left.svg\" alt=\"arrow-left\" class=\"disabled\"></img>\n\t<span></span>\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</div>\n<div id=\"schedules-container\"></div>\n<a target=\"_blank\" href=\"https://rooster.hva.nl/schedule\">Volledig rooster\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class schedule extends HTMLElement {\n        constructor() {\n            super()\n\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.data = this.getData()\n                .then(json => {\n                    this.updateSchedule(json[0])\n                    this.data = json\n                })\n\n            this.navigator = this.shadowRoot.querySelector('.navigator')\n            this.arrowPrevious = this.navigator.querySelector('img:first-of-type')\n            this.arrowNext = this.navigator.querySelector('img:last-of-type')\n\n            this.arrowNext.addEventListener('click', () => this.navigate('next'))\n            this.arrowPrevious.addEventListener('click', () => this.navigate('previous'))\n            this.index = 0\n        }\n\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/schedule', options).then(res => res.json())\n        }\n\n        updateSchedule(data) {\n            const schedulesContainer = this.shadowRoot.getElementById('schedules-container')\n            schedulesContainer.textContent = \"\"\n\n            this.navigator.querySelector('span').textContent = `${data.day} - ${data.month} - ${data.year}`\n\n            data.schedules.forEach(schedule => {\n                const classRoom = schedule._embedded ? schedule._embedded.rooms[0].abbreviation : \"Geen lokaal\"\n\n                const div = document.createElement('div')\n                div.classList.add('schedule-course')\n                schedulesContainer.appendChild(div)\n\n                const time = document.createElement('p')\n                time.textContent = `${schedule.startDateTime.time} - ${schedule.endDateTime.time}`\n                div.appendChild(time)\n\n                const name = document.createElement('p')\n                name.textContent = schedule._links.courses[0].title\n                div.appendChild(name)\n\n                const room = document.createElement('p')\n                room.textContent = classRoom\n                div.appendChild(room)\n\n                const teacher = document.createElement('p')\n                teacher.textContent = schedule._links.lecturers[0].title\n                div.appendChild(teacher)\n            })\n        }\n\n        navigate(direction) {\n            direction === 'previous' ? this.index-- : this.index++\n\n            this.index === 0 ? this.arrowPrevious.classList.add('disabled') : this.arrowPrevious.classList.remove('disabled')\n            this.index === 4 ? this.arrowNext.classList.add('disabled') : this.arrowNext.classList.remove('disabled')\n\n            this.updateSchedule(this.data[this.index])\n        }\n    }\n\n    window.customElements.define('schedule-widget', schedule)\n}","export { init as WC_studyprogress }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n    font-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n    font-weight: lighter;\n    line-height: 1.1;\n}\n\np {\n    margin: 0;\n}\n\n#recent-results div {\n    display: grid;\n    grid-template-columns: auto 1fr auto;\n    grid-template-rows: 1fr auto;\n}\n\n#recent-results div:not(:last-of-type) {\n    margin-bottom: 15px;\n}\n\n#recent-results span {\n    display: block;\n    grid-column: 1 / 2;\n    grid-row: 1 / 3;\n    width: 5px;\n    height: 100%;\n}\n\nspan.success {\n    background-color: #25167A;\n}\n\nspan.failed {\n    background-color: #DDDDDD;\n}\n\n#recent-results p:nth-of-type(1) {\n    grid-column: 2 / 3;\n    padding: 4px 0px 0px 10px;\n}\n\n#recent-results p:nth-of-type(2) {\n    grid-row: 1 / 3;\n    grid-column: 3 / 4;\n    align-self: center;\n}\n\n#recent-results p:nth-of-type(3) {\n    padding: 0px 0px 4px 10px;\n    font-size: 14px;\n    color: #666666;\n}\n\n#recent-results p:nth-of-type(1),\n#recent-results p:nth-of-type(2) {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n\n}\n\n#recent-progress {\n    margin-top: 30px;\n}\n\n#recent-progress div {\n    display: grid;\n    grid-template-columns: auto 1fr auto;\n}\n\n#recent-progress div span {\n        display: block;\n        width: 5px;\n}\n\n#recent-progress p {\n    padding: 5px 0px;\n}\n\n#recent-progress p:first-of-type {\n    padding-left: 10px;\n}\n\n#recent-progress .current-year {\n    background-color: #DDDDDD;\n}\n\n#recent-progress .current-year span {\n    background-color: #25167A;\n}\n\n#recent-progress .current-year p {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n\n#recent-progress .current-year p:last-of-type {\n    padding-right: 10px;\n}\n\n#link-container {\n    display: flex;\n    justify-content: space-between;\n}\n\n#link-container a {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\n#link-container a:hover,\n#link-container a:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\n#link-container a img {\n    height: 12px;\n    margin-left: 20px;\n}\n\n@media only screen and (max-width: 450px) {\n    #link-container {\n        flex-direction: column;\n    }\n\n    #link-container a:last-of-type {\n        margin-top: 10px;\n    }\n}\n</style>\n\n<h2>Studieresultaten en -voortgang</h2>\n\n<div id=\"recent-results\"></div>\n<div id=\"recent-progress\"></div>\n\n<div id=\"link-container\">\n<a target=\"_blank\" href=\"https://sis.hva.nl:8011/psc/S2PRD/EMPLOYEE/SA/c/SNS_MENU_FLD.SNS_SS_STD_RES_FL.GBL\">Jouw resultaten\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n\n<a target=\"_blank\" href=\"https://sis.hva.nl:8011/psc/S2PRD/EMPLOYEE/SA/c/SNS_MENU_FLD.SNS_SS_FLD_ADB.GBL\">Jouw studievoortgang\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n</div>\n`\n\nfunction init() {\n    class StudyProgress extends HTMLElement {\n        constructor() {\n            // Setup\n            super()\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.getData().then(json => {\n                const [results, progress] = json\n\n                this.resultComponent(results)\n                this.progressComponent(progress)\n            })\n\n            this.resultsContainer = this.shadowRoot.querySelector('#recent-results')\n            this.progressContainer = this.shadowRoot.querySelector('#recent-progress')\n        }\n\n        progressComponent(results) {\n            results.forEach(result => {\n                const div = document.createElement('div')\n                if (result.currentYear) {\n                    div.classList.add('current-year')\n                }\n\n                const template = `\n                <span></span>\n                <p>Leerjaar ${result.studyYear}</p>\n                <p>${result.studypoints.achieved}/${result.studypoints.available} studiepunten</p>`\n\n                // InsertAdjacentHtml\n                // Template engine uitzoeken voor Webcomponents\n\n                div.innerHTML = template\n                this.progressContainer.append(div)\n            })\n        }\n\n\n        resultComponent(results) {\n            results.forEach(result => {\n                // Parent container\n                const div = document.createElement('div')\n\n                let indicator\n                if (typeof result.grade === 'number' && result.grade >= 5.5 || result.grade === 'V') {\n                    indicator = `<span class=\"success\"></span>`\n                } else if (typeof result.grade === 'number' && result.grade < 5.5 || result.grade === '-' || result.grade === 'GR') {\n                    indicator = `<span class=\"failed\"></span>`\n                }\n\n                const template = `\n                ${indicator}\n                <p>${result._links.course.title}</p>\n                <p>${result.grade}</p>\n                <p>${result.fullDate}</p>\n                `\n\n                div.innerHTML = template\n                this.resultsContainer.append(div)\n            })\n        }\n\n        // Helpers\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/studyprogress', options).then(res => res.json())\n        }\n    }\n\n    customElements.define('study-progress', StudyProgress)\n}","import * as utils from '../modules/utils.mjs'\n\nexport { template as WC_urgentAnnouncement }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\n    div {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        padding: 16px;\n        background-color: #ECE7FA;\n        position: sticky;\n        top: 0;\n    }\n\n    div.hide {\n        position: absolute;\n        left: -9999px;\n    }\n\n    p {\n        margin: 0;\n        padding-right: 10px;\n    }\n\n    @media only screen and (max-width: 768px) {\n        div {\n            top: 60px;\n        }\n    }\n\n    img {\n        cursor: pointer;\n    }\n</style>\n<div class=\"hide\">\n    <p></p>\n    <img src=\"./media/icons/notification-exit.svg\" alt=\"hide notification\">\n</div>`\n\n\n\nclass urgentAnnouncement extends HTMLElement {\n\n    constructor() {\n        super()\n\n        this.attachShadow({ mode: 'open' })\n        this.shadowRoot.appendChild(template.content.cloneNode(true))\n        this.shadowRoot.querySelector('p').textContent = this.getAttribute('message')\n        this.shadowRoot.querySelector('img').addEventListener('click', () => {\n            this.hide()\n            this.store()\n        })\n    }\n\n    static get observedAttributes() {\n        return ['uid']\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue != newValue && newValue != \"\") {\n            const uid = this.getAttribute('uid')\n            if (utils.storageAvailable('localStorage')) {\n                const storedHistory = utils.getLocalStorage('read-history')\n                if (storedHistory) {\n                    if (!storedHistory.includes(uid)) {\n                        this.updateContent()\n                        this.show()\n                    }\n                } else {\n                    this.updateContent()\n                    this.show()\n                }\n            }\n        }\n    }\n\n    updateContent() {\n        this.shadowRoot.querySelector('p').textContent = this.getAttribute('message')\n    }\n\n    show() {\n        this.shadowRoot.querySelector('div').classList.remove('hide')\n        document.querySelector('main').classList.add('showsNotification')\n    }\n\n    hide() {\n        this.shadowRoot.querySelector('div').classList.add('hide')\n        document.querySelector('main').classList.remove('showsNotification')\n    }\n\n    store() {\n        if (utils.storageAvailable('localStorage')) {\n            const storedHistory = utils.getLocalStorage('read-history')\n            const readHistory = storedHistory ? storedHistory : []\n\n            readHistory.push(this.getAttribute('uid'))\n            utils.setLocalStorage('read-history', readHistory)\n        }\n    }\n}\n\nwindow.customElements.define('urgent-announcement', urgentAnnouncement)"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc29ydGFibGVqcy9Tb3J0YWJsZS5qcyIsInNyYy9qcy9pbmRleC5qcyIsInNyYy9qcy9tb2R1bGVzL2RyYWctYW5kLWRyb3AubWpzIiwic3JjL2pzL21vZHVsZXMvbm90aWZ5Lm1qcyIsInNyYy9qcy9tb2R1bGVzL3NlYXJjaC5tanMiLCJzcmMvanMvbW9kdWxlcy90b2dnbGVQcmVmZXJlbmNlcy5tanMiLCJzcmMvanMvbW9kdWxlcy91bnJlYWRBbm5vdW5jZW1lbnRzLm1qcyIsInNyYy9qcy9tb2R1bGVzL3V0aWxzLm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9hbm5vdW5jZW1lbnRzLm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9jb3Vyc2Utb3ZlcnZpZXcubWpzIiwic3JjL2pzL3dlYi1jb21wb25lbnRzL3NjaGVkdWxlLm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9zdHVkeS1wcm9ncmVzcy5tanMiLCJzcmMvanMvd2ViLWNvbXBvbmVudHMvdXJnZW50LWFubm91bmNlbWVudC5tanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LEdBQXpDLENBQTZDLG1CQUE3QztBQUNIOzs7MkJBRU07QUFDSCxXQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsQ0FBOEIsS0FBOUIsRUFBcUMsU0FBckMsQ0FBK0MsR0FBL0MsQ0FBbUQsTUFBbkQ7QUFDQSxNQUFBLFFBQVEsQ0FBQyxhQUFULENBQXVCLE1BQXZCLEVBQStCLFNBQS9CLENBQXlDLE1BQXpDLENBQWdELG1CQUFoRDtBQUNIOzs7NEJBRU87QUFDSixVQUFJLEtBQUssQ0FBQyxnQkFBTixDQUF1QixjQUF2QixDQUFKLEVBQTRDO0FBQ3hDLFlBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxlQUFOLENBQXNCLGNBQXRCLENBQXRCO0FBQ0EsWUFBTSxXQUFXLEdBQUcsYUFBYSxHQUFHLGFBQUgsR0FBbUIsRUFBcEQ7QUFFQSxRQUFBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLEtBQUssWUFBTCxDQUFrQixLQUFsQixDQUFqQjtBQUNBLFFBQUEsS0FBSyxDQUFDLGVBQU4sQ0FBc0IsY0FBdEIsRUFBc0MsV0FBdEM7QUFDSDtBQUNKOzs7d0JBNUMrQjtBQUM1QixhQUFPLENBQUMsS0FBRCxDQUFQO0FBQ0g7Ozs7aUNBaEI0QixXOztBQTZEakMsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsTUFBdEIsQ0FBNkIscUJBQTdCLEVBQW9ELGtCQUFwRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKiFcbiAqIFNvcnRhYmxlIDEuMTAuMlxuICogQGF1dGhvclx0UnViYVhhICAgPHRyYXNoQHJ1YmF4YS5vcmc+XG4gKiBAYXV0aG9yXHRvd2VubSAgICA8b3dlbjIzMzU1QGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLlNvcnRhYmxlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgICB2YXIga2V5LCBpO1xuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IFwiMS4xMC4yXCI7XG5cbiAgZnVuY3Rpb24gdXNlckFnZW50KHBhdHRlcm4pIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgICAgcmV0dXJuICEhXG4gICAgICAvKkBfX1BVUkVfXyovXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHBhdHRlcm4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBJRTExT3JMZXNzID0gdXNlckFnZW50KC8oPzpUcmlkZW50LipydlsgOl0/MTFcXC58bXNpZXxpZW1vYmlsZXxXaW5kb3dzIFBob25lKS9pKTtcbiAgdmFyIEVkZ2UgPSB1c2VyQWdlbnQoL0VkZ2UvaSk7XG4gIHZhciBGaXJlRm94ID0gdXNlckFnZW50KC9maXJlZm94L2kpO1xuICB2YXIgU2FmYXJpID0gdXNlckFnZW50KC9zYWZhcmkvaSkgJiYgIXVzZXJBZ2VudCgvY2hyb21lL2kpICYmICF1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG4gIHZhciBJT1MgPSB1c2VyQWdlbnQoL2lQKGFkfG9kfGhvbmUpL2kpO1xuICB2YXIgQ2hyb21lRm9yQW5kcm9pZCA9IHVzZXJBZ2VudCgvY2hyb21lL2kpICYmIHVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcblxuICB2YXIgY2FwdHVyZU1vZGUgPSB7XG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfTtcblxuICBmdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sICFJRTExT3JMZXNzICYmIGNhcHR1cmVNb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGZuKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sICFJRTExT3JMZXNzICYmIGNhcHR1cmVNb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoZXMoXG4gIC8qKkhUTUxFbGVtZW50Ki9cbiAgZWwsXG4gIC8qKlN0cmluZyovXG4gIHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICAgIHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMpIHtcbiAgICAgICAgICByZXR1cm4gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWwubXNNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsLndlYmtpdE1hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJlbnRPckhvc3QoZWwpIHtcbiAgICByZXR1cm4gZWwuaG9zdCAmJiBlbCAhPT0gZG9jdW1lbnQgJiYgZWwuaG9zdC5ub2RlVHlwZSA/IGVsLmhvc3QgOiBlbC5wYXJlbnROb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VzdChcbiAgLyoqSFRNTEVsZW1lbnQqL1xuICBlbCxcbiAgLyoqU3RyaW5nKi9cbiAgc2VsZWN0b3IsXG4gIC8qKkhUTUxFbGVtZW50Ki9cbiAgY3R4LCBpbmNsdWRlQ1RYKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgKHNlbGVjdG9yWzBdID09PSAnPicgPyBlbC5wYXJlbnROb2RlID09PSBjdHggJiYgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIDogbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB8fCBpbmNsdWRlQ1RYICYmIGVsID09PSBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwgPT09IGN0eCkgYnJlYWs7XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgIH0gd2hpbGUgKGVsID0gZ2V0UGFyZW50T3JIb3N0KGVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgUl9TUEFDRSA9IC9cXHMrL2c7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIHN0YXRlKSB7XG4gICAgaWYgKGVsICYmIG5hbWUpIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShSX1NQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjc3MoZWwsIHByb3AsIHZhbCkge1xuICAgIHZhciBzdHlsZSA9IGVsICYmIGVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICB2YWwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWwuY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3AgPT09IHZvaWQgMCA/IHZhbCA6IHZhbFtwcm9wXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHByb3AgaW4gc3R5bGUpICYmIHByb3AuaW5kZXhPZignd2Via2l0JykgPT09IC0xKSB7XG4gICAgICAgICAgcHJvcCA9ICctd2Via2l0LScgKyBwcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdHJpeChlbCwgc2VsZk9ubHkpIHtcbiAgICB2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcblxuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhcHBsaWVkVHJhbnNmb3JtcyA9IGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjc3MoZWwsICd0cmFuc2Zvcm0nKTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICAgIH0gd2hpbGUgKCFzZWxmT25seSAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeEZuID0gd2luZG93LkRPTU1hdHJpeCB8fCB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4IHx8IHdpbmRvdy5DU1NNYXRyaXggfHwgd2luZG93Lk1TQ1NTTWF0cml4O1xuICAgIC8qanNoaW50IC1XMDU2ICovXG5cbiAgICByZXR1cm4gbWF0cml4Rm4gJiYgbmV3IG1hdHJpeEZuKGFwcGxpZWRUcmFuc2Zvcm1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmQoY3R4LCB0YWdOYW1lLCBpdGVyYXRvcikge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG4gPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgaXRlcmF0b3IobGlzdFtpXSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgICBpZiAoc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIFwiYm91bmRpbmcgY2xpZW50IHJlY3RcIiBvZiBnaXZlbiBlbGVtZW50XHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgICAgICAgICAgICAgICAgICBUaGUgZWxlbWVudCB3aG9zZSBib3VuZGluZ0NsaWVudFJlY3QgaXMgd2FudGVkXHJcbiAgICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyBibG9jayBvZiAoaW5jbHVkaW5nKSB0aGUgY29udGFpbmVyXHJcbiAgICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmUgcGFyZW50IG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWllbnJcclxuICAgKiBAcGFyYW0gIHtbQm9vbGVhbl19IHVuZG9TY2FsZSAgICAgICAgICAgICAgICAgIFdoZXRoZXIgdGhlIGNvbnRhaW5lcidzIHNjYWxlKCkgc2hvdWxkIGJlIHVuZG9uZVxyXG4gICAqIEBwYXJhbSAge1tIVE1MRWxlbWVudF19IGNvbnRhaW5lciAgICAgICAgICAgICAgVGhlIHBhcmVudCB0aGUgZWxlbWVudCB3aWxsIGJlIHBsYWNlZCBpblxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJvdW5kaW5nQ2xpZW50UmVjdCBvZiBlbCwgd2l0aCBzcGVjaWZpZWQgYWRqdXN0bWVudHNcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJlY3QoZWwsIHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2ssIHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQsIHVuZG9TY2FsZSwgY29udGFpbmVyKSB7XG4gICAgaWYgKCFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwgIT09IHdpbmRvdykgcmV0dXJuO1xuICAgIHZhciBlbFJlY3QsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgaGVpZ2h0LCB3aWR0aDtcblxuICAgIGlmIChlbCAhPT0gd2luZG93ICYmIGVsICE9PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICAgIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdG9wID0gZWxSZWN0LnRvcDtcbiAgICAgIGxlZnQgPSBlbFJlY3QubGVmdDtcbiAgICAgIGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XG4gICAgICByaWdodCA9IGVsUmVjdC5yaWdodDtcbiAgICAgIGhlaWdodCA9IGVsUmVjdC5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gMDtcbiAgICAgIGxlZnQgPSAwO1xuICAgICAgYm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgcmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKChyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQpICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAgIC8vIEFkanVzdCBmb3IgdHJhbnNsYXRlKClcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBlbC5wYXJlbnROb2RlOyAvLyBzb2x2ZXMgIzExMjMgKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3OTUzODA2LzYwODgzMTIpXG4gICAgICAvLyBOb3QgbmVlZGVkIG9uIDw9IElFMTFcblxuICAgICAgaWYgKCFJRTExT3JMZXNzKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGNzcyhjb250YWluZXIsICd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgJiYgY3NzKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFNldCByZWxhdGl2ZSB0byBlZGdlcyBvZiBwYWRkaW5nIGJveCBvZiBjb250YWluZXJcblxuICAgICAgICAgICAgdG9wIC09IGNvbnRhaW5lclJlY3QudG9wICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci10b3Atd2lkdGgnKSk7XG4gICAgICAgICAgICBsZWZ0IC09IGNvbnRhaW5lclJlY3QubGVmdCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItbGVmdC13aWR0aCcpKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IHRvcCArIGVsUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICByaWdodCA9IGxlZnQgKyBlbFJlY3Qud2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgICAgIH0gd2hpbGUgKGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodW5kb1NjYWxlICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAgIC8vIEFkanVzdCBmb3Igc2NhbGUoKVxuICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGNvbnRhaW5lciB8fCBlbCksXG4gICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kO1xuXG4gICAgICBpZiAoZWxNYXRyaXgpIHtcbiAgICAgICAgdG9wIC89IHNjYWxlWTtcbiAgICAgICAgbGVmdCAvPSBzY2FsZVg7XG4gICAgICAgIHdpZHRoIC89IHNjYWxlWDtcbiAgICAgICAgaGVpZ2h0IC89IHNjYWxlWTtcbiAgICAgICAgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgICAgICByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICByaWdodDogcmlnaHQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgc2lkZSBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHBhc3QgYSBzaWRlIG9mIGl0cyBwYXJlbnRzXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbCAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvJ3Mgc2lkZSBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBpcyBpbiBxdWVzdGlvblxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgZWxTaWRlICAgICAgIFNpZGUgb2YgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgcGFyZW50U2lkZSAgIFNpZGUgb2YgdGhlIHBhcmVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgICAgICAgVGhlIHBhcmVudCBzY3JvbGwgZWxlbWVudCB0aGF0IHRoZSBlbCdzIHNpZGUgaXMgc2Nyb2xsZWQgcGFzdCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIGVsZW1lbnRcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzU2Nyb2xsZWRQYXN0KGVsLCBlbFNpZGUsIHBhcmVudFNpZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIHRydWUpLFxuICAgICAgICBlbFNpZGVWYWwgPSBnZXRSZWN0KGVsKVtlbFNpZGVdO1xuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHZhciBwYXJlbnRTaWRlVmFsID0gZ2V0UmVjdChwYXJlbnQpW3BhcmVudFNpZGVdLFxuICAgICAgICAgIHZpc2libGUgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJlbnRTaWRlID09PSAndG9wJyB8fCBwYXJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA+PSBwYXJlbnRTaWRlVmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA8PSBwYXJlbnRTaWRlVmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZpc2libGUpIHJldHVybiBwYXJlbnQ7XG4gICAgICBpZiAocGFyZW50ID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIGJyZWFrO1xuICAgICAgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocGFyZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldHMgbnRoIGNoaWxkIG9mIGVsLCBpZ25vcmluZyBoaWRkZW4gY2hpbGRyZW4sIHNvcnRhYmxlJ3MgZWxlbWVudHMgKGRvZXMgbm90IGlnbm9yZSBjbG9uZSBpZiBpdCdzIHZpc2libGUpXHJcbiAgICogYW5kIG5vbi1kcmFnZ2FibGUgZWxlbWVudHNcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgVGhlIHBhcmVudCBlbGVtZW50XHJcbiAgICogQHBhcmFtICB7TnVtYmVyfSBjaGlsZE51bSAgICAgIFRoZSBpbmRleCBvZiB0aGUgY2hpbGRcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgICAgICAgUGFyZW50IFNvcnRhYmxlJ3Mgb3B0aW9uc1xyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgY2hpbGQgYXQgaW5kZXggY2hpbGROdW0sIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRDaGlsZChlbCwgY2hpbGROdW0sIG9wdGlvbnMpIHtcbiAgICB2YXIgY3VycmVudENoaWxkID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cbiAgICB3aGlsZSAoaSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZ2hvc3QgJiYgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmRyYWdnZWQgJiYgY2xvc2VzdChjaGlsZHJlbltpXSwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGlsZCA9PT0gY2hpbGROdW0pIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50Q2hpbGQrKztcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIGVsLCBpZ25vcmluZyBnaG9zdEVsIG9yIGludmlzaWJsZSBlbGVtZW50cyAoY2xvbmVzKVxyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxyXG4gICAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvciAgICBBbnkgb3RoZXIgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaWdub3JlZFxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgbGFzdCBjaGlsZCwgaWdub3JpbmcgZ2hvc3RFbFxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGFzdENoaWxkKGVsLCBzZWxlY3Rvcikge1xuICAgIHZhciBsYXN0ID0gZWwubGFzdEVsZW1lbnRDaGlsZDtcblxuICAgIHdoaWxlIChsYXN0ICYmIChsYXN0ID09PSBTb3J0YWJsZS5naG9zdCB8fCBjc3MobGFzdCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNlbGVjdG9yICYmICFtYXRjaGVzKGxhc3QsIHNlbGVjdG9yKSkpIHtcbiAgICAgIGxhc3QgPSBsYXN0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3QgfHwgbnVsbDtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50IGZvciBhIHNlbGVjdGVkIHNldCBvZlxyXG4gICAqIGVsZW1lbnRzXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAgICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5kZXgoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG5cbiAgICB3aGlsZSAoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBpZiAoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1RFTVBMQVRFJyAmJiBlbCAhPT0gU29ydGFibGUuY2xvbmUgJiYgKCFzZWxlY3RvciB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQsIGFkZGVkIHdpdGggYWxsIHRoZSBzY3JvbGwgb2Zmc2V0cyBvZiBwYXJlbnQgZWxlbWVudHMuXHJcbiAgICogVGhlIHZhbHVlIGlzIHJldHVybmVkIGluIHJlYWwgcGl4ZWxzLlxyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxyXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBPZmZzZXRzIGluIHRoZSBmb3JtYXQgb2YgW2xlZnQsIHRvcF1cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGVsKSB7XG4gICAgdmFyIG9mZnNldExlZnQgPSAwLFxuICAgICAgICBvZmZzZXRUb3AgPSAwLFxuICAgICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoZWwpLFxuICAgICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXguYSxcbiAgICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4LmQ7XG4gICAgICAgIG9mZnNldExlZnQgKz0gZWwuc2Nyb2xsTGVmdCAqIHNjYWxlWDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IGVsLnNjcm9sbFRvcCAqIHNjYWxlWTtcbiAgICAgIH0gd2hpbGUgKGVsICE9PSB3aW5TY3JvbGxlciAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvZmZzZXRMZWZ0LCBvZmZzZXRUb3BdO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBvYmplY3Qgd2l0aGluIHRoZSBnaXZlbiBhcnJheVxyXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnIgICBBcnJheSB0aGF0IG1heSBvciBtYXkgbm90IGhvbGQgdGhlIG9iamVjdFxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqICBBbiBvYmplY3QgdGhhdCBoYXMgYSBrZXktdmFsdWUgcGFpciB1bmlxdWUgdG8gYW5kIGlkZW50aWNhbCB0byBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gZmluZFxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICBUaGUgaW5kZXggb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXksIG9yIC0xXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbmRleE9mT2JqZWN0KGFyciwgb2JqKSB7XG4gICAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICAgIGlmICghYXJyLmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgb2JqW2tleV0gPT09IGFycltpXVtrZXldKSByZXR1cm4gTnVtYmVyKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCBpbmNsdWRlU2VsZikge1xuICAgIC8vIHNraXAgdG8gd2luZG93XG4gICAgaWYgKCFlbCB8fCAhZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgIHZhciBlbGVtID0gZWw7XG4gICAgdmFyIGdvdFNlbGYgPSBmYWxzZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZ2V0IGVsZW0gY3NzIGlmIGl0IGlzbid0IGV2ZW4gb3ZlcmZsb3dpbmcgaW4gdGhlIGZpcnN0IHBsYWNlIChwZXJmb3JtYW5jZSlcbiAgICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBlbGVtQ1NTID0gY3NzKGVsZW0pO1xuXG4gICAgICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCAmJiAoZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dYID09ICdzY3JvbGwnKSB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0ICYmIChlbGVtQ1NTLm92ZXJmbG93WSA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ3Njcm9sbCcpKSB7XG4gICAgICAgICAgaWYgKCFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgIGlmIChnb3RTZWxmIHx8IGluY2x1ZGVTZWxmKSByZXR1cm4gZWxlbTtcbiAgICAgICAgICBnb3RTZWxmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGRzdCwgc3JjKSB7XG4gICAgaWYgKGRzdCAmJiBzcmMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlY3RFcXVhbChyZWN0MSwgcmVjdDIpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZWN0MS50b3ApID09PSBNYXRoLnJvdW5kKHJlY3QyLnRvcCkgJiYgTWF0aC5yb3VuZChyZWN0MS5sZWZ0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5sZWZ0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLmhlaWdodCkgPT09IE1hdGgucm91bmQocmVjdDIuaGVpZ2h0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLndpZHRoKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi53aWR0aCk7XG4gIH1cblxuICB2YXIgX3Rocm90dGxlVGltZW91dDtcblxuICBmdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhyb3R0bGVUaW1lb3V0KSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoX3RoaXMsIGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xuICAgICAgICB9LCBtcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbFRocm90dGxlKCkge1xuICAgIGNsZWFyVGltZW91dChfdGhyb3R0bGVUaW1lb3V0KTtcbiAgICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsQnkoZWwsIHgsIHkpIHtcbiAgICBlbC5zY3JvbGxMZWZ0ICs9IHg7XG4gICAgZWwuc2Nyb2xsVG9wICs9IHk7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZShlbCkge1xuICAgIHZhciBQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG4gICAgdmFyICQgPSB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0bztcblxuICAgIGlmIChQb2x5bWVyICYmIFBvbHltZXIuZG9tKSB7XG4gICAgICByZXR1cm4gUG9seW1lci5kb20oZWwpLmNsb25lTm9kZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKCQpIHtcbiAgICAgIHJldHVybiAkKGVsKS5jbG9uZSh0cnVlKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRSZWN0KGVsLCByZWN0KSB7XG4gICAgY3NzKGVsLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICBjc3MoZWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgY3NzKGVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gICAgY3NzKGVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICBjc3MoZWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnNldFJlY3QoZWwpIHtcbiAgICBjc3MoZWwsICdwb3NpdGlvbicsICcnKTtcbiAgICBjc3MoZWwsICd0b3AnLCAnJyk7XG4gICAgY3NzKGVsLCAnbGVmdCcsICcnKTtcbiAgICBjc3MoZWwsICd3aWR0aCcsICcnKTtcbiAgICBjc3MoZWwsICdoZWlnaHQnLCAnJyk7XG4gIH1cblxuICB2YXIgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSB7XG4gICAgdmFyIGFuaW1hdGlvblN0YXRlcyA9IFtdLFxuICAgICAgICBhbmltYXRpb25DYWxsYmFja0lkO1xuICAgIHJldHVybiB7XG4gICAgICBjYXB0dXJlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGNhcHR1cmVBbmltYXRpb25TdGF0ZSgpIHtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikgcmV0dXJuO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGRyZW4pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGlmIChjc3MoY2hpbGQsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBjaGlsZCA9PT0gU29ydGFibGUuZ2hvc3QpIHJldHVybjtcbiAgICAgICAgICBhbmltYXRpb25TdGF0ZXMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGNoaWxkLFxuICAgICAgICAgICAgcmVjdDogZ2V0UmVjdChjaGlsZClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBmcm9tUmVjdCA9IF9vYmplY3RTcHJlYWQoe30sIGFuaW1hdGlvblN0YXRlc1thbmltYXRpb25TdGF0ZXMubGVuZ3RoIC0gMV0ucmVjdCk7IC8vIElmIGFuaW1hdGluZzogY29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cblxuXG4gICAgICAgICAgaWYgKGNoaWxkLnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGNoaWxkTWF0cml4ID0gbWF0cml4KGNoaWxkLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkTWF0cml4KSB7XG4gICAgICAgICAgICAgIGZyb21SZWN0LnRvcCAtPSBjaGlsZE1hdHJpeC5mO1xuICAgICAgICAgICAgICBmcm9tUmVjdC5sZWZ0IC09IGNoaWxkTWF0cml4LmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWRkQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGFkZEFuaW1hdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gcmVtb3ZlQW5pbWF0aW9uU3RhdGUodGFyZ2V0KSB7XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5zcGxpY2UoaW5kZXhPZk9iamVjdChhbmltYXRpb25TdGF0ZXMsIHtcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICB9KSwgMSk7XG4gICAgICB9LFxuICAgICAgYW5pbWF0ZUFsbDogZnVuY3Rpb24gYW5pbWF0ZUFsbChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25DYWxsYmFja0lkKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmltYXRpbmcgPSBmYWxzZSxcbiAgICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICAgIHRhcmdldCA9IHN0YXRlLnRhcmdldCxcbiAgICAgICAgICAgICAgZnJvbVJlY3QgPSB0YXJnZXQuZnJvbVJlY3QsXG4gICAgICAgICAgICAgIHRvUmVjdCA9IGdldFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgICAgcHJldkZyb21SZWN0ID0gdGFyZ2V0LnByZXZGcm9tUmVjdCxcbiAgICAgICAgICAgICAgcHJldlRvUmVjdCA9IHRhcmdldC5wcmV2VG9SZWN0LFxuICAgICAgICAgICAgICBhbmltYXRpbmdSZWN0ID0gc3RhdGUucmVjdCxcbiAgICAgICAgICAgICAgdGFyZ2V0TWF0cml4ID0gbWF0cml4KHRhcmdldCwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgICAgICAvLyBDb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICAgICAgdG9SZWN0LnRvcCAtPSB0YXJnZXRNYXRyaXguZjtcbiAgICAgICAgICAgIHRvUmVjdC5sZWZ0IC09IHRhcmdldE1hdHJpeC5lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldC50b1JlY3QgPSB0b1JlY3Q7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gQ291bGQgYWxzbyBjaGVjayBpZiBhbmltYXRpbmdSZWN0IGlzIGJldHdlZW4gZnJvbVJlY3QgYW5kIHRvUmVjdFxuICAgICAgICAgICAgaWYgKGlzUmVjdEVxdWFsKHByZXZGcm9tUmVjdCwgdG9SZWN0KSAmJiAhaXNSZWN0RXF1YWwoZnJvbVJlY3QsIHRvUmVjdCkgJiYgLy8gTWFrZSBzdXJlIGFuaW1hdGluZ1JlY3QgaXMgb24gbGluZSBiZXR3ZWVuIHRvUmVjdCAmIGZyb21SZWN0XG4gICAgICAgICAgICAoYW5pbWF0aW5nUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChhbmltYXRpbmdSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgPT09IChmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wKSAvIChmcm9tUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHJldHVybmluZyB0byBzYW1lIHBsYWNlIGFzIHN0YXJ0ZWQgZnJvbSBhbmltYXRpb24gYW5kIG9uIHNhbWUgYXhpc1xuICAgICAgICAgICAgICB0aW1lID0gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgcHJldkZyb21SZWN0LCBwcmV2VG9SZWN0LCBfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGlmIGZyb21SZWN0ICE9IHRvUmVjdDogYW5pbWF0ZVxuXG5cbiAgICAgICAgICBpZiAoIWlzUmVjdEVxdWFsKHRvUmVjdCwgZnJvbVJlY3QpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gZnJvbVJlY3Q7XG4gICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZSh0YXJnZXQsIGFuaW1hdGluZ1JlY3QsIHRvUmVjdCwgdGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICBhbmltYXRpb25UaW1lID0gTWF0aC5tYXgoYW5pbWF0aW9uVGltZSwgdGltZSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIpO1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgdGFyZ2V0LmZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgdGFyZ2V0LnByZXZUb1JlY3QgPSBudWxsO1xuICAgICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgICAgdGFyZ2V0LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IHRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuXG4gICAgICAgIGlmICghYW5pbWF0aW5nKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb25DYWxsYmFja0lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICAgIH0sIGFuaW1hdGlvblRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgICB9LFxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSh0YXJnZXQsIGN1cnJlbnRSZWN0LCB0b1JlY3QsIGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KHRoaXMuZWwpLFxuICAgICAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gKGN1cnJlbnRSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gKGN1cnJlbnRSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKHNjYWxlWSB8fCAxKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9ICEhdHJhbnNsYXRlWDtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWSA9ICEhdHJhbnNsYXRlWTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKCcgKyB0cmFuc2xhdGVYICsgJ3B4LCcgKyB0cmFuc2xhdGVZICsgJ3B4LDApJyk7XG4gICAgICAgICAgcmVwYWludCh0YXJnZXQpOyAvLyByZXBhaW50XG5cbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcbiAgICAgICAgICB0eXBlb2YgdGFyZ2V0LmFuaW1hdGVkID09PSAnbnVtYmVyJyAmJiBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcbiAgICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gZmFsc2U7XG4gICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGFpbnQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5vZmZzZXRXaWR0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIGZyb21SZWN0LCB0b1JlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG4gIH1cblxuICB2YXIgcGx1Z2lucyA9IFtdO1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxuICB9O1xuICB2YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQocGx1Z2luKSB7XG4gICAgICAvLyBTZXQgZGVmYXVsdCBzdGF0aWMgcHJvcGVydGllc1xuICAgICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmICEob3B0aW9uIGluIHBsdWdpbikpIHtcbiAgICAgICAgICBwbHVnaW5bb3B0aW9uXSA9IGRlZmF1bHRzW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgfSxcbiAgICBwbHVnaW5FdmVudDogZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSwgZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmV2ZW50Q2FuY2VsZWQgPSBmYWxzZTtcblxuICAgICAgZXZ0LmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZXZlbnRDYW5jZWxlZCA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXZlbnROYW1lR2xvYmFsID0gZXZlbnROYW1lICsgJ0dsb2JhbCc7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBGaXJlIGdsb2JhbCBldmVudHMgaWYgaXQgZXhpc3RzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgICBpZiAoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0pIHtcbiAgICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lR2xvYmFsXShfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICAgIH0sIGV2dCkpO1xuICAgICAgICB9IC8vIE9ubHkgZmlyZSBwbHVnaW4gZXZlbnQgaWYgcGx1Z2luIGlzIGVuYWJsZWQgaW4gdGhpcyBzb3J0YWJsZSxcbiAgICAgICAgLy8gYW5kIHBsdWdpbiBoYXMgZXZlbnQgZGVmaW5lZFxuXG5cbiAgICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luLnBsdWdpbk5hbWVdICYmIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKSB7XG4gICAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0oX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgICB9LCBldnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbml0aWFsaXplUGx1Z2luczogZnVuY3Rpb24gaW5pdGlhbGl6ZVBsdWdpbnMoc29ydGFibGUsIGVsLCBkZWZhdWx0cywgb3B0aW9ucykge1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZTtcbiAgICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zW3BsdWdpbk5hbWVdICYmICFwbHVnaW4uaW5pdGlhbGl6ZUJ5RGVmYXVsdCkgcmV0dXJuO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBuZXcgcGx1Z2luKHNvcnRhYmxlLCBlbCwgc29ydGFibGUub3B0aW9ucyk7XG4gICAgICAgIGluaXRpYWxpemVkLnNvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICAgIGluaXRpYWxpemVkLm9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zO1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW5OYW1lXSA9IGluaXRpYWxpemVkOyAvLyBBZGQgZGVmYXVsdCBvcHRpb25zIGZyb20gcGx1Z2luXG5cbiAgICAgICAgX2V4dGVuZHMoZGVmYXVsdHMsIGluaXRpYWxpemVkLmRlZmF1bHRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBvcHRpb24gaW4gc29ydGFibGUub3B0aW9ucykge1xuICAgICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkgY29udGludWU7XG4gICAgICAgIHZhciBtb2RpZmllZCA9IHRoaXMubW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBvcHRpb24sIHNvcnRhYmxlLm9wdGlvbnNbb3B0aW9uXSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0gPSBtb2RpZmllZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBnZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpIHtcbiAgICAgIHZhciBldmVudFByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmV2ZW50UHJvcGVydGllcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICAgIF9leHRlbmRzKGV2ZW50UHJvcGVydGllcywgcGx1Z2luLmV2ZW50UHJvcGVydGllcy5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgbmFtZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXZlbnRQcm9wZXJ0aWVzO1xuICAgIH0sXG4gICAgbW9kaWZ5T3B0aW9uOiBmdW5jdGlvbiBtb2RpZnlPcHRpb24oc29ydGFibGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbW9kaWZpZWRWYWx1ZTtcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIC8vIFBsdWdpbiBtdXN0IGV4aXN0IG9uIHRoZSBTb3J0YWJsZVxuICAgICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBJZiBzdGF0aWMgb3B0aW9uIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBvcHRpb24sIGNhbGwgaW4gdGhlIGNvbnRleHQgb2YgdGhlIFNvcnRhYmxlJ3MgaW5zdGFuY2Ugb2YgdGhpcyBwbHVnaW5cblxuICAgICAgICBpZiAocGx1Z2luLm9wdGlvbkxpc3RlbmVycyAmJiB0eXBlb2YgcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1vZGlmaWVkVmFsdWUgPSBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1vZGlmaWVkVmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoX3JlZikge1xuICAgIHZhciBzb3J0YWJsZSA9IF9yZWYuc29ydGFibGUsXG4gICAgICAgIHJvb3RFbCA9IF9yZWYucm9vdEVsLFxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICB0YXJnZXRFbCA9IF9yZWYudGFyZ2V0RWwsXG4gICAgICAgIGNsb25lRWwgPSBfcmVmLmNsb25lRWwsXG4gICAgICAgIHRvRWwgPSBfcmVmLnRvRWwsXG4gICAgICAgIGZyb21FbCA9IF9yZWYuZnJvbUVsLFxuICAgICAgICBvbGRJbmRleCA9IF9yZWYub2xkSW5kZXgsXG4gICAgICAgIG5ld0luZGV4ID0gX3JlZi5uZXdJbmRleCxcbiAgICAgICAgb2xkRHJhZ2dhYmxlSW5kZXggPSBfcmVmLm9sZERyYWdnYWJsZUluZGV4LFxuICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IF9yZWYubmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZi5wdXRTb3J0YWJsZSxcbiAgICAgICAgZXh0cmFFdmVudFByb3BlcnRpZXMgPSBfcmVmLmV4dHJhRXZlbnRQcm9wZXJ0aWVzO1xuICAgIHNvcnRhYmxlID0gc29ydGFibGUgfHwgcm9vdEVsICYmIHJvb3RFbFtleHBhbmRvXTtcbiAgICBpZiAoIXNvcnRhYmxlKSByZXR1cm47XG4gICAgdmFyIGV2dCxcbiAgICAgICAgb3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXG4gICAgICAgIG9uTmFtZSA9ICdvbicgKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7IC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXG5cbiAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgIH1cblxuICAgIGV2dC50byA9IHRvRWwgfHwgcm9vdEVsO1xuICAgIGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcbiAgICBldnQuaXRlbSA9IHRhcmdldEVsIHx8IHJvb3RFbDtcbiAgICBldnQuY2xvbmUgPSBjbG9uZUVsO1xuICAgIGV2dC5vbGRJbmRleCA9IG9sZEluZGV4O1xuICAgIGV2dC5uZXdJbmRleCA9IG5ld0luZGV4O1xuICAgIGV2dC5vbGREcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgIGV2dC5uZXdEcmFnZ2FibGVJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4O1xuICAgIGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICBldnQucHVsbE1vZGUgPSBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGFsbEV2ZW50UHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQoe30sIGV4dHJhRXZlbnRQcm9wZXJ0aWVzLCBQbHVnaW5NYW5hZ2VyLmdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkpO1xuXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGFsbEV2ZW50UHJvcGVydGllcykge1xuICAgICAgZXZ0W29wdGlvbl0gPSBhbGxFdmVudFByb3BlcnRpZXNbb3B0aW9uXTtcbiAgICB9XG5cbiAgICBpZiAocm9vdEVsKSB7XG4gICAgICByb290RWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zW29uTmFtZV0pIHtcbiAgICAgIG9wdGlvbnNbb25OYW1lXS5jYWxsKHNvcnRhYmxlLCBldnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbHVnaW5FdmVudCA9IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLmV2dCxcbiAgICAgICAgZGF0YSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJldnRcIl0pO1xuXG4gICAgUGx1Z2luTWFuYWdlci5wbHVnaW5FdmVudC5iaW5kKFNvcnRhYmxlKShldmVudE5hbWUsIHNvcnRhYmxlLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgICAgcGFyZW50RWw6IHBhcmVudEVsLFxuICAgICAgZ2hvc3RFbDogZ2hvc3RFbCxcbiAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgbmV4dEVsOiBuZXh0RWwsXG4gICAgICBsYXN0RG93bkVsOiBsYXN0RG93bkVsLFxuICAgICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICAgIGNsb25lSGlkZGVuOiBjbG9uZUhpZGRlbixcbiAgICAgIGRyYWdTdGFydGVkOiBtb3ZlZCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZSxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlOiBTb3J0YWJsZS5hY3RpdmUsXG4gICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0OiBfaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQ6IF91bmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICAgIGNsb25lTm93SGlkZGVuOiBmdW5jdGlvbiBjbG9uZU5vd0hpZGRlbigpIHtcbiAgICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIGNsb25lTm93U2hvd246IGZ1bmN0aW9uIGNsb25lTm93U2hvd24oKSB7XG4gICAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaFNvcnRhYmxlRXZlbnQobmFtZSkge1xuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBkYXRhKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQoaW5mbykge1xuICAgIGRpc3BhdGNoRXZlbnQoX29iamVjdFNwcmVhZCh7XG4gICAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgb2xkSW5kZXg6IG9sZEluZGV4LFxuICAgICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4XG4gICAgfSwgaW5mbykpO1xuICB9XG5cbiAgdmFyIGRyYWdFbCxcbiAgICAgIHBhcmVudEVsLFxuICAgICAgZ2hvc3RFbCxcbiAgICAgIHJvb3RFbCxcbiAgICAgIG5leHRFbCxcbiAgICAgIGxhc3REb3duRWwsXG4gICAgICBjbG9uZUVsLFxuICAgICAgY2xvbmVIaWRkZW4sXG4gICAgICBvbGRJbmRleCxcbiAgICAgIG5ld0luZGV4LFxuICAgICAgb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgIGFjdGl2ZUdyb3VwLFxuICAgICAgcHV0U29ydGFibGUsXG4gICAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2UsXG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZSxcbiAgICAgIHNvcnRhYmxlcyA9IFtdLFxuICAgICAgdGFwRXZ0LFxuICAgICAgdG91Y2hFdnQsXG4gICAgICBsYXN0RHgsXG4gICAgICBsYXN0RHksXG4gICAgICB0YXBEaXN0YW5jZUxlZnQsXG4gICAgICB0YXBEaXN0YW5jZVRvcCxcbiAgICAgIG1vdmVkLFxuICAgICAgbGFzdFRhcmdldCxcbiAgICAgIGxhc3REaXJlY3Rpb24sXG4gICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZSxcbiAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSBmYWxzZSxcbiAgICAgIHRhcmdldE1vdmVEaXN0YW5jZSxcbiAgICAgIC8vIEZvciBwb3NpdGlvbmluZyBnaG9zdCBhYnNvbHV0ZWx5XG4gIGdob3N0UmVsYXRpdmVQYXJlbnQsXG4gICAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAgICAgLy8gKGxlZnQsIHRvcClcbiAgX3NpbGVudCA9IGZhbHNlLFxuICAgICAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcbiAgLyoqIEBjb25zdCAqL1xuXG4gIHZhciBkb2N1bWVudEV4aXN0cyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgICAgIENTU0Zsb2F0UHJvcGVydHkgPSBFZGdlIHx8IElFMTFPckxlc3MgPyAnY3NzRmxvYXQnIDogJ2Zsb2F0JyxcbiAgICAgIC8vIFRoaXMgd2lsbCBub3QgcGFzcyBmb3IgSUU5LCBiZWNhdXNlIElFOSBEbkQgb25seSB3b3JrcyBvbiBhbmNob3JzXG4gIHN1cHBvcnREcmFnZ2FibGUgPSBkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCAmJiAhSU9TICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkb2N1bWVudEV4aXN0cykgcmV0dXJuOyAvLyBmYWxzZSB3aGVuIDw9IElFMTFcblxuICAgIGlmIChJRTExT3JMZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9pbnRlci1ldmVudHM6YXV0byc7XG4gICAgcmV0dXJuIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPT09ICdhdXRvJztcbiAgfSgpLFxuICAgICAgX2RldGVjdERpcmVjdGlvbiA9IGZ1bmN0aW9uIF9kZXRlY3REaXJlY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgICBlbFdpZHRoID0gcGFyc2VJbnQoZWxDU1Mud2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlckxlZnRXaWR0aCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICAgICAgY2hpbGQxID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMpLFxuICAgICAgICBjaGlsZDIgPSBnZXRDaGlsZChlbCwgMSwgb3B0aW9ucyksXG4gICAgICAgIGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgY3NzKGNoaWxkMSksXG4gICAgICAgIHNlY29uZENoaWxkQ1NTID0gY2hpbGQyICYmIGNzcyhjaGlsZDIpLFxuICAgICAgICBmaXJzdENoaWxkV2lkdGggPSBmaXJzdENoaWxkQ1NTICYmIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQxKS53aWR0aCxcbiAgICAgICAgc2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDIpLndpZHRoO1xuXG4gICAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdmbGV4Jykge1xuICAgICAgcmV0dXJuIGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4nIHx8IGVsQ1NTLmZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZScgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cblxuICAgIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZ3JpZCcpIHtcbiAgICAgIHJldHVybiBlbENTUy5ncmlkVGVtcGxhdGVDb2x1bW5zLnNwbGl0KCcgJykubGVuZ3RoIDw9IDEgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cblxuICAgIGlmIChjaGlsZDEgJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAhPT0gJ25vbmUnKSB7XG4gICAgICB2YXIgdG91Y2hpbmdTaWRlQ2hpbGQyID0gZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdID09PSAnbGVmdCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgcmV0dXJuIGNoaWxkMiAmJiAoc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09ICdib3RoJyB8fCBzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gdG91Y2hpbmdTaWRlQ2hpbGQyKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkMSAmJiAoZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnYmxvY2snIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ3RhYmxlJyB8fCBmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdncmlkJyB8fCBmaXJzdENoaWxkV2lkdGggPj0gZWxXaWR0aCAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnIHx8IGNoaWxkMiAmJiBlbENTU1tDU1NGbG9hdFByb3BlcnR5XSA9PT0gJ25vbmUnICYmIGZpcnN0Q2hpbGRXaWR0aCArIHNlY29uZENoaWxkV2lkdGggPiBlbFdpZHRoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH0sXG4gICAgICBfZHJhZ0VsSW5Sb3dDb2x1bW4gPSBmdW5jdGlvbiBfZHJhZ0VsSW5Sb3dDb2x1bW4oZHJhZ1JlY3QsIHRhcmdldFJlY3QsIHZlcnRpY2FsKSB7XG4gICAgdmFyIGRyYWdFbFMxT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5sZWZ0IDogZHJhZ1JlY3QudG9wLFxuICAgICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICAgIGRyYWdFbE9wcExlbmd0aCA9IHZlcnRpY2FsID8gZHJhZ1JlY3Qud2lkdGggOiBkcmFnUmVjdC5oZWlnaHQsXG4gICAgICAgIHRhcmdldFMxT3BwID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmxlZnQgOiB0YXJnZXRSZWN0LnRvcCxcbiAgICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgICAgdGFyZ2V0T3BwTGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LndpZHRoIDogdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gICAgcmV0dXJuIGRyYWdFbFMxT3BwID09PSB0YXJnZXRTMU9wcCB8fCBkcmFnRWxTMk9wcCA9PT0gdGFyZ2V0UzJPcHAgfHwgZHJhZ0VsUzFPcHAgKyBkcmFnRWxPcHBMZW5ndGggLyAyID09PSB0YXJnZXRTMU9wcCArIHRhcmdldE9wcExlbmd0aCAvIDI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVjdHMgZmlyc3QgbmVhcmVzdCBlbXB0eSBzb3J0YWJsZSB0byBYIGFuZCBZIHBvc2l0aW9uIHVzaW5nIGVtcHR5SW5zZXJ0VGhyZXNob2xkLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICBYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgICAgIFkgcG9zaXRpb25cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgRWxlbWVudCBvZiB0aGUgZmlyc3QgZm91bmQgbmVhcmVzdCBTb3J0YWJsZVxuICAgKi9cbiAgX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlID0gZnVuY3Rpb24gX2RldGVjdE5lYXJlc3RFbXB0eVNvcnRhYmxlKHgsIHkpIHtcbiAgICB2YXIgcmV0O1xuICAgIHNvcnRhYmxlcy5zb21lKGZ1bmN0aW9uIChzb3J0YWJsZSkge1xuICAgICAgaWYgKGxhc3RDaGlsZChzb3J0YWJsZSkpIHJldHVybjtcbiAgICAgIHZhciByZWN0ID0gZ2V0UmVjdChzb3J0YWJsZSksXG4gICAgICAgICAgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZCxcbiAgICAgICAgICBpbnNpZGVIb3Jpem9udGFsbHkgPSB4ID49IHJlY3QubGVmdCAtIHRocmVzaG9sZCAmJiB4IDw9IHJlY3QucmlnaHQgKyB0aHJlc2hvbGQsXG4gICAgICAgICAgaW5zaWRlVmVydGljYWxseSA9IHkgPj0gcmVjdC50b3AgLSB0aHJlc2hvbGQgJiYgeSA8PSByZWN0LmJvdHRvbSArIHRocmVzaG9sZDtcblxuICAgICAgaWYgKHRocmVzaG9sZCAmJiBpbnNpZGVIb3Jpem9udGFsbHkgJiYgaW5zaWRlVmVydGljYWxseSkge1xuICAgICAgICByZXR1cm4gcmV0ID0gc29ydGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgICAgIF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCkge1xuICAgICAgICB2YXIgc2FtZUdyb3VwID0gdG8ub3B0aW9ucy5ncm91cC5uYW1lICYmIGZyb20ub3B0aW9ucy5ncm91cC5uYW1lICYmIHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XG5cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xuICAgICAgICAgIC8vIERlZmF1bHQgcHVsbCB2YWx1ZVxuICAgICAgICAgIC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChwdWxsICYmIHZhbHVlID09PSAnY2xvbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG90aGVyR3JvdXAgPSAocHVsbCA/IHRvIDogZnJvbSkub3B0aW9ucy5ncm91cC5uYW1lO1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwIHx8IHZhbHVlLmpvaW4gJiYgdmFsdWUuaW5kZXhPZihvdGhlckdyb3VwKSA+IC0xO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbEdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuICAgIGlmICghb3JpZ2luYWxHcm91cCB8fCBfdHlwZW9mKG9yaWdpbmFsR3JvdXApICE9ICdvYmplY3QnKSB7XG4gICAgICBvcmlnaW5hbEdyb3VwID0ge1xuICAgICAgICBuYW1lOiBvcmlnaW5hbEdyb3VwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XG4gICAgZ3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xuICAgIGdyb3VwLmNoZWNrUHV0ID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1dCk7XG4gICAgZ3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xuICAgIG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcbiAgfSxcbiAgICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICAgIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG4gICAgICBfdW5oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gICAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgfVxuICB9OyAvLyAjMTE4NCBmaXggLSBQcmV2ZW50IGNsaWNrIGV2ZW50IG9uIGZhbGxiYWNrIGlmIGRyYWdnZWQgYnV0IGl0ZW0gbm90IGNoYW5nZWQgcG9zaXRpb25cblxuXG4gIGlmIChkb2N1bWVudEV4aXN0cykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKGlnbm9yZU5leHRDbGljaykge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9XG5cbiAgdmFyIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50ID0gZnVuY3Rpb24gbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KSB7XG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgZXZ0ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dDtcblxuICAgICAgdmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgICAgaWYgKG5lYXJlc3QpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGltaXRhdGlvbiBldmVudFxuICAgICAgICB2YXIgZXZlbnQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIGV2dCkge1xuICAgICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGV2ZW50W2ldID0gZXZ0W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnJvb3RFbCA9IG5lYXJlc3Q7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgbmVhcmVzdFtleHBhbmRvXS5fb25EcmFnT3ZlcihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwgPSBmdW5jdGlvbiBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwoZXZ0KSB7XG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAY2xhc3MgIFNvcnRhYmxlXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cbiAgICovXG5cblxuICBmdW5jdGlvbiBTb3J0YWJsZShlbCwgb3B0aW9ucykge1xuICAgIGlmICghKGVsICYmIGVsLm5vZGVUeXBlICYmIGVsLm5vZGVUeXBlID09PSAxKSkge1xuICAgICAgdGhyb3cgXCJTb3J0YWJsZTogYGVsYCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50LCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwoZWwpKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsID0gZWw7IC8vIHJvb3QgZWxlbWVudFxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zKTsgLy8gRXhwb3J0IGluc3RhbmNlXG5cbiAgICBlbFtleHBhbmRvXSA9IHRoaXM7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICBzb3J0OiB0cnVlLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgc3RvcmU6IG51bGwsXG4gICAgICBoYW5kbGU6IG51bGwsXG4gICAgICBkcmFnZ2FibGU6IC9eW3VvXWwkL2kudGVzdChlbC5ub2RlTmFtZSkgPyAnPmxpJyA6ICc+KicsXG4gICAgICBzd2FwVGhyZXNob2xkOiAxLFxuICAgICAgLy8gcGVyY2VudGFnZTsgMCA8PSB4IDw9IDFcbiAgICAgIGludmVydFN3YXA6IGZhbHNlLFxuICAgICAgLy8gaW52ZXJ0IGFsd2F5c1xuICAgICAgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkOiBudWxsLFxuICAgICAgLy8gd2lsbCBiZSBzZXQgdG8gc2FtZSBhcyBzd2FwVGhyZXNob2xkIGlmIGRlZmF1bHRcbiAgICAgIHJlbW92ZUNsb25lT25IaWRlOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBmdW5jdGlvbiBkaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGdob3N0Q2xhc3M6ICdzb3J0YWJsZS1naG9zdCcsXG4gICAgICBjaG9zZW5DbGFzczogJ3NvcnRhYmxlLWNob3NlbicsXG4gICAgICBkcmFnQ2xhc3M6ICdzb3J0YWJsZS1kcmFnJyxcbiAgICAgIGlnbm9yZTogJ2EsIGltZycsXG4gICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICBwcmV2ZW50T25GaWx0ZXI6IHRydWUsXG4gICAgICBhbmltYXRpb246IDAsXG4gICAgICBlYXNpbmc6IG51bGwsXG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcbiAgICAgIH0sXG4gICAgICBkcm9wQnViYmxlOiBmYWxzZSxcbiAgICAgIGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcbiAgICAgIGRhdGFJZEF0dHI6ICdkYXRhLWlkJyxcbiAgICAgIGRlbGF5OiAwLFxuICAgICAgZGVsYXlPblRvdWNoT25seTogZmFsc2UsXG4gICAgICB0b3VjaFN0YXJ0VGhyZXNob2xkOiAoTnVtYmVyLnBhcnNlSW50ID8gTnVtYmVyIDogd2luZG93KS5wYXJzZUludCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMTApIHx8IDEsXG4gICAgICBmb3JjZUZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXG4gICAgICBmYWxsYmFja09uQm9keTogZmFsc2UsXG4gICAgICBmYWxsYmFja1RvbGVyYW5jZTogMCxcbiAgICAgIGZhbGxiYWNrT2Zmc2V0OiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBzdXBwb3J0UG9pbnRlcjogU29ydGFibGUuc3VwcG9ydFBvaW50ZXIgIT09IGZhbHNlICYmICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdyxcbiAgICAgIGVtcHR5SW5zZXJ0VGhyZXNob2xkOiA1XG4gICAgfTtcbiAgICBQbHVnaW5NYW5hZ2VyLmluaXRpYWxpemVQbHVnaW5zKHRoaXMsIGVsLCBkZWZhdWx0cyk7IC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgICEobmFtZSBpbiBvcHRpb25zKSAmJiAob3B0aW9uc1tuYW1lXSA9IGRlZmF1bHRzW25hbWVdKTtcbiAgICB9XG5cbiAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpOyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfSAvLyBTZXR1cCBkcmFnIG1vZGVcblxuXG4gICAgdGhpcy5uYXRpdmVEcmFnZ2FibGUgPSBvcHRpb25zLmZvcmNlRmFsbGJhY2sgPyBmYWxzZSA6IHN1cHBvcnREcmFnZ2FibGU7XG5cbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIC8vIFRvdWNoIHN0YXJ0IHRocmVzaG9sZCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBuYXRpdmUgZHJhZ3N0YXJ0IHRocmVzaG9sZFxuICAgICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSAxO1xuICAgIH0gLy8gQmluZCBldmVudHNcblxuXG4gICAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgIG9uKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb24oZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICAgIG9uKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb24oZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgb24oZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgICB9XG5cbiAgICBzb3J0YWJsZXMucHVzaCh0aGlzLmVsKTsgLy8gUmVzdG9yZSBzb3J0aW5nXG5cbiAgICBvcHRpb25zLnN0b3JlICYmIG9wdGlvbnMuc3RvcmUuZ2V0ICYmIHRoaXMuc29ydChvcHRpb25zLnN0b3JlLmdldCh0aGlzKSB8fCBbXSk7IC8vIEFkZCBhbmltYXRpb24gc3RhdGUgbWFuYWdlclxuXG4gICAgX2V4dGVuZHModGhpcywgQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkpO1xuICB9XG5cbiAgU29ydGFibGUucHJvdG90eXBlID1cbiAgLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi9cbiAge1xuICAgIGNvbnN0cnVjdG9yOiBTb3J0YWJsZSxcbiAgICBfaXNPdXRzaWRlVGhpc0VsOiBmdW5jdGlvbiBfaXNPdXRzaWRlVGhpc0VsKHRhcmdldCkge1xuICAgICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKHRhcmdldCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmVsKSB7XG4gICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldERpcmVjdGlvbjogZnVuY3Rpb24gX2dldERpcmVjdGlvbihldnQsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgICB9LFxuICAgIF9vblRhcFN0YXJ0OiBmdW5jdGlvbiBfb25UYXBTdGFydChcbiAgICAvKiogRXZlbnR8VG91Y2hFdmVudCAqL1xuICAgIGV2dCkge1xuICAgICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHByZXZlbnRPbkZpbHRlciA9IG9wdGlvbnMucHJldmVudE9uRmlsdGVyLFxuICAgICAgICAgIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzWzBdIHx8IGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgZXZ0LFxuICAgICAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgICAgICBvcmlnaW5hbFRhcmdldCA9IGV2dC50YXJnZXQuc2hhZG93Um9vdCAmJiAoZXZ0LnBhdGggJiYgZXZ0LnBhdGhbMF0gfHwgZXZ0LmNvbXBvc2VkUGF0aCAmJiBldnQuY29tcG9zZWRQYXRoKClbMF0pIHx8IHRhcmdldCxcbiAgICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblxuICAgICAgX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShlbCk7IC8vIERvbid0IHRyaWdnZXIgc3RhcnQgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIGJlZW4gZHJhZ2dlZCwgb3RoZXJ3aXNlIHRoZSBldnQub2xkaW5kZXggYWx3YXlzIHdyb25nIHdoZW4gc2V0IG9wdGlvbi5ncm91cC5cblxuXG4gICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QodHlwZSkgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjsgLy8gb25seSBsZWZ0IGJ1dHRvbiBhbmQgZW5hYmxlZFxuICAgICAgfSAvLyBjYW5jZWwgZG5kIGlmIG9yaWdpbmFsIHRhcmdldCBpcyBjb250ZW50IGVkaXRhYmxlXG5cblxuICAgICAgaWYgKG9yaWdpbmFsVGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpO1xuXG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5hbmltYXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0RG93bkVsID09PSB0YXJnZXQpIHtcbiAgICAgICAgLy8gSWdub3JpbmcgZHVwbGljYXRlIGBkb3duYFxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG5cbiAgICAgIG9sZEluZGV4ID0gaW5kZXgodGFyZ2V0KTtcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4ID0gaW5kZXgodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSk7IC8vIENoZWNrIGZpbHRlclxuXG4gICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoZmlsdGVyLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIHRoaXMpKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgcm9vdEVsOiBvcmlnaW5hbFRhcmdldCxcbiAgICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICAgIHRvRWw6IGVsLFxuICAgICAgICAgICAgZnJvbUVsOiBlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICBjcml0ZXJpYSA9IGNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIGNyaXRlcmlhLnRyaW0oKSwgZWwsIGZhbHNlKTtcblxuICAgICAgICAgIGlmIChjcml0ZXJpYSkge1xuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgICAgIHJvb3RFbDogY3JpdGVyaWEsXG4gICAgICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgICB0b0VsOiBlbFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlICYmICFjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBvcHRpb25zLmhhbmRsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXBhcmUgYGRyYWdzdGFydGBcblxuXG4gICAgICB0aGlzLl9wcmVwYXJlRHJhZ1N0YXJ0KGV2dCwgdG91Y2gsIHRhcmdldCk7XG4gICAgfSxcbiAgICBfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gX3ByZXBhcmVEcmFnU3RhcnQoXG4gICAgLyoqIEV2ZW50ICovXG4gICAgZXZ0LFxuICAgIC8qKiBUb3VjaCAqL1xuICAgIHRvdWNoLFxuICAgIC8qKiBIVE1MRWxlbWVudCAqL1xuICAgIHRhcmdldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBlbCA9IF90aGlzLmVsLFxuICAgICAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICAgIGRyYWdTdGFydEZuO1xuXG4gICAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgcm9vdEVsID0gZWw7XG4gICAgICAgIGRyYWdFbCA9IHRhcmdldDtcbiAgICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTtcbiAgICAgICAgbmV4dEVsID0gZHJhZ0VsLm5leHRTaWJsaW5nO1xuICAgICAgICBsYXN0RG93bkVsID0gdGFyZ2V0O1xuICAgICAgICBhY3RpdmVHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XG4gICAgICAgIFNvcnRhYmxlLmRyYWdnZWQgPSBkcmFnRWw7XG4gICAgICAgIHRhcEV2dCA9IHtcbiAgICAgICAgICB0YXJnZXQ6IGRyYWdFbCxcbiAgICAgICAgICBjbGllbnRYOiAodG91Y2ggfHwgZXZ0KS5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcbiAgICAgICAgfTtcbiAgICAgICAgdGFwRGlzdGFuY2VMZWZ0ID0gdGFwRXZ0LmNsaWVudFggLSBkcmFnUmVjdC5sZWZ0O1xuICAgICAgICB0YXBEaXN0YW5jZVRvcCA9IHRhcEV2dC5jbGllbnRZIC0gZHJhZ1JlY3QudG9wO1xuICAgICAgICB0aGlzLl9sYXN0WCA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFg7XG4gICAgICAgIHRoaXMuX2xhc3RZID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WTtcbiAgICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XG5cbiAgICAgICAgZHJhZ1N0YXJ0Rm4gPSBmdW5jdGlvbiBkcmFnU3RhcnRGbigpIHtcbiAgICAgICAgICBwbHVnaW5FdmVudCgnZGVsYXlFbmRlZCcsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICAgIF90aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRGVsYXllZCBkcmFnIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgIC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxuXG5cbiAgICAgICAgICBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICAgICAgICBpZiAoIUZpcmVGb3ggJiYgX3RoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIEJpbmQgdGhlIGV2ZW50czogZHJhZ3N0YXJ0L2RyYWdlbmRcblxuXG4gICAgICAgICAgX3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQoZXZ0LCB0b3VjaCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuXG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgbmFtZTogJ2Nob29zZScsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTsgLy8gQ2hvc2VuIGl0ZW1cblxuXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmNob3NlbkNsYXNzLCB0cnVlKTtcbiAgICAgICAgfTsgLy8gRGlzYWJsZSBcImRyYWdnYWJsZVwiXG5cblxuICAgICAgICBvcHRpb25zLmlnbm9yZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgICAgZmluZChkcmFnRWwsIGNyaXRlcmlhLnRyaW0oKSwgX2Rpc2FibGVEcmFnZ2FibGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7IC8vIE1ha2UgZHJhZ0VsIGRyYWdnYWJsZSAobXVzdCBiZSBiZWZvcmUgZGVsYXkgZm9yIEZpcmVGb3gpXG5cbiAgICAgICAgaWYgKEZpcmVGb3ggJiYgdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDQ7XG4gICAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwbHVnaW5FdmVudCgnZGVsYXlTdGFydCcsIHRoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTsgLy8gRGVsYXkgaXMgaW1wb3NzaWJsZSBmb3IgbmF0aXZlIERuRCBpbiBFZGdlIG9yIElFXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgJiYgKCFvcHRpb25zLmRlbGF5T25Ub3VjaE9ubHkgfHwgdG91Y2gpICYmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgIShFZGdlIHx8IElFMTFPckxlc3MpKSkge1xuICAgICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuICAgICAgICAgIC8vIGJlZm9yZSB0aGUgZGVsYXkgaGFzIGJlZW4gcmVhY2hlZDpcbiAgICAgICAgICAvLyBkaXNhYmxlIHRoZSBkZWxheWVkIGRyYWdcblxuXG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICAgIG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgX3RoaXMuX2RyYWdTdGFydFRpbWVyID0gc2V0VGltZW91dChkcmFnU3RhcnRGbiwgb3B0aW9ucy5kZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ1N0YXJ0Rm4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcjogZnVuY3Rpb24gX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcihcbiAgICAvKiogVG91Y2hFdmVudHxQb2ludGVyRXZlbnQgKiovXG4gICAgZSkge1xuICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgICAgaWYgKE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpID49IE1hdGguZmxvb3IodGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgLyAodGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZygpIHtcbiAgICAgIGRyYWdFbCAmJiBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG4gICAgfSxcbiAgICBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIH0sXG4gICAgX3RyaWdnZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIF90cmlnZ2VyRHJhZ1N0YXJ0KFxuICAgIC8qKiBFdmVudCAqL1xuICAgIGV2dCxcbiAgICAvKiogVG91Y2ggKi9cbiAgICB0b3VjaCkge1xuICAgICAgdG91Y2ggPSB0b3VjaCB8fCBldnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJyAmJiBldnQ7XG5cbiAgICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgdG91Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG91Y2gpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICBvbihyb290RWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaW1lb3V0IG5lY2Nlc3NhcnkgZm9yIElFOVxuICAgICAgICAgIF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICB9LFxuICAgIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gX2RyYWdTdGFydGVkKGZhbGxiYWNrLCBldnQpIHtcblxuICAgICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAocm9vdEVsICYmIGRyYWdFbCkge1xuICAgICAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0ZWQnLCB0aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIF9jaGVja091dHNpZGVUYXJnZXRFbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gQXBwbHkgZWZmZWN0XG5cbiAgICAgICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgICBTb3J0YWJsZS5hY3RpdmUgPSB0aGlzO1xuICAgICAgICBmYWxsYmFjayAmJiB0aGlzLl9hcHBlbmRHaG9zdCgpOyAvLyBEcmFnIHN0YXJ0IGV2ZW50XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbnVsbGluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2VtdWxhdGVEcmFnT3ZlcjogZnVuY3Rpb24gX2VtdWxhdGVEcmFnT3ZlcigpIHtcbiAgICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgICB0aGlzLl9sYXN0WCA9IHRvdWNoRXZ0LmNsaWVudFg7XG4gICAgICAgIHRoaXMuX2xhc3RZID0gdG91Y2hFdnQuY2xpZW50WTtcblxuICAgICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gcGFyZW50KSBicmVhaztcbiAgICAgICAgICBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKHRhcmdldCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgdmFyIGluc2VydGVkID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpbnNlcnRlZCA9IHBhcmVudFtleHBhbmRvXS5fb25EcmFnT3Zlcih7XG4gICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hFdnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChpbnNlcnRlZCAmJiAhdGhpcy5vcHRpb25zLmRyYWdvdmVyQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gcGFyZW50OyAvLyBzdG9yZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9vblRvdWNoTW92ZTogZnVuY3Rpb24gX29uVG91Y2hNb3ZlKFxuICAgIC8qKlRvdWNoRXZlbnQqL1xuICAgIGV2dCkge1xuICAgICAgaWYgKHRhcEV2dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGZhbGxiYWNrVG9sZXJhbmNlID0gb3B0aW9ucy5mYWxsYmFja1RvbGVyYW5jZSxcbiAgICAgICAgICAgIGZhbGxiYWNrT2Zmc2V0ID0gb3B0aW9ucy5mYWxsYmFja09mZnNldCxcbiAgICAgICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCxcbiAgICAgICAgICAgIGdob3N0TWF0cml4ID0gZ2hvc3RFbCAmJiBtYXRyaXgoZ2hvc3RFbCwgdHJ1ZSksXG4gICAgICAgICAgICBzY2FsZVggPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmEsXG4gICAgICAgICAgICBzY2FsZVkgPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmQsXG4gICAgICAgICAgICByZWxhdGl2ZVNjcm9sbE9mZnNldCA9IFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgJiYgZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCksXG4gICAgICAgICAgICBkeCA9ICh0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFggKyBmYWxsYmFja09mZnNldC54KSAvIChzY2FsZVggfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFswXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzBdIDogMCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgICAgZHkgPSAodG91Y2guY2xpZW50WSAtIHRhcEV2dC5jbGllbnRZICsgZmFsbGJhY2tPZmZzZXQueSkgLyAoc2NhbGVZIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMV0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFsxXSA6IDApIC8gKHNjYWxlWSB8fCAxKTsgLy8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcblxuICAgICAgICBpZiAoIVNvcnRhYmxlLmFjdGl2ZSAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICAgIGlmIChmYWxsYmFja1RvbGVyYW5jZSAmJiBNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA8IGZhbGxiYWNrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZXZ0LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnaG9zdEVsKSB7XG4gICAgICAgICAgaWYgKGdob3N0TWF0cml4KSB7XG4gICAgICAgICAgICBnaG9zdE1hdHJpeC5lICs9IGR4IC0gKGxhc3REeCB8fCAwKTtcbiAgICAgICAgICAgIGdob3N0TWF0cml4LmYgKz0gZHkgLSAobGFzdER5IHx8IDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnaG9zdE1hdHJpeCA9IHtcbiAgICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgICAgZDogMSxcbiAgICAgICAgICAgICAgZTogZHgsXG4gICAgICAgICAgICAgIGY6IGR5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjc3NNYXRyaXggPSBcIm1hdHJpeChcIi5jb25jYXQoZ2hvc3RNYXRyaXguYSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5iLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmMsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZCwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5lLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmYsIFwiKVwiKTtcbiAgICAgICAgICBjc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgICAgY3NzKGdob3N0RWwsICdtb3pUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICAgIGNzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgICBsYXN0RHggPSBkeDtcbiAgICAgICAgICBsYXN0RHkgPSBkeTtcbiAgICAgICAgICB0b3VjaEV2dCA9IHRvdWNoO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXBwZW5kR2hvc3Q6IGZ1bmN0aW9uIF9hcHBlbmRHaG9zdCgpIHtcbiAgICAgIC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XG4gICAgICAvLyBOb3QgYmVpbmcgYWRqdXN0ZWQgZm9yXG4gICAgICBpZiAoIWdob3N0RWwpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5mYWxsYmFja09uQm9keSA/IGRvY3VtZW50LmJvZHkgOiByb290RWwsXG4gICAgICAgICAgICByZWN0ID0gZ2V0UmVjdChkcmFnRWwsIHRydWUsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5LCB0cnVlLCBjb250YWluZXIpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gUG9zaXRpb24gYWJzb2x1dGVseVxuXG4gICAgICAgIGlmIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSkge1xuICAgICAgICAgIC8vIEdldCByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgcGFyZW50XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGNvbnRhaW5lcjtcblxuICAgICAgICAgIHdoaWxlIChjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnICYmIGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAndHJhbnNmb3JtJykgPT09ICdub25lJyAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdob3N0UmVsYXRpdmVQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ID09PSBkb2N1bWVudCkgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICAgIHJlY3QudG9wICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgcmVjdC5sZWZ0ICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2hvc3RFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmZhbGxiYWNrQ2xhc3MsIHRydWUpO1xuICAgICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnYm94LXNpemluZycsICdib3JkZXItYm94Jyk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbWFyZ2luJywgMCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndG9wJywgcmVjdC50b3ApO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAncG9zaXRpb24nLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA/ICdhYnNvbHV0ZScgOiAnZml4ZWQnKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd6SW5kZXgnLCAnMTAwMDAwJyk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XG4gICAgICAgIFNvcnRhYmxlLmdob3N0ID0gZ2hvc3RFbDtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGdob3N0RWwpOyAvLyBTZXQgdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtLW9yaWdpbicsIHRhcERpc3RhbmNlTGVmdCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUud2lkdGgpICogMTAwICsgJyUgJyArIHRhcERpc3RhbmNlVG9wIC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS5oZWlnaHQpICogMTAwICsgJyUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9vbkRyYWdTdGFydDogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KFxuICAgIC8qKkV2ZW50Ki9cbiAgICBldnQsXG4gICAgLyoqYm9vbGVhbiovXG4gICAgZmFsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldnQuZGF0YVRyYW5zZmVyO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbkV2ZW50KCdzZXR1cENsb25lJywgdGhpcyk7XG5cbiAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICBjbG9uZUVsID0gY2xvbmUoZHJhZ0VsKTtcbiAgICAgICAgY2xvbmVFbC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgY2xvbmVFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuXG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGNsb25lRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuICAgICAgICBTb3J0YWJsZS5jbG9uZSA9IGNsb25lRWw7XG4gICAgICB9IC8vICMxMTQzOiBJRnJhbWUgc3VwcG9ydCB3b3JrYXJvdW5kXG5cblxuICAgICAgX3RoaXMuY2xvbmVJZCA9IF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdjbG9uZScsIF90aGlzKTtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2xvbmUnXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7IC8vIFNldCBwcm9wZXIgZHJvcCBldmVudHNcblxuICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgIGlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICAgIF90aGlzLl9sb29wSWQgPSBzZXRJbnRlcnZhbChfdGhpcy5fZW11bGF0ZURyYWdPdmVyLCA1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVbmRvIHdoYXQgd2FzIHNldCBpbiBfcHJlcGFyZURyYWdTdGFydCBiZWZvcmUgZHJhZyBzdGFydGVkXG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcblxuICAgICAgICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgICAgb3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBvbihkb2N1bWVudCwgJ2Ryb3AnLCBfdGhpcyk7IC8vICMxMjc2IGZpeDpcblxuICAgICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICBfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcbiAgICAgIG9uKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCBfdGhpcyk7XG4gICAgICBtb3ZlZCA9IHRydWU7XG5cbiAgICAgIGlmIChTYWZhcmkpIHtcbiAgICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICdub25lJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBSZXR1cm5zIHRydWUgLSBpZiBubyBmdXJ0aGVyIGFjdGlvbiBpcyBuZWVkZWQgKGVpdGhlciBpbnNlcnRlZCBvciBhbm90aGVyIGNvbmRpdGlvbilcbiAgICBfb25EcmFnT3ZlcjogZnVuY3Rpb24gX29uRHJhZ092ZXIoXG4gICAgLyoqRXZlbnQqL1xuICAgIGV2dCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICAgIGRyYWdSZWN0LFxuICAgICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgICAgcmV2ZXJ0LFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gU29ydGFibGUuYWN0aXZlLFxuICAgICAgICAgIGlzT3duZXIgPSBhY3RpdmVHcm91cCA9PT0gZ3JvdXAsXG4gICAgICAgICAgY2FuU29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgICBmcm9tU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICB2ZXJ0aWNhbCxcbiAgICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgY29tcGxldGVkRmlyZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKF9zaWxlbnQpIHJldHVybjtcblxuICAgICAgZnVuY3Rpb24gZHJhZ092ZXJFdmVudChuYW1lLCBleHRyYSkge1xuICAgICAgICBwbHVnaW5FdmVudChuYW1lLCBfdGhpcywgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgaXNPd25lcjogaXNPd25lcixcbiAgICAgICAgICBheGlzOiB2ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgcmV2ZXJ0OiByZXZlcnQsXG4gICAgICAgICAgZHJhZ1JlY3Q6IGRyYWdSZWN0LFxuICAgICAgICAgIHRhcmdldFJlY3Q6IHRhcmdldFJlY3QsXG4gICAgICAgICAgY2FuU29ydDogY2FuU29ydCxcbiAgICAgICAgICBmcm9tU29ydGFibGU6IGZyb21Tb3J0YWJsZSxcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZSh0YXJnZXQsIGFmdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIGdldFJlY3QodGFyZ2V0KSwgZXZ0LCBhZnRlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gICAgICAgIH0sIGV4dHJhKSk7XG4gICAgICB9IC8vIENhcHR1cmUgYW5pbWF0aW9uIHN0YXRlXG5cblxuICAgICAgZnVuY3Rpb24gY2FwdHVyZSgpIHtcbiAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlJyk7XG5cbiAgICAgICAgX3RoaXMuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICBmcm9tU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIGludm9jYXRpb24gd2hlbiBkcmFnRWwgaXMgaW5zZXJ0ZWQgKG9yIGNvbXBsZXRlZClcblxuXG4gICAgICBmdW5jdGlvbiBjb21wbGV0ZWQoaW5zZXJ0aW9uKSB7XG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQ29tcGxldGVkJywge1xuICAgICAgICAgIGluc2VydGlvbjogaW5zZXJ0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoX3RoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgICAvLyBTZXQgZ2hvc3QgY2xhc3MgdG8gbmV3IHNvcnRhYmxlJ3MgZ2hvc3QgY2xhc3NcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiBhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHV0U29ydGFibGUgIT09IF90aGlzICYmIF90aGlzICE9PSBTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3RoaXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGhpcyA9PT0gU29ydGFibGUuYWN0aXZlICYmIHB1dFNvcnRhYmxlKSB7XG4gICAgICAgICAgICBwdXRTb3J0YWJsZSA9IG51bGw7XG4gICAgICAgICAgfSAvLyBBbmltYXRpb25cblxuXG4gICAgICAgICAgaWYgKGZyb21Tb3J0YWJsZSA9PT0gX3RoaXMpIHtcbiAgICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IHRhcmdldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ29tcGxldGUnKTtcbiAgICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgICAgZnJvbVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICAgIGZyb21Tb3J0YWJsZS5faWdub3JlV2hpbGVBbmltYXRpbmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBOdWxsIGxhc3RUYXJnZXQgaWYgaXQgaXMgbm90IGluc2lkZSBhIHByZXZpb3VzbHkgc3dhcHBlZCBlbGVtZW50XG5cblxuICAgICAgICBpZiAodGFyZ2V0ID09PSBkcmFnRWwgJiYgIWRyYWdFbC5hbmltYXRlZCB8fCB0YXJnZXQgPT09IGVsICYmICF0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfSAvLyBubyBidWJibGluZyBhbmQgbm90IGZhbGxiYWNrXG5cblxuICAgICAgICBpZiAoIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgIWV2dC5yb290RWwgJiYgdGFyZ2V0ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7IC8vIERvIG5vdCBkZXRlY3QgZm9yIGVtcHR5IGluc2VydCBpZiBhbHJlYWR5IGluc2VydGVkXG5cblxuICAgICAgICAgICFpbnNlcnRpb24gJiYgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgICFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gY29tcGxldGVkRmlyZWQgPSB0cnVlO1xuICAgICAgfSAvLyBDYWxsIHdoZW4gZHJhZ0VsIGhhcyBiZWVuIGluc2VydGVkXG5cblxuICAgICAgZnVuY3Rpb24gY2hhbmdlZCgpIHtcbiAgICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgbmFtZTogJ2NoYW5nZScsXG4gICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldnQucHJldmVudERlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgdHJ1ZSk7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlcicpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybiBjb21wbGV0ZWRGaXJlZDtcblxuICAgICAgaWYgKGRyYWdFbC5jb250YWlucyhldnQudGFyZ2V0KSB8fCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LmFuaW1hdGluZ1ggJiYgdGFyZ2V0LmFuaW1hdGluZ1kgfHwgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiYgKGlzT3duZXIgPyBjYW5Tb3J0IHx8IChyZXZlcnQgPSAhcm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkpIC8vIFJldmVydGluZyBpdGVtIGludG8gdGhlIG9yaWdpbmFsIGxpc3RcbiAgICAgIDogcHV0U29ydGFibGUgPT09IHRoaXMgfHwgKHRoaXMubGFzdFB1dE1vZGUgPSBhY3RpdmVHcm91cC5jaGVja1B1bGwodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkgJiYgZ3JvdXAuY2hlY2tQdXQodGhpcywgYWN0aXZlU29ydGFibGUsIGRyYWdFbCwgZXZ0KSkpIHtcbiAgICAgICAgdmVydGljYWwgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpID09PSAndmVydGljYWwnO1xuICAgICAgICBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsKTtcbiAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJWYWxpZCcpO1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgICAgIGlmIChyZXZlcnQpIHtcbiAgICAgICAgICBwYXJlbnRFbCA9IHJvb3RFbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgICBkcmFnT3ZlckV2ZW50KCdyZXZlcnQnKTtcblxuICAgICAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgICAgaWYgKG5leHRFbCkge1xuICAgICAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dEVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxMYXN0Q2hpbGQgPSBsYXN0Q2hpbGQoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgICBpZiAoIWVsTGFzdENoaWxkIHx8IF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCB0aGlzKSAmJiAhZWxMYXN0Q2hpbGQuYW5pbWF0ZWQpIHtcbiAgICAgICAgICAvLyBJZiBhbHJlYWR5IGF0IGVuZCBvZiBsaXN0OiBEbyBub3QgaW5zZXJ0XG4gICAgICAgICAgaWYgKGVsTGFzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICAgIH0gLy8gYXNzaWduIHRhcmdldCBvbmx5IGlmIGNvbmRpdGlvbiBpcyB0cnVlXG5cblxuICAgICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbCA9PT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZWxMYXN0Q2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgISF0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgIHBhcmVudEVsID0gZWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gMCxcbiAgICAgICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwLFxuICAgICAgICAgICAgICBkaWZmZXJlbnRMZXZlbCA9IGRyYWdFbC5wYXJlbnROb2RlICE9PSBlbCxcbiAgICAgICAgICAgICAgZGlmZmVyZW50Um93Q29sID0gIV9kcmFnRWxJblJvd0NvbHVtbihkcmFnRWwuYW5pbWF0ZWQgJiYgZHJhZ0VsLnRvUmVjdCB8fCBkcmFnUmVjdCwgdGFyZ2V0LmFuaW1hdGVkICYmIHRhcmdldC50b1JlY3QgfHwgdGFyZ2V0UmVjdCwgdmVydGljYWwpLFxuICAgICAgICAgICAgICBzaWRlMSA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICAgIHNjcm9sbGVkUGFzdFRvcCA9IGlzU2Nyb2xsZWRQYXN0KHRhcmdldCwgJ3RvcCcsICd0b3AnKSB8fCBpc1Njcm9sbGVkUGFzdChkcmFnRWwsICd0b3AnLCAndG9wJyksXG4gICAgICAgICAgICAgIHNjcm9sbEJlZm9yZSA9IHNjcm9sbGVkUGFzdFRvcCA/IHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3AgOiB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAobGFzdFRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAgPSB0YXJnZXRSZWN0W3NpZGUxXTtcbiAgICAgICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9ICFkaWZmZXJlbnRSb3dDb2wgJiYgb3B0aW9ucy5pbnZlcnRTd2FwIHx8IGRpZmZlcmVudExldmVsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgZGlmZmVyZW50Um93Q29sID8gMSA6IG9wdGlvbnMuc3dhcFRocmVzaG9sZCwgb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQgPT0gbnVsbCA/IG9wdGlvbnMuc3dhcFRocmVzaG9sZCA6IG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0LCBsYXN0VGFyZ2V0ID09PSB0YXJnZXQpO1xuICAgICAgICAgIHZhciBzaWJsaW5nO1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGJlc2lkZSBkcmFnRWwgaW4gcmVzcGVjdGl2ZSBkaXJlY3Rpb24gKGlnbm9yaW5nIGhpZGRlbiBlbGVtZW50cylcbiAgICAgICAgICAgIHZhciBkcmFnSW5kZXggPSBpbmRleChkcmFnRWwpO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGRyYWdJbmRleCAtPSBkaXJlY3Rpb247XG4gICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnRFbC5jaGlsZHJlbltkcmFnSW5kZXhdO1xuICAgICAgICAgICAgfSB3aGlsZSAoc2libGluZyAmJiAoY3NzKHNpYmxpbmcsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzaWJsaW5nID09PSBnaG9zdEVsKSk7XG4gICAgICAgICAgfSAvLyBJZiBkcmFnRWwgaXMgYWxyZWFkeSBiZXNpZGUgdGFyZ2V0OiBEbyBub3QgaW5zZXJ0XG5cblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgfHwgc2libGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIGxhc3REaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgICBhZnRlciA9IGRpcmVjdGlvbiA9PT0gMTtcblxuICAgICAgICAgIHZhciBtb3ZlVmVjdG9yID0gX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgYWZ0ZXIpO1xuXG4gICAgICAgICAgaWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobW92ZVZlY3RvciA9PT0gMSB8fCBtb3ZlVmVjdG9yID09PSAtMSkge1xuICAgICAgICAgICAgICBhZnRlciA9IG1vdmVWZWN0b3IgPT09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChfdW5zaWxlbnQsIDMwKTtcbiAgICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgICAgaWYgKGFmdGVyICYmICFuZXh0U2libGluZykge1xuICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgYWZ0ZXIgPyBuZXh0U2libGluZyA6IHRhcmdldCk7XG4gICAgICAgICAgICB9IC8vIFVuZG8gY2hyb21lJ3Mgc2Nyb2xsIGFkanVzdG1lbnQgKGhhcyBubyBlZmZlY3Qgb24gb3RoZXIgYnJvd3NlcnMpXG5cblxuICAgICAgICAgICAgaWYgKHNjcm9sbGVkUGFzdFRvcCkge1xuICAgICAgICAgICAgICBzY3JvbGxCeShzY3JvbGxlZFBhc3RUb3AsIDAsIHNjcm9sbEJlZm9yZSAtIHNjcm9sbGVkUGFzdFRvcC5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlOyAvLyBhY3R1YWxpemF0aW9uXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGRvbmUgYmVmb3JlIGFuaW1hdGlvblxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0QmVmb3JlRmlyc3RTd2FwICE9PSB1bmRlZmluZWQgJiYgIWlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0TW92ZURpc3RhbmNlID0gTWF0aC5hYnModGFyZ2V0QmVmb3JlRmlyc3RTd2FwIC0gZ2V0UmVjdCh0YXJnZXQpW3NpZGUxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsLmNvbnRhaW5zKGRyYWdFbCkpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBfaWdub3JlV2hpbGVBbmltYXRpbmc6IG51bGwsXG4gICAgX29mZk1vdmVFdmVudHM6IGZ1bmN0aW9uIF9vZmZNb3ZlRXZlbnRzKCkge1xuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICB9LFxuICAgIF9vZmZVcEV2ZW50czogZnVuY3Rpb24gX29mZlVwRXZlbnRzKCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gICAgfSxcbiAgICBfb25Ecm9wOiBmdW5jdGlvbiBfb25Ecm9wKFxuICAgIC8qKkV2ZW50Ki9cbiAgICBldnQpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWwsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cbiAgICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgICBwbHVnaW5FdmVudCgnZHJvcCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pO1xuICAgICAgcGFyZW50RWwgPSBkcmFnRWwgJiYgZHJhZ0VsLnBhcmVudE5vZGU7IC8vIEdldCBhZ2FpbiBhZnRlciBwbHVnaW4gZXZlbnRcblxuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy5fbnVsbGluZygpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlO1xuICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2xvb3BJZCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5jbG9uZUlkKTtcblxuICAgICAgX2NhbmNlbE5leHRUaWNrKHRoaXMuX2RyYWdTdGFydElkKTsgLy8gVW5iaW5kIGV2ZW50c1xuXG5cbiAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICAgIG9mZihlbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb2ZmTW92ZUV2ZW50cygpO1xuXG4gICAgICB0aGlzLl9vZmZVcEV2ZW50cygpO1xuXG4gICAgICBpZiAoU2FmYXJpKSB7XG4gICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgIGlmIChldnQpIHtcbiAgICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgIW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZSAmJiBnaG9zdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2hvc3RFbCk7XG5cbiAgICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgY2xvbmUocylcbiAgICAgICAgICBjbG9uZUVsICYmIGNsb25lRWwucGFyZW50Tm9kZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBvZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG5cbiAgICAgICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJzsgLy8gUmVtb3ZlIGNsYXNzZXNcbiAgICAgICAgICAvLyBnaG9zdENsYXNzIGlzIGFkZGVkIGluIGRyYWdTdGFydGVkXG5cbiAgICAgICAgICBpZiAobW92ZWQgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7IC8vIERyYWcgc3RvcCBldmVudFxuXG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICBuYW1lOiAndW5jaG9vc2UnLFxuICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICBuZXdJbmRleDogbnVsbCxcbiAgICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAocm9vdEVsICE9PSBwYXJlbnRFbCkge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgLy8gQWRkIGV2ZW50XG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhZGQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTsgLy8gUmVtb3ZlIGV2ZW50XG5cblxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlbW92ZScsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pOyAvLyBkcmFnIGZyb20gb25lIGxpc3QgYW5kIGRyb3AgaW50byBhbm90aGVyXG5cblxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5zYXZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleCAhPT0gb2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgICAgLyoganNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPT0gbnVsbCB8fCBuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBvbGRJbmRleDtcbiAgICAgICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBTYXZlIHNvcnRpbmdcblxuXG4gICAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fbnVsbGluZygpO1xuICAgIH0sXG4gICAgX251bGxpbmc6IGZ1bmN0aW9uIF9udWxsaW5nKCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ251bGxpbmcnLCB0aGlzKTtcbiAgICAgIHJvb3RFbCA9IGRyYWdFbCA9IHBhcmVudEVsID0gZ2hvc3RFbCA9IG5leHRFbCA9IGNsb25lRWwgPSBsYXN0RG93bkVsID0gY2xvbmVIaWRkZW4gPSB0YXBFdnQgPSB0b3VjaEV2dCA9IG1vdmVkID0gbmV3SW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXggPSBsYXN0VGFyZ2V0ID0gbGFzdERpcmVjdGlvbiA9IHB1dFNvcnRhYmxlID0gYWN0aXZlR3JvdXAgPSBTb3J0YWJsZS5kcmFnZ2VkID0gU29ydGFibGUuZ2hvc3QgPSBTb3J0YWJsZS5jbG9uZSA9IFNvcnRhYmxlLmFjdGl2ZSA9IG51bGw7XG4gICAgICBzYXZlZElucHV0Q2hlY2tlZC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgc2F2ZWRJbnB1dENoZWNrZWQubGVuZ3RoID0gbGFzdER4ID0gbGFzdER5ID0gMDtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbiBoYW5kbGVFdmVudChcbiAgICAvKipFdmVudCovXG4gICAgZXZ0KSB7XG4gICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgICB0aGlzLl9vbkRyb3AoZXZ0KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRyYWdPdmVyKGV2dCk7XG5cbiAgICAgICAgICAgIF9nbG9iYWxEcmFnT3ZlcihldnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBvcmRlciA9IFtdLFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGVsID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKGNsb3Nlc3QoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSkpIHtcbiAgICAgICAgICBvcmRlci5wdXNoKGVsLmdldEF0dHJpYnV0ZShvcHRpb25zLmRhdGFJZEF0dHIpIHx8IF9nZW5lcmF0ZUlkKGVsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gIG9yZGVyICBvcmRlciBvZiB0aGUgaXRlbXNcbiAgICAgKi9cbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KG9yZGVyKSB7XG4gICAgICB2YXIgaXRlbXMgPSB7fSxcbiAgICAgICAgICByb290RWwgPSB0aGlzLmVsO1xuICAgICAgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgICAgdmFyIGVsID0gcm9vdEVsLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmIChjbG9zZXN0KGVsLCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCByb290RWwsIGZhbHNlKSkge1xuICAgICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpdGVtc1tpZF0pIHtcbiAgICAgICAgICByb290RWwucmVtb3ZlQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xuICAgICAqL1xuICAgIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICB2YXIgc3RvcmUgPSB0aGlzLm9wdGlvbnMuc3RvcmU7XG4gICAgICBzdG9yZSAmJiBzdG9yZS5zZXQgJiYgc3RvcmUuc2V0KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yIGJ5IHRlc3RpbmcgdGhlIGVsZW1lbnQgaXRzZWxmIGFuZCB0cmF2ZXJzaW5nIHVwIHRocm91Z2ggaXRzIGFuY2VzdG9ycyBpbiB0aGUgRE9NIHRyZWUuXG4gICAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgZWxcbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICBbc2VsZWN0b3JdICBkZWZhdWx0OiBgb3B0aW9ucy5kcmFnZ2FibGVgXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAgICovXG4gICAgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdCQxKGVsLCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGNsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0L2dldCBvcHRpb25cbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtICAgeyp9ICAgICAgW3ZhbHVlXVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbbmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IFBsdWdpbk1hbmFnZXIubW9kaWZ5T3B0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVkVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG1vZGlmaWVkVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICBlbFtleHBhbmRvXSA9IG51bGw7XG4gICAgICBvZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICAgIG9mZihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICAgIG9mZihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG5cbiAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgICBvZmYoZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXG5cblxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKCdbZHJhZ2dhYmxlXScpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2FibGUnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICAgIHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xuICAgICAgdGhpcy5lbCA9IGVsID0gbnVsbDtcbiAgICB9LFxuICAgIF9oaWRlQ2xvbmU6IGZ1bmN0aW9uIF9oaWRlQ2xvbmUoKSB7XG4gICAgICBpZiAoIWNsb25lSGlkZGVuKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdoaWRlQ2xvbmUnLCB0aGlzKTtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lRWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9zaG93Q2xvbmU6IGZ1bmN0aW9uIF9zaG93Q2xvbmUocHV0U29ydGFibGUpIHtcbiAgICAgIGlmIChwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9uZUhpZGRlbikge1xuICAgICAgICBwbHVnaW5FdmVudCgnc2hvd0Nsb25lJywgdGhpcyk7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47IC8vIHNob3cgY2xvbmUgYXQgZHJhZ0VsIG9yIG9yaWdpbmFsIHBvc2l0aW9uXG5cbiAgICAgICAgaWYgKHJvb3RFbC5jb250YWlucyhkcmFnRWwpICYmICF0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBuZXh0RWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZUVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoZHJhZ0VsLCBjbG9uZUVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX2dsb2JhbERyYWdPdmVyKFxuICAvKipFdmVudCovXG4gIGV2dCkge1xuICAgIGlmIChldnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gICAgfVxuXG4gICAgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBfb25Nb3ZlKGZyb21FbCwgdG9FbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0RWwsIHRhcmdldFJlY3QsIG9yaWdpbmFsRXZlbnQsIHdpbGxJbnNlcnRBZnRlcikge1xuICAgIHZhciBldnQsXG4gICAgICAgIHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxuICAgICAgICBvbk1vdmVGbiA9IHNvcnRhYmxlLm9wdGlvbnMub25Nb3ZlLFxuICAgICAgICByZXRWYWw7IC8vIFN1cHBvcnQgZm9yIG5ldyBDdXN0b21FdmVudCBmZWF0dXJlXG5cbiAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vdmUnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBldnQudG8gPSB0b0VsO1xuICAgIGV2dC5mcm9tID0gZnJvbUVsO1xuICAgIGV2dC5kcmFnZ2VkID0gZHJhZ0VsO1xuICAgIGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuICAgIGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcbiAgICBldnQucmVsYXRlZFJlY3QgPSB0YXJnZXRSZWN0IHx8IGdldFJlY3QodG9FbCk7XG4gICAgZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcbiAgICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgZnJvbUVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgIGlmIChvbk1vdmVGbikge1xuICAgICAgcmV0VmFsID0gb25Nb3ZlRm4uY2FsbChzb3J0YWJsZSwgZXZ0LCBvcmlnaW5hbEV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Rpc2FibGVEcmFnZ2FibGUoZWwpIHtcbiAgICBlbC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnNpbGVudCgpIHtcbiAgICBfc2lsZW50ID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgICB2YXIgcmVjdCA9IGdldFJlY3QobGFzdENoaWxkKHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLmRyYWdnYWJsZSkpO1xuICAgIHZhciBzcGFjZXIgPSAxMDtcbiAgICByZXR1cm4gdmVydGljYWwgPyBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgKyBzcGFjZXIgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYID49IHJlY3QubGVmdCA6IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QudG9wIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSArIHNwYWNlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgc3dhcFRocmVzaG9sZCwgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpbnZlcnRTd2FwLCBpc0xhc3RUYXJnZXQpIHtcbiAgICB2YXIgbW91c2VPbkF4aXMgPSB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRZIDogZXZ0LmNsaWVudFgsXG4gICAgICAgIHRhcmdldExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgICAgICB0YXJnZXRTMSA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC50b3AgOiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICAgIHRhcmdldFMyID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmJvdHRvbSA6IHRhcmdldFJlY3QucmlnaHQsXG4gICAgICAgIGludmVydCA9IGZhbHNlO1xuXG4gICAgaWYgKCFpbnZlcnRTd2FwKSB7XG4gICAgICAvLyBOZXZlciBpbnZlcnQgb3IgY3JlYXRlIGRyYWdFbCBzaGFkb3cgd2hlbiB0YXJnZXQgbW92ZW1lbmV0IGNhdXNlcyBtb3VzZSB0byBtb3ZlIHBhc3QgdGhlIGVuZCBvZiByZWd1bGFyIHN3YXBUaHJlc2hvbGRcbiAgICAgIGlmIChpc0xhc3RUYXJnZXQgJiYgdGFyZ2V0TW92ZURpc3RhbmNlIDwgdGFyZ2V0TGVuZ3RoICogc3dhcFRocmVzaG9sZCkge1xuICAgICAgICAvLyBtdWx0aXBsaWVkIG9ubHkgYnkgc3dhcFRocmVzaG9sZCBiZWNhdXNlIG1vdXNlIHdpbGwgYWxyZWFkeSBiZSBpbnNpZGUgdGFyZ2V0IGJ5ICgxIC0gdGhyZXNob2xkKSAqIHRhcmdldExlbmd0aCAvIDJcbiAgICAgICAgLy8gY2hlY2sgaWYgcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkIG9uIHNpZGUgb3Bwb3NpdGUgb2YgbGFzdERpcmVjdGlvblxuICAgICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIDogbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpKSB7XG4gICAgICAgICAgLy8gcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkLCBkbyBub3QgcmVzdHJpY3QgaW52ZXJ0ZWQgdGhyZXNob2xkIHRvIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2gpIHtcbiAgICAgICAgICAvLyBkcmFnRWwgc2hhZG93ICh0YXJnZXQgbW92ZSBkaXN0YW5jZSBzaGFkb3cpXG4gICAgICAgICAgaWYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TW92ZURpc3RhbmNlIC8vIG92ZXIgZHJhZ0VsIHNoYWRvd1xuICAgICAgICAgIDogbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldE1vdmVEaXN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIC1sYXN0RGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZlcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWd1bGFyXG4gICAgICAgIGlmIChtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIgJiYgbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludmVydCA9IGludmVydCB8fCBpbnZlcnRTd2FwO1xuXG4gICAgaWYgKGludmVydCkge1xuICAgICAgLy8gSW52ZXJ0IG9mIHJlZ3VsYXJcbiAgICAgIGlmIChtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMiB8fCBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikge1xuICAgICAgICByZXR1cm4gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIgPyAxIDogLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkIHJlbGF0aXZlIHRvIHRhcmdldCBpbiBvcmRlciB0byBtYWtlIGl0XG4gICAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXCJpbnNlcnRlZFwiIGludG8gdGhhdCBlbGVtZW50J3MgcG9zaXRpb25cbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgICAgICBUaGUgdGFyZ2V0IHdob3NlIHBvc2l0aW9uIGRyYWdFbCBpcyBiZWluZyBpbnNlcnRlZCBhdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgIERpcmVjdGlvbiBkcmFnRWwgbXVzdCBiZSBzd2FwcGVkXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpIHtcbiAgICBpZiAoaW5kZXgoZHJhZ0VsKSA8IGluZGV4KHRhcmdldCkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBpZFxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gX2dlbmVyYXRlSWQoZWwpIHtcbiAgICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgICAgaSA9IHN0ci5sZW5ndGgsXG4gICAgICAgIHN1bSA9IDA7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzdW0gKz0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bS50b1N0cmluZygzNik7XG4gIH1cblxuICBmdW5jdGlvbiBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKHJvb3QpIHtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICAgIHZhciBpbnB1dHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuICAgIHZhciBpZHggPSBpbnB1dHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGlkeC0tKSB7XG4gICAgICB2YXIgZWwgPSBpbnB1dHNbaWR4XTtcbiAgICAgIGVsLmNoZWNrZWQgJiYgc2F2ZWRJbnB1dENoZWNrZWQucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX25leHRUaWNrKGZuKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NhbmNlbE5leHRUaWNrKGlkKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG4gIH0gLy8gRml4ZWQgIzk3MzpcblxuXG4gIGlmIChkb2N1bWVudEV4aXN0cykge1xuICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKChTb3J0YWJsZS5hY3RpdmUgfHwgYXdhaXRpbmdEcmFnU3RhcnRlZCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gRXhwb3J0IHV0aWxzXG5cblxuICBTb3J0YWJsZS51dGlscyA9IHtcbiAgICBvbjogb24sXG4gICAgb2ZmOiBvZmYsXG4gICAgY3NzOiBjc3MsXG4gICAgZmluZDogZmluZCxcbiAgICBpczogZnVuY3Rpb24gaXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgICB9LFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICBjbG9zZXN0OiBjbG9zZXN0LFxuICAgIHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIG5leHRUaWNrOiBfbmV4dFRpY2ssXG4gICAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgICBkZXRlY3REaXJlY3Rpb246IF9kZXRlY3REaXJlY3Rpb24sXG4gICAgZ2V0Q2hpbGQ6IGdldENoaWxkXG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdGhlIFNvcnRhYmxlIGluc3RhbmNlIG9mIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnRcbiAgICogQHJldHVybiB7U29ydGFibGV8dW5kZWZpbmVkfSAgICAgICAgIFRoZSBpbnN0YW5jZSBvZiBTb3J0YWJsZVxuICAgKi9cblxuICBTb3J0YWJsZS5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50W2V4cGFuZG9dO1xuICB9O1xuICAvKipcbiAgICogTW91bnQgYSBwbHVnaW4gdG8gU29ydGFibGVcbiAgICogQHBhcmFtICB7Li4uU29ydGFibGVQbHVnaW58U29ydGFibGVQbHVnaW5bXX0gcGx1Z2lucyAgICAgICBQbHVnaW5zIGJlaW5nIG1vdW50ZWRcbiAgICovXG5cblxuICBTb3J0YWJsZS5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbnNbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKCFwbHVnaW4ucHJvdG90eXBlIHx8ICFwbHVnaW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRocm93IFwiU29ydGFibGU6IE1vdW50ZWQgcGx1Z2luIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKHBsdWdpbikpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGx1Z2luLnV0aWxzKSBTb3J0YWJsZS51dGlscyA9IF9vYmplY3RTcHJlYWQoe30sIFNvcnRhYmxlLnV0aWxzLCBwbHVnaW4udXRpbHMpO1xuICAgICAgUGx1Z2luTWFuYWdlci5tb3VudChwbHVnaW4pO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cbiAgICovXG5cblxuICBTb3J0YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNvcnRhYmxlKGVsLCBvcHRpb25zKTtcbiAgfTsgLy8gRXhwb3J0XG5cblxuICBTb3J0YWJsZS52ZXJzaW9uID0gdmVyc2lvbjtcblxuICB2YXIgYXV0b1Njcm9sbHMgPSBbXSxcbiAgICAgIHNjcm9sbEVsLFxuICAgICAgc2Nyb2xsUm9vdEVsLFxuICAgICAgc2Nyb2xsaW5nID0gZmFsc2UsXG4gICAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgICBsYXN0QXV0b1Njcm9sbFksXG4gICAgICB0b3VjaEV2dCQxLFxuICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbiAgZnVuY3Rpb24gQXV0b1Njcm9sbFBsdWdpbigpIHtcbiAgICBmdW5jdGlvbiBBdXRvU2Nyb2xsKCkge1xuICAgICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgICBzY3JvbGxTZW5zaXRpdml0eTogMzAsXG4gICAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgICAgYnViYmxlU2Nyb2xsOiB0cnVlXG4gICAgICB9OyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuICAgICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZikge1xuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudDtcblxuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYyLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgLy8gRm9yIHdoZW4gYnViYmxpbmcgaXMgY2FuY2VsZWQgYW5kIHVzaW5nIGZhbGxiYWNrIChmYWxsYmFjayAndG91Y2htb3ZlJyBhbHdheXMgcmVhY2hlZClcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlQXV0b1Njcm9sbChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvcnRhYmxlLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICBjYW5jZWxUaHJvdHRsZSgpO1xuICAgICAgfSxcbiAgICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICAgIHRvdWNoRXZ0JDEgPSBzY3JvbGxSb290RWwgPSBzY3JvbGxFbCA9IHNjcm9sbGluZyA9IHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID0gbGFzdEF1dG9TY3JvbGxYID0gbGFzdEF1dG9TY3JvbGxZID0gbnVsbDtcbiAgICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICAgIH0sXG4gICAgICBfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsOiBmdW5jdGlvbiBfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKGV2dCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgX2hhbmRsZUF1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgZmFsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIHRvdWNoRXZ0JDEgPSBldnQ7IC8vIElFIGRvZXMgbm90IHNlZW0gdG8gaGF2ZSBuYXRpdmUgYXV0b3Njcm9sbCxcbiAgICAgICAgLy8gRWRnZSdzIGF1dG9zY3JvbGwgc2VlbXMgdG9vIGNvbmRpdGlvbmFsLFxuICAgICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgYXJlIGdvb2RcblxuICAgICAgICBpZiAoZmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGVsZW0sIGZhbGxiYWNrKTsgLy8gTGlzdGVuZXIgZm9yIHBvaW50ZXIgZWxlbWVudCBjaGFuZ2VcblxuICAgICAgICAgIHZhciBvZ0VsZW1TY3JvbGxlciA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbGluZyAmJiAoIXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8IHggIT09IGxhc3RBdXRvU2Nyb2xsWCB8fCB5ICE9PSBsYXN0QXV0b1Njcm9sbFkpKSB7XG4gICAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCAmJiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7IC8vIERldGVjdCBmb3IgcG9pbnRlciBlbGVtIGNoYW5nZSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG5cbiAgICAgICAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbmV3RWxlbSA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksIHRydWUpO1xuXG4gICAgICAgICAgICAgIGlmIChuZXdFbGVtICE9PSBvZ0VsZW1TY3JvbGxlcikge1xuICAgICAgICAgICAgICAgIG9nRWxlbVNjcm9sbGVyID0gbmV3RWxlbTtcbiAgICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgX3RoaXMub3B0aW9ucywgbmV3RWxlbSwgZmFsbGJhY2spO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgbGFzdEF1dG9TY3JvbGxYID0geDtcbiAgICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIERuRCBpcyBlbmFibGVkIChhbmQgYnJvd3NlciBoYXMgZ29vZCBhdXRvc2Nyb2xsaW5nKSwgZmlyc3QgYXV0b3Njcm9sbCB3aWxsIGFscmVhZHkgc2Nyb2xsLCBzbyBnZXQgcGFyZW50IGF1dG9zY3JvbGwgb2YgZmlyc3QgYXV0b3Njcm9sbFxuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgZmFsc2UpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyhBdXRvU2Nyb2xsLCB7XG4gICAgICBwbHVnaW5OYW1lOiAnc2Nyb2xsJyxcbiAgICAgIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQXV0b1Njcm9sbHMoKSB7XG4gICAgYXV0b1Njcm9sbHMuZm9yRWFjaChmdW5jdGlvbiAoYXV0b1Njcm9sbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gICAgfSk7XG4gICAgYXV0b1Njcm9sbHMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCk7XG4gIH1cblxuICB2YXIgYXV0b1Njcm9sbCA9IHRocm90dGxlKGZ1bmN0aW9uIChldnQsIG9wdGlvbnMsIHJvb3RFbCwgaXNGYWxsYmFjaykge1xuICAgIC8vIEJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTA1NTIxXG4gICAgaWYgKCFvcHRpb25zLnNjcm9sbCkgcmV0dXJuO1xuICAgIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICAgIHkgPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WSxcbiAgICAgICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgICAgIHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcbiAgICAgICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgICAgICBzY3JvbGxDdXN0b21GbjsgLy8gTmV3IHNjcm9sbCByb290LCBzZXQgc2Nyb2xsRWxcblxuICAgIGlmIChzY3JvbGxSb290RWwgIT09IHJvb3RFbCkge1xuICAgICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgc2Nyb2xsRWwgPSBvcHRpb25zLnNjcm9sbDtcbiAgICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcblxuICAgICAgaWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XG4gICAgICAgIHNjcm9sbEVsID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocm9vdEVsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJzT3V0ID0gMDtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGVsID0gY3VycmVudFBhcmVudCxcbiAgICAgICAgICByZWN0ID0gZ2V0UmVjdChlbCksXG4gICAgICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICAgICAgYm90dG9tID0gcmVjdC5ib3R0b20sXG4gICAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgICByaWdodCA9IHJlY3QucmlnaHQsXG4gICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgIGNhblNjcm9sbFggPSB2b2lkIDAsXG4gICAgICAgICAgY2FuU2Nyb2xsWSA9IHZvaWQgMCxcbiAgICAgICAgICBzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICBlbENTUyA9IGNzcyhlbCksXG4gICAgICAgICAgc2Nyb2xsUG9zWCA9IGVsLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsUG9zWSA9IGVsLnNjcm9sbFRvcDtcblxuICAgICAgaWYgKGVsID09PSB3aW5TY3JvbGxlcikge1xuICAgICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAndmlzaWJsZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZ4ID0gY2FuU2Nyb2xsWCAmJiAoTWF0aC5hYnMocmlnaHQgLSB4KSA8PSBzZW5zICYmIHNjcm9sbFBvc1ggKyB3aWR0aCA8IHNjcm9sbFdpZHRoKSAtIChNYXRoLmFicyhsZWZ0IC0geCkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1gpO1xuICAgICAgdmFyIHZ5ID0gY2FuU2Nyb2xsWSAmJiAoTWF0aC5hYnMoYm90dG9tIC0geSkgPD0gc2VucyAmJiBzY3JvbGxQb3NZICsgaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0KSAtIChNYXRoLmFicyh0b3AgLSB5KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWSk7XG5cbiAgICAgIGlmICghYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICAgIGlmICghYXV0b1Njcm9sbHNbaV0pIHtcbiAgICAgICAgICAgIGF1dG9TY3JvbGxzW2ldID0ge307XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCA9IGVsO1xuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ID0gdng7XG4gICAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCk7XG5cbiAgICAgICAgaWYgKHZ4ICE9IDAgfHwgdnkgIT0gMCkge1xuICAgICAgICAgIHNjcm9sbFRoaXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cblxuICAgICAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0ucGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgICBpZiAoaXNGYWxsYmFjayAmJiB0aGlzLmxheWVyID09PSAwKSB7XG4gICAgICAgICAgICAgIFNvcnRhYmxlLmFjdGl2ZS5fb25Ub3VjaE1vdmUodG91Y2hFdnQkMSk7IC8vIFRvIG1vdmUgZ2hvc3QgaWYgaXQgaXMgcG9zaXRpb25lZCBhYnNvbHV0ZWx5XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFkgPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ICogc3BlZWQgOiAwO1xuICAgICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFggPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ICogc3BlZWQgOiAwO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChzY3JvbGxDdXN0b21Gbi5jYWxsKFNvcnRhYmxlLmRyYWdnZWQucGFyZW50Tm9kZVtleHBhbmRvXSwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgZXZ0LCB0b3VjaEV2dCQxLCBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCkgIT09ICdjb250aW51ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2Nyb2xsQnkoYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwsIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFkpO1xuICAgICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgICBsYXllcjogbGF5ZXJzT3V0XG4gICAgICAgICAgfSksIDI0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXllcnNPdXQrKztcbiAgICB9IHdoaWxlIChvcHRpb25zLmJ1YmJsZVNjcm9sbCAmJiBjdXJyZW50UGFyZW50ICE9PSB3aW5TY3JvbGxlciAmJiAoY3VycmVudFBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xuXG4gICAgc2Nyb2xsaW5nID0gc2Nyb2xsVGhpc0luc3RhbmNlOyAvLyBpbiBjYXNlIGFub3RoZXIgZnVuY3Rpb24gY2F0Y2hlcyBzY3JvbGxpbmcgYXMgZmFsc2UgaW4gYmV0d2VlbiB3aGVuIGl0IGlzIG5vdFxuICB9LCAzMCk7XG5cbiAgdmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgICBkcmFnRWwgPSBfcmVmLmRyYWdFbCxcbiAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi51bmhpZGVHaG9zdEZvclRhcmdldDtcbiAgICBpZiAoIW9yaWdpbmFsRXZlbnQpIHJldHVybjtcbiAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICAgIGhpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgIHZhciB0b3VjaCA9IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPyBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogb3JpZ2luYWxFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICB1bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gICAgaWYgKHRvU29ydGFibGUgJiYgIXRvU29ydGFibGUuZWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgICAgdGhpcy5vblNwaWxsKHtcbiAgICAgICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFJldmVydCgpIHt9XG5cbiAgUmV2ZXJ0LnByb3RvdHlwZSA9IHtcbiAgICBzdGFydEluZGV4OiBudWxsLFxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgICB2YXIgb2xkRHJhZ2dhYmxlSW5kZXggPSBfcmVmMi5vbGREcmFnZ2FibGVJbmRleDtcbiAgICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgIH0sXG4gICAgb25TcGlsbDogZnVuY3Rpb24gb25TcGlsbChfcmVmMykge1xuICAgICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlO1xuICAgICAgdGhpcy5zb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICAgIHB1dFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICB0aGlzLnNvcnRhYmxlLmVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc29ydGFibGUuZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zb3J0YWJsZS5hbmltYXRlQWxsKCk7XG5cbiAgICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgICBwdXRTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBkcm9wXG4gIH07XG5cbiAgX2V4dGVuZHMoUmV2ZXJ0LCB7XG4gICAgcGx1Z2luTmFtZTogJ3JldmVydE9uU3BpbGwnXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIFJlbW92ZSgpIHt9XG5cbiAgUmVtb3ZlLnByb3RvdHlwZSA9IHtcbiAgICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgICB2YXIgZHJhZ0VsID0gX3JlZjQuZHJhZ0VsLFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjQucHV0U29ydGFibGU7XG4gICAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgcGFyZW50U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICBkcmFnRWwucGFyZW50Tm9kZSAmJiBkcmFnRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkcmFnRWwpO1xuICAgICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgIH0sXG4gICAgZHJvcDogZHJvcFxuICB9O1xuXG4gIF9leHRlbmRzKFJlbW92ZSwge1xuICAgIHBsdWdpbk5hbWU6ICdyZW1vdmVPblNwaWxsJ1xuICB9KTtcblxuICB2YXIgbGFzdFN3YXBFbDtcblxuICBmdW5jdGlvbiBTd2FwUGx1Z2luKCkge1xuICAgIGZ1bmN0aW9uIFN3YXAoKSB7XG4gICAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgICBzd2FwQ2xhc3M6ICdzb3J0YWJsZS1zd2FwLWhpZ2hsaWdodCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgU3dhcC5wcm90b3R5cGUgPSB7XG4gICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmKSB7XG4gICAgICAgIHZhciBkcmFnRWwgPSBfcmVmLmRyYWdFbDtcbiAgICAgICAgbGFzdFN3YXBFbCA9IGRyYWdFbDtcbiAgICAgIH0sXG4gICAgICBkcmFnT3ZlclZhbGlkOiBmdW5jdGlvbiBkcmFnT3ZlclZhbGlkKF9yZWYyKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSBfcmVmMi5jb21wbGV0ZWQsXG4gICAgICAgICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICAgICAgICBvbk1vdmUgPSBfcmVmMi5vbk1vdmUsXG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYyLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgICAgY2hhbmdlZCA9IF9yZWYyLmNoYW5nZWQsXG4gICAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICAgIGlmICghYWN0aXZlU29ydGFibGUub3B0aW9ucy5zd2FwKSByZXR1cm47XG4gICAgICAgIHZhciBlbCA9IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgIHZhciBwcmV2U3dhcEVsID0gbGFzdFN3YXBFbDtcblxuICAgICAgICAgIGlmIChvbk1vdmUodGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRhcmdldCwgb3B0aW9ucy5zd2FwQ2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgbGFzdFN3YXBFbCA9IHRhcmdldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFN3YXBFbCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByZXZTd2FwRWwgJiYgcHJldlN3YXBFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MocHJldlN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcChfcmVmMykge1xuICAgICAgICB2YXIgYWN0aXZlU29ydGFibGUgPSBfcmVmMy5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjMucHV0U29ydGFibGUsXG4gICAgICAgICAgICBkcmFnRWwgPSBfcmVmMy5kcmFnRWw7XG4gICAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGxhc3RTd2FwRWwgJiYgdG9nZ2xlQ2xhc3MobGFzdFN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcblxuICAgICAgICBpZiAobGFzdFN3YXBFbCAmJiAob3B0aW9ucy5zd2FwIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLm9wdGlvbnMuc3dhcCkpIHtcbiAgICAgICAgICBpZiAoZHJhZ0VsICE9PSBsYXN0U3dhcEVsKSB7XG4gICAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgIHN3YXBOb2RlcyhkcmFnRWwsIGxhc3RTd2FwRWwpO1xuICAgICAgICAgICAgdG9Tb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyhTd2FwLCB7XG4gICAgICBwbHVnaW5OYW1lOiAnc3dhcCcsXG4gICAgICBldmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzd2FwSXRlbTogbGFzdFN3YXBFbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3dhcE5vZGVzKG4xLCBuMikge1xuICAgIHZhciBwMSA9IG4xLnBhcmVudE5vZGUsXG4gICAgICAgIHAyID0gbjIucGFyZW50Tm9kZSxcbiAgICAgICAgaTEsXG4gICAgICAgIGkyO1xuICAgIGlmICghcDEgfHwgIXAyIHx8IHAxLmlzRXF1YWxOb2RlKG4yKSB8fCBwMi5pc0VxdWFsTm9kZShuMSkpIHJldHVybjtcbiAgICBpMSA9IGluZGV4KG4xKTtcbiAgICBpMiA9IGluZGV4KG4yKTtcblxuICAgIGlmIChwMS5pc0VxdWFsTm9kZShwMikgJiYgaTEgPCBpMikge1xuICAgICAgaTIrKztcbiAgICB9XG5cbiAgICBwMS5pbnNlcnRCZWZvcmUobjIsIHAxLmNoaWxkcmVuW2kxXSk7XG4gICAgcDIuaW5zZXJ0QmVmb3JlKG4xLCBwMi5jaGlsZHJlbltpMl0pO1xuICB9XG5cbiAgdmFyIG11bHRpRHJhZ0VsZW1lbnRzID0gW10sXG4gICAgICBtdWx0aURyYWdDbG9uZXMgPSBbXSxcbiAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QsXG4gICAgICAvLyBmb3Igc2VsZWN0aW9uIHdpdGggbW9kaWZpZXIga2V5IGRvd24gKFNISUZUKVxuICBtdWx0aURyYWdTb3J0YWJsZSxcbiAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2UsXG4gICAgICAvLyBJbml0aWFsIG11bHRpLWRyYWcgZm9sZCB3aGVuIGRyYWcgc3RhcnRlZFxuICBmb2xkaW5nID0gZmFsc2UsXG4gICAgICAvLyBGb2xkaW5nIGFueSBvdGhlciB0aW1lXG4gIGRyYWdTdGFydGVkID0gZmFsc2UsXG4gICAgICBkcmFnRWwkMSxcbiAgICAgIGNsb25lc0Zyb21SZWN0LFxuICAgICAgY2xvbmVzSGlkZGVuO1xuXG4gIGZ1bmN0aW9uIE11bHRpRHJhZ1BsdWdpbigpIHtcbiAgICBmdW5jdGlvbiBNdWx0aURyYWcoc29ydGFibGUpIHtcbiAgICAgIC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuICAgICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgfVxuXG4gICAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0tleURvd24pO1xuICAgICAgb24oZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgICAgc2VsZWN0ZWRDbGFzczogJ3NvcnRhYmxlLXNlbGVjdGVkJyxcbiAgICAgICAgbXVsdGlEcmFnS2V5OiBudWxsLFxuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSAnJztcblxuICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICAgIGRhdGEgKz0gKCFpID8gJycgOiAnLCAnKSArIG11bHRpRHJhZ0VsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGRyYWdFbC50ZXh0Q29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIE11bHRpRHJhZy5wcm90b3R5cGUgPSB7XG4gICAgICBtdWx0aURyYWdLZXlEb3duOiBmYWxzZSxcbiAgICAgIGlzTXVsdGlEcmFnOiBmYWxzZSxcbiAgICAgIGRlbGF5U3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRlbGF5U3RhcnRHbG9iYWwoX3JlZikge1xuICAgICAgICB2YXIgZHJhZ2dlZCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgICBkcmFnRWwkMSA9IGRyYWdnZWQ7XG4gICAgICB9LFxuICAgICAgZGVsYXlFbmRlZDogZnVuY3Rpb24gZGVsYXlFbmRlZCgpIHtcbiAgICAgICAgdGhpcy5pc011bHRpRHJhZyA9IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKTtcbiAgICAgIH0sXG4gICAgICBzZXR1cENsb25lOiBmdW5jdGlvbiBzZXR1cENsb25lKF9yZWYyKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYyLnNvcnRhYmxlLFxuICAgICAgICAgICAgY2FuY2VsID0gX3JlZjIuY2FuY2VsO1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLnB1c2goY2xvbmUobXVsdGlEcmFnRWxlbWVudHNbaV0pKTtcbiAgICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc29ydGFibGVJbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzW2ldLnNvcnRhYmxlSW5kZXg7XG4gICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50c1tpXSA9PT0gZHJhZ0VsJDEgJiYgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoX3JlZjMpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjMuc29ydGFibGUsXG4gICAgICAgICAgICByb290RWwgPSBfcmVmMy5yb290RWwsXG4gICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMy5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICAgICAgICBjYW5jZWwgPSBfcmVmMy5jYW5jZWw7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICAgIGluc2VydE11bHRpRHJhZ0Nsb25lcyh0cnVlLCByb290RWwpO1xuICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdjbG9uZScpO1xuICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvd0Nsb25lOiBmdW5jdGlvbiBzaG93Q2xvbmUoX3JlZjQpIHtcbiAgICAgICAgdmFyIGNsb25lTm93U2hvd24gPSBfcmVmNC5jbG9uZU5vd1Nob3duLFxuICAgICAgICAgICAgcm9vdEVsID0gX3JlZjQucm9vdEVsLFxuICAgICAgICAgICAgY2FuY2VsID0gX3JlZjQuY2FuY2VsO1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGZhbHNlLCByb290RWwpO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xvbmVOb3dTaG93bigpO1xuICAgICAgICBjbG9uZXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgaGlkZUNsb25lOiBmdW5jdGlvbiBoaWRlQ2xvbmUoX3JlZjUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgc29ydGFibGUgPSBfcmVmNS5zb3J0YWJsZSxcbiAgICAgICAgICAgIGNsb25lTm93SGlkZGVuID0gX3JlZjUuY2xvbmVOb3dIaWRkZW4sXG4gICAgICAgICAgICBjYW5jZWwgPSBfcmVmNS5jYW5jZWw7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlICYmIGNsb25lLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsb25lTm93SGlkZGVuKCk7XG4gICAgICAgIGNsb25lc0hpZGRlbiA9IHRydWU7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfSxcbiAgICAgIGRyYWdTdGFydEdsb2JhbDogZnVuY3Rpb24gZHJhZ1N0YXJ0R2xvYmFsKF9yZWY2KSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY2LnNvcnRhYmxlO1xuXG4gICAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZyAmJiBtdWx0aURyYWdTb3J0YWJsZSkge1xuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfSk7IC8vIFNvcnQgbXVsdGktZHJhZyBlbGVtZW50c1xuXG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzID0gbXVsdGlEcmFnRWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLnNvcnRhYmxlSW5kZXggLSBiLnNvcnRhYmxlSW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICB9LFxuICAgICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWY3KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY3LnNvcnRhYmxlO1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICAvLyBDYXB0dXJlIHJlY3RzLFxuICAgICAgICAgIC8vIGhpZGUgbXVsdGkgZHJhZyBlbGVtZW50cyAoYnkgcG9zaXRpb25pbmcgdGhlbSBhYnNvbHV0ZSksXG4gICAgICAgICAgLy8gc2V0IG11bHRpIGRyYWcgZWxlbWVudHMgcmVjdHMgdG8gZHJhZ1JlY3QsXG4gICAgICAgICAgLy8gc2hvdyBtdWx0aSBkcmFnIGVsZW1lbnRzLFxuICAgICAgICAgIC8vIGFuaW1hdGUgdG8gcmVjdHMsXG4gICAgICAgICAgLy8gdW5zZXQgcmVjdHMgJiByZW1vdmUgZnJvbSBET01cbiAgICAgICAgICBzb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgICBjc3MobXVsdGlEcmFnRWxlbWVudCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzb3J0YWJsZS5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBSZW1vdmUgYWxsIGF1eGlsaWFyeSBtdWx0aWRyYWcgaXRlbXMgZnJvbSBlbCwgaWYgc29ydGluZyBlbmFibGVkXG5cblxuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5zb3J0KSB7XG4gICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZHJhZ092ZXI6IGZ1bmN0aW9uIGRyYWdPdmVyKF9yZWY4KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBfcmVmOC50YXJnZXQsXG4gICAgICAgICAgICBjb21wbGV0ZWQgPSBfcmVmOC5jb21wbGV0ZWQsXG4gICAgICAgICAgICBjYW5jZWwgPSBfcmVmOC5jYW5jZWw7XG5cbiAgICAgICAgaWYgKGZvbGRpbmcgJiYgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YodGFyZ2V0KSkge1xuICAgICAgICAgIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChfcmVmOSkge1xuICAgICAgICB2YXIgZnJvbVNvcnRhYmxlID0gX3JlZjkuZnJvbVNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsID0gX3JlZjkucm9vdEVsLFxuICAgICAgICAgICAgc29ydGFibGUgPSBfcmVmOS5zb3J0YWJsZSxcbiAgICAgICAgICAgIGRyYWdSZWN0ID0gX3JlZjkuZHJhZ1JlY3Q7XG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBTZXR1cCB1bmZvbGQgYW5pbWF0aW9uXG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgc29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgIHJlY3Q6IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgICAgZnJvbVNvcnRhYmxlLnJlbW92ZUFuaW1hdGlvblN0YXRlKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlLCByb290RWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJhZ092ZXJDb21wbGV0ZWQ6IGZ1bmN0aW9uIGRyYWdPdmVyQ29tcGxldGVkKF9yZWYxMCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBfcmVmMTAuc29ydGFibGUsXG4gICAgICAgICAgICBpc093bmVyID0gX3JlZjEwLmlzT3duZXIsXG4gICAgICAgICAgICBpbnNlcnRpb24gPSBfcmVmMTAuaW5zZXJ0aW9uLFxuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTAuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMC5wYXJlbnRFbCxcbiAgICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEwLnB1dFNvcnRhYmxlO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2U7IC8vIElmIGxlYXZpbmcgc29ydDpmYWxzZSByb290LCBvciBhbHJlYWR5IGZvbGRpbmcgLSBGb2xkIHRvIG5ldyBsb2NhdGlvblxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEgJiYgKGZvbGRpbmcgfHwgIWlzT3duZXIgJiYgIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc29ydCAmJiAhcHV0U29ydGFibGUpKSB7XG4gICAgICAgICAgICAvLyBGb2xkOiBTZXQgYWxsIG11bHRpIGRyYWcgZWxlbWVudHMncyByZWN0cyB0byBkcmFnRWwncyByZWN0IHdoZW4gbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW52aXNpYmxlXG4gICAgICAgICAgICB2YXIgZHJhZ1JlY3RBYnNvbHV0ZSA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3RBYnNvbHV0ZSk7IC8vIE1vdmUgZWxlbWVudChzKSB0byBlbmQgb2YgcGFyZW50RWwgc28gdGhhdCBpdCBkb2VzIG5vdCBpbnRlcmZlcmUgd2l0aCBtdWx0aS1kcmFnIGNsb25lcyBpbnNlcnRpb24gaWYgdGhleSBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgLy8gd2hpbGUgZm9sZGluZywgYW5kIHNvIHRoYXQgd2UgY2FuIGNhcHR1cmUgdGhlbSBhZ2FpbiBiZWNhdXNlIG9sZCBzb3J0YWJsZSB3aWxsIG5vIGxvbmdlciBiZSBmcm9tU29ydGFibGVcblxuICAgICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgICAgfSAvLyBDbG9uZXMgbXVzdCBiZSBzaG93biAoYW5kIGNoZWNrIHRvIHJlbW92ZSBtdWx0aSBkcmFncykgYWZ0ZXIgZm9sZGluZyB3aGVuIGludGVyZmVyaW5nIG11bHRpRHJhZ0VsZW1lbnRzIGFyZSBtb3ZlZCBvdXRcblxuXG4gICAgICAgICAgaWYgKCFpc093bmVyKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlbW92ZSBpZiBub3QgZm9sZGluZyAoZm9sZGluZyB3aWxsIHJlbW92ZSB0aGVtIGFueXdheXMpXG4gICAgICAgICAgICBpZiAoIWZvbGRpbmcpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGNsb25lc0hpZGRlbkJlZm9yZSA9IGNsb25lc0hpZGRlbjtcblxuICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTsgLy8gVW5mb2xkIGFuaW1hdGlvbiBmb3IgY2xvbmVzIGlmIHNob3dpbmcgZnJvbSBoaWRkZW5cblxuXG4gICAgICAgICAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhY2xvbmVzSGlkZGVuICYmIGNsb25lc0hpZGRlbkJlZm9yZSkge1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNsb25lLFxuICAgICAgICAgICAgICAgICAgICByZWN0OiBjbG9uZXNGcm9tUmVjdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjbG9uZS5mcm9tUmVjdCA9IGNsb25lc0Zyb21SZWN0O1xuICAgICAgICAgICAgICAgICAgY2xvbmUudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShzb3J0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlOiBmdW5jdGlvbiBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUoX3JlZjExKSB7XG4gICAgICAgIHZhciBkcmFnUmVjdCA9IF9yZWYxMS5kcmFnUmVjdCxcbiAgICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTEuaXNPd25lcixcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjExLmFjdGl2ZVNvcnRhYmxlO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYWN0aXZlU29ydGFibGUub3B0aW9ucy5hbmltYXRpb24gJiYgIWlzT3duZXIgJiYgYWN0aXZlU29ydGFibGUubXVsdGlEcmFnLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgICAgY2xvbmVzRnJvbVJlY3QgPSBfZXh0ZW5kcyh7fSwgZHJhZ1JlY3QpO1xuICAgICAgICAgIHZhciBkcmFnTWF0cml4ID0gbWF0cml4KGRyYWdFbCQxLCB0cnVlKTtcbiAgICAgICAgICBjbG9uZXNGcm9tUmVjdC50b3AgLT0gZHJhZ01hdHJpeC5mO1xuICAgICAgICAgIGNsb25lc0Zyb21SZWN0LmxlZnQgLT0gZHJhZ01hdHJpeC5lO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKGZvbGRpbmcpIHtcbiAgICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjEyKSB7XG4gICAgICAgIHZhciBldnQgPSBfcmVmMTIub3JpZ2luYWxFdmVudCxcbiAgICAgICAgICAgIHJvb3RFbCA9IF9yZWYxMi5yb290RWwsXG4gICAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMi5wYXJlbnRFbCxcbiAgICAgICAgICAgIHNvcnRhYmxlID0gX3JlZjEyLnNvcnRhYmxlLFxuICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjEyLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICAgIG9sZEluZGV4ID0gX3JlZjEyLm9sZEluZGV4LFxuICAgICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMTIucHV0U29ydGFibGU7XG4gICAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgICAgaWYgKCFldnQpIHJldHVybjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHBhcmVudEVsLmNoaWxkcmVuOyAvLyBNdWx0aS1kcmFnIHNlbGVjdGlvblxuXG4gICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5tdWx0aURyYWdLZXkgJiYgIXRoaXMubXVsdGlEcmFnS2V5RG93bikge1xuICAgICAgICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwkMSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCAhfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKTtcblxuICAgICAgICAgIGlmICghfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGRyYWdFbCQxKTtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnc2VsZWN0JyxcbiAgICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgICB9KTsgLy8gTW9kaWZpZXIgYWN0aXZhdGVkLCBzZWxlY3QgZnJvbSBsYXN0IHRvIGRyYWdFbFxuXG4gICAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5ICYmIGxhc3RNdWx0aURyYWdTZWxlY3QgJiYgc29ydGFibGUuZWwuY29udGFpbnMobGFzdE11bHRpRHJhZ1NlbGVjdCkpIHtcbiAgICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4KGxhc3RNdWx0aURyYWdTZWxlY3QpLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gaW5kZXgoZHJhZ0VsJDEpO1xuXG4gICAgICAgICAgICAgIGlmICh+bGFzdEluZGV4ICYmIH5jdXJyZW50SW5kZXggJiYgbGFzdEluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGluY2x1ZGUgbGFzdE11bHRpRHJhZ1NlbGVjdCAoc2VsZWN0IGl0KSwgaW4gY2FzZSBtb2RpZmllZCBzZWxlY3Rpb24gZnJvbSBubyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAoYnV0IHByZXZpb3VzIHNlbGVjdGlvbiBleGlzdGVkKVxuICAgICAgICAgICAgICAgIHZhciBuLCBpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgaSA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgIG4gPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgICBuID0gbGFzdEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGNoaWxkcmVuW2ldKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZHJlbltpXSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbDogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IGRyYWdFbCQxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNwbGljZShtdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSwgMSk7XG4gICAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgICB0YXJnZXRFbDogZHJhZ0VsJDEsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBNdWx0aS1kcmFnIGRyb3BcblxuXG4gICAgICAgIGlmIChkcmFnU3RhcnRlZCAmJiB0aGlzLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgICAgLy8gRG8gbm90IFwidW5mb2xkXCIgYWZ0ZXIgYXJvdW5kIGRyYWdFbCBpZiByZXZlcnRlZFxuICAgICAgICAgIGlmICgocGFyZW50RWxbZXhwYW5kb10ub3B0aW9ucy5zb3J0IHx8IHBhcmVudEVsICE9PSByb290RWwpICYmIG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEpLFxuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4ID0gaW5kZXgoZHJhZ0VsJDEsICc6bm90KC4nICsgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MgKyAnKScpO1xuICAgICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZyAmJiBvcHRpb25zLmFuaW1hdGlvbikgZHJhZ0VsJDEudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0VsJDEuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3Q7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuZnJvbVJlY3QgPSByZWN0OyAvLyBQcmVwYXJlIHVuZm9sZCBhbmltYXRpb25cblxuICAgICAgICAgICAgICAgICAgICB0b1NvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSAvLyBNdWx0aSBkcmFnIGVsZW1lbnRzIGFyZSBub3QgbmVjZXNzYXJpbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00gb24gZHJvcCwgc28gdG8gcmVpbnNlcnRcbiAgICAgICAgICAgICAgLy8gcHJvcGVybHkgdGhleSBtdXN0IGFsbCBiZSByZW1vdmVkXG5cblxuICAgICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKG11bHRpRHJhZ0VsZW1lbnQsIGNoaWxkcmVuW211bHRpRHJhZ0luZGV4XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4Kys7XG4gICAgICAgICAgICAgIH0pOyAvLyBJZiBpbml0aWFsIGZvbGRpbmcgaXMgZG9uZSwgdGhlIGVsZW1lbnRzIG1heSBoYXZlIGNoYW5nZWQgcG9zaXRpb24gYmVjYXVzZSB0aGV5IGFyZSBub3dcbiAgICAgICAgICAgICAgLy8gdW5mb2xkaW5nIGFyb3VuZCBkcmFnRWwsIGV2ZW4gdGhvdWdoIGRyYWdFbCBtYXkgbm90IGhhdmUgaGlzIGluZGV4IGNoYW5nZWQsIHNvIHVwZGF0ZSBldmVudFxuICAgICAgICAgICAgICAvLyBtdXN0IGJlIGZpcmVkIGhlcmUgYXMgU29ydGFibGUgd2lsbCBub3QuXG5cbiAgICAgICAgICAgICAgaWYgKG9sZEluZGV4ID09PSBpbmRleChkcmFnRWwkMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCAhPT0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCd1cGRhdGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gTXVzdCBiZSBkb25lIGFmdGVyIGNhcHR1cmluZyBpbmRpdmlkdWFsIHJlY3RzIChzY3JvbGwgYmFyKVxuXG5cbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZSA9IHRvU29ydGFibGU7XG4gICAgICAgIH0gLy8gUmVtb3ZlIGNsb25lcyBpZiBuZWNlc3NhcnlcblxuXG4gICAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICBjbG9uZS5wYXJlbnROb2RlICYmIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbnVsbGluZ0dsb2JhbDogZnVuY3Rpb24gbnVsbGluZ0dsb2JhbCgpIHtcbiAgICAgICAgdGhpcy5pc011bHRpRHJhZyA9IGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5sZW5ndGggPSAwO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lHbG9iYWw6IGZ1bmN0aW9uIGRlc3Ryb3lHbG9iYWwoKSB7XG4gICAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgICB9LFxuICAgICAgX2Rlc2VsZWN0TXVsdGlEcmFnOiBmdW5jdGlvbiBfZGVzZWxlY3RNdWx0aURyYWcoZXZ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ1N0YXJ0ZWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZHJhZ1N0YXJ0ZWQpIHJldHVybjsgLy8gT25seSBkZXNlbGVjdCBpZiBzZWxlY3Rpb24gaXMgaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAhPT0gdGhpcy5zb3J0YWJsZSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIHRhcmdldCBpcyBub3QgaXRlbSBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgICAgaWYgKGV2dCAmJiBjbG9zZXN0KGV2dC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuc29ydGFibGUuZWwsIGZhbHNlKSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIGxlZnQgY2xpY2tcblxuICAgICAgICBpZiAoZXZ0ICYmIGV2dC5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICB3aGlsZSAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGVsID0gbXVsdGlEcmFnRWxlbWVudHNbMF07XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc2hpZnQoKTtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLnNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiB0aGlzLnNvcnRhYmxlLmVsLFxuICAgICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICAgIHRhcmdldEVsOiBlbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jaGVja0tleURvd246IGZ1bmN0aW9uIF9jaGVja0tleURvd24oZXZ0KSB7XG4gICAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jaGVja0tleVVwOiBmdW5jdGlvbiBfY2hlY2tLZXlVcChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzKE11bHRpRHJhZywge1xuICAgICAgLy8gU3RhdGljIG1ldGhvZHMgJiBwcm9wZXJ0aWVzXG4gICAgICBwbHVnaW5OYW1lOiAnbXVsdGlEcmFnJyxcbiAgICAgIHV0aWxzOiB7XG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxyXG4gICAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBzZWxlY3RlZFxyXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChlbCkge1xuICAgICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb107XG4gICAgICAgICAgaWYgKCFzb3J0YWJsZSB8fCAhc29ydGFibGUub3B0aW9ucy5tdWx0aURyYWcgfHwgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpKSByZXR1cm47XG5cbiAgICAgICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgJiYgbXVsdGlEcmFnU29ydGFibGUgIT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgICBtdWx0aURyYWdTb3J0YWJsZS5tdWx0aURyYWcuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG5cbiAgICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgVGhlIGVsZW1lbnQgdG8gYmUgZGVzZWxlY3RlZFxyXG4gICAgICAgICAqL1xuICAgICAgICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWwpIHtcbiAgICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dLFxuICAgICAgICAgICAgICBpbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpO1xuICAgICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8ICF+aW5kZXgpIHJldHVybjtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc29ydGFibGUub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgb2xkSW5kaWNpZXMgPSBbXSxcbiAgICAgICAgICAgIG5ld0luZGljaWVzID0gW107XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICBvbGRJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICBpbmRleDogbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4XG4gICAgICAgICAgfSk7IC8vIG11bHRpRHJhZ0VsZW1lbnRzIHdpbGwgYWxyZWFkeSBiZSBzb3J0ZWQgaWYgZm9sZGluZ1xuXG4gICAgICAgICAgdmFyIG5ld0luZGV4O1xuXG4gICAgICAgICAgaWYgKGZvbGRpbmcgJiYgbXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb2xkaW5nKSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQsICc6bm90KC4nICsgX3RoaXMzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3SW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGl0ZW1zOiBfdG9Db25zdW1hYmxlQXJyYXkobXVsdGlEcmFnRWxlbWVudHMpLFxuICAgICAgICAgIGNsb25lczogW10uY29uY2F0KG11bHRpRHJhZ0Nsb25lcyksXG4gICAgICAgICAgb2xkSW5kaWNpZXM6IG9sZEluZGljaWVzLFxuICAgICAgICAgIG5ld0luZGljaWVzOiBuZXdJbmRpY2llc1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIG9wdGlvbkxpc3RlbmVyczoge1xuICAgICAgICBtdWx0aURyYWdLZXk6IGZ1bmN0aW9uIG11bHRpRHJhZ0tleShrZXkpIHtcbiAgICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIGlmIChrZXkgPT09ICdjdHJsJykge1xuICAgICAgICAgICAga2V5ID0gJ0NvbnRyb2wnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoY2xvbmVzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQsIGkpIHtcbiAgICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICsgKGNsb25lc0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgdGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBJbnNlcnQgbXVsdGktZHJhZyBjbG9uZXNcclxuICAgKiBAcGFyYW0gIHtbQm9vbGVhbl19IGVsZW1lbnRzSW5zZXJ0ZWQgIFdoZXRoZXIgdGhlIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGluc2VydGVkXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHJvb3RFbFxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGVsZW1lbnRzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSwgaSkge1xuICAgICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlbltjbG9uZS5zb3J0YWJsZUluZGV4ICsgKGVsZW1lbnRzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZSwgdGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpIHtcbiAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZSAmJiBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgfSk7XG4gIH1cblxuICBTb3J0YWJsZS5tb3VudChuZXcgQXV0b1Njcm9sbFBsdWdpbigpKTtcbiAgU29ydGFibGUubW91bnQoUmVtb3ZlLCBSZXZlcnQpO1xuXG4gIFNvcnRhYmxlLm1vdW50KG5ldyBTd2FwUGx1Z2luKCkpO1xuICBTb3J0YWJsZS5tb3VudChuZXcgTXVsdGlEcmFnUGx1Z2luKCkpO1xuXG4gIHJldHVybiBTb3J0YWJsZTtcblxufSkpO1xuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9tb2R1bGVzL3V0aWxzLm1qcydcbmltcG9ydCAqIGFzIHNlYXJjaCBmcm9tICcuL21vZHVsZXMvc2VhcmNoLm1qcydcbmltcG9ydCB0b2dnbGVQcmVmZXJlbmNlcyBmcm9tICcuL21vZHVsZXMvdG9nZ2xlUHJlZmVyZW5jZXMubWpzJ1xuaW1wb3J0IHVyZ2VudEFubm91bmNlbWVudCBmcm9tICcuL3dlYi1jb21wb25lbnRzL3VyZ2VudC1hbm5vdW5jZW1lbnQubWpzJ1xuaW1wb3J0IHsgV0NfYW5ub3VuY2VtZW50c1dpZGdldCB9IGZyb20gJy4vd2ViLWNvbXBvbmVudHMvYW5ub3VuY2VtZW50cy5tanMnXG5pbXBvcnQgKiBhcyB1bnJlYWRBbm5vdW5jZW1lbnRzIGZyb20gJy4vbW9kdWxlcy91bnJlYWRBbm5vdW5jZW1lbnRzLm1qcydcbmltcG9ydCAqIGFzIG5vdGlmeSBmcm9tICcuL21vZHVsZXMvbm90aWZ5Lm1qcydcbmltcG9ydCBkcmFnQW5kRHJvcCBmcm9tICcuL21vZHVsZXMvZHJhZy1hbmQtZHJvcC5tanMnXG5cbmNvbnN0IHBhZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYWluJykuaWQudG9Mb3dlckNhc2UoKVxuXG4vL2luaXQgd2ViIGNvbXBvbmVudHNcbmlmIChwYWdlID09PSAnZGFzaGJvYXJkJykge1xuICAgIHV0aWxzLmFwcGVuZFdpZGdldHModXRpbHMuZ2V0UHJlZmVyZW5jZXMoKSlcblxuICAgIC8vIGRyYWdBbmREcm9wKClcbn1cblxuaWYgKHBhZ2UgPT09ICdhY2NvdW50Jykge1xuICAgIHRvZ2dsZVByZWZlcmVuY2VzKClcbn1cblxuaWYgKHBhZ2UgPT09ICdhbm5vdW5jZW1lbnRzLW92ZXJ2aWV3Jykge1xuICAgIGNvbnN0IGFubm91bmNlbWVudExpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5ub3VuY2VtZW50cycpXG4gICAgYW5ub3VuY2VtZW50TGlzdC5yZW1vdmUoKVxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4gc2VjdGlvbicpLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhbm5vdW5jZW1lbnRzLXdpZGdldCcpKVxuICAgIFdDX2Fubm91bmNlbWVudHNXaWRnZXQocGFnZSlcbn1cblxuXG4vL2NoZWNrIGlmIGJyb3dzZXIgaXMgb25saW5lXG5pZiAobmF2aWdhdG9yLm9uTGluZSkge1xuICAgIC8vdXJnZW50IGFubm91bmNlbWVudHNcbiAgICBjb25zdCBzb2NrZXQgPSBpbygpXG5cbiAgICAvL3N1YnNjcmliZSB0byB1cmdlbnQtYW5ub3VuY2VtZW50c1xuICAgIHNvY2tldC5lbWl0KCdqb2luJywgcGFnZSlcblxuICAgIC8vb24gdXJnZW50LWFubm91bmNlbWVudCBob29rIHVwZGF0ZSBpbnRlcmZhY2UgKHNlZSBXQ191cmdlbnRBbm5vdW5jZW1lbnQpXG4gICAgc29ja2V0Lm9uKCd1cmdlbnQtYW5ub3VuY2VtZW50JywgYW5ub3VuY2VtZW50ID0+IHtcbiAgICAgICAgY29uc3QgdXJnZW50QW5ub3VuY2VtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndXJnZW50LWFubm91bmNlbWVudCcpXG5cbiAgICAgICAgaWYgKHV0aWxzLmV4aXN0cyhbdXJnZW50QW5ub3VuY2VtZW50XSkpIHtcbiAgICAgICAgICAgIHVyZ2VudEFubm91bmNlbWVudC5zZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnLCBhbm5vdW5jZW1lbnQuY29udGVudClcbiAgICAgICAgICAgIHVyZ2VudEFubm91bmNlbWVudC5zZXRBdHRyaWJ1dGUoJ3VpZCcsIGFubm91bmNlbWVudC5uZXdzSXRlbUlkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdykge1xuICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVhZHkgLy93YWl0IGZvciBzdyB0byBiZSByZWFkeVxuICAgICAgICAgICAgICAgIC50aGVuKHJlZ2lzdHJhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbihzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZ5LmRpc3BsYXlOb3RpZmljYXRpb24oYW5ub3VuY2VtZW50LnRpdGxlLCBhbm5vdW5jZW1lbnQuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuXG5cblxuLy9tZW51IFxuY29uc3QgbWVudUljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudS1pY29uJylcbmNvbnN0IG1lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudScpXG5cbmlmICh1dGlscy5leGlzdHMoW21lbnVJY29uLCBtZW51XSkpIHtcblxuICAgIC8vdG9nZ2xlIG1lbnUgKG9uIG1vYmlsZSlcbiAgICBtZW51SWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgbWVudS5jbGFzc0xpc3QudG9nZ2xlKCdoaWRlJylcbiAgICB9KVxufVxuXG5cblxuXG4vL3NlYXJjaCBcbmNvbnN0IHNlYXJjaEJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gtYmFyJylcbmNvbnN0IHNlYXJjaFJlc2V0SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gtcmVzZXQnKVxuY29uc3Qgc2VhcmNoSWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWFyY2gtY29udGFpbmVyIGlucHV0W3R5cGU9c3VibWl0XScpXG5cbmlmICh1dGlscy5leGlzdHMoW3NlYXJjaEJhciwgc2VhcmNoUmVzZXRJY29uLCBzZWFyY2hJY29uXSkpIHtcblxuICAgIC8vY29udHJvbCBzZWFyY2gtcmVzZXQgaWNvbiBcbiAgICBzZWFyY2hCYXIuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiBzZWFyY2guc2hvd1Jlc2V0KCkpXG4gICAgc2VhcmNoQmFyLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiBzZWFyY2guaGlkZVJlc2V0KCkpXG5cblxuICAgIC8vcmVzZXQgc2VhcmNoIGlucHV0XG4gICAgc2VhcmNoUmVzZXRJY29uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiBzZWFyY2gucmVzZXQoZSkpXG5cblxuICAgIC8vZGVwZW5kaW5nIG9uIHNlYXJjaC1xdWVyeSBlaXRoZXIgZ2l2ZSBmb2N1cyB0byBzZWFyY2hiYXIgb3Igc3VibWl0IHNlYXJjaC1xdWVyeVxuICAgIHNlYXJjaEljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgICAgaWYgKHNlYXJjaEJhci52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgc2VhcmNoLmZvY3VzKGUpXG4gICAgICAgIH1cbiAgICB9KVxuXG5cbiAgICAvL2xpc3RlbiB0byBrZXlib2FyZCBpbnB1dFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICAgICAgc2VhcmNoLmZvY3VzKGUpIC8vZ2l2ZSBzZWFyY2hiYXIgZm9jdXMgYW5kIGhpZGUgc2VhcmNoLXJlc2V0IGljb25cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgfSlcbn1cblxuXG4vL3VucmVhZCBhbm5vdW5jZW1lbnQgaW5kaWNhdG9yIGluIG1lbnVcbmNvbnN0IGFubm91bmNlbWVudE1lbnVJdGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21lbnUtcHJpbWFyeS1saW5rcyBhOmxhc3Qtb2YtdHlwZScpXG5cbmlmICh1dGlscy5leGlzdHMoW2Fubm91bmNlbWVudE1lbnVJdGVtXSkgJiYgdXRpbHMuc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJykpIHtcbiAgICB1bnJlYWRBbm5vdW5jZW1lbnRzLmluZGljYXRlKGFubm91bmNlbWVudE1lbnVJdGVtKVxufSIsImltcG9ydCBTb3J0YWJsZSBmcm9tICdzb3J0YWJsZWpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcmFnQW5kRHJvcCgpIHtcbiAgICBjb25zdCB3aWRnZXRDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd2lkZ2V0LWNvbnRhaW5lcicpXG5cbiAgICBuZXcgU29ydGFibGUod2lkZ2V0Q29udGFpbmVyLCB7XG4gICAgICAgIGFuaW1hdGlvbjogMTUwLFxuICAgICAgICBvblN0YXJ0OiAoZXZlbnQpID0+IGNvbnNvbGUubG9nKGV2ZW50KSxcbiAgICAgICAgb25FbmQ6IChldmVudCkgPT4gY29uc29sZS5sb2coZXZlbnQpXG4gICAgfSlcbn0iLCJleHBvcnQgZnVuY3Rpb24gZGlzcGxheU5vdGlmaWNhdGlvbih0aXRsZSwgYm9keSkge1xuICAgIGlmIChOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gJ2dyYW50ZWQnKSB7XG4gICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmdldFJlZ2lzdHJhdGlvbigpLnRoZW4ocmVnID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBpY29uOiAnLi9tZWRpYS9pY29ucy9odmEtbG9nby1wdXJwbGUuc3ZnJyxcbiAgICAgICAgICAgICAgICB2aWJyYXRlOiBbMTAwLCA1MCwgMTAwXSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2dvdG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdHbyB0byBIdkEgUG9ydGFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICcuL21lZGlhL2ljb25zL2h2YS1sb2dvLXB1cnBsZS5zdmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnQ2xvc2Ugbm90aWZpY2F0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246ICcuL21lZGlhL2ljb25zL2h2YS1sb2dvLXB1cnBsZS5zdmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnLnNob3dOb3RpZmljYXRpb24odGl0bGUsIG9wdGlvbnMpXG4gICAgICAgIH0pXG4gICAgfVxufSIsImNvbnN0IHNlYXJjaEJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gtYmFyJylcbmNvbnN0IHNlYXJjaFJlc2V0SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gtcmVzZXQnKVxuXG5leHBvcnQgZnVuY3Rpb24gZm9jdXMoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHNlYXJjaEJhci5mb2N1cygpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93UmVzZXQoKSB7XG4gICAgc2VhcmNoUmVzZXRJY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZVJlc2V0KCkge1xuICAgIGlmIChzZWFyY2hCYXIudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgc2VhcmNoUmVzZXRJY29uLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KGUpIHtcbiAgICBzZWFyY2hCYXIudmFsdWUgPSBcIlwiXG4gICAgZm9jdXMoZSlcbn0iLCJpbXBvcnQgeyBzZXRMb2NhbFN0b3JhZ2UsIGdldExvY2FsU3RvcmFnZSB9IGZyb20gJy4uL21vZHVsZXMvdXRpbHMubWpzJ1xuaW1wb3J0IFNvcnRhYmxlIGZyb20gJ3NvcnRhYmxlanMnXG5cbmNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNhY2NvdW50IGZvcm0nKVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9nZ2xlUHJlZmVyZW5jZXMoKSB7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcblxuICAgIGdldFByZWZlcmVuY2VzKClcbiAgICBzdGF0ZUhhbmRsZXIoKVxuICAgIGRyYWdIYW5kbGVyKClcbn1cblxuZnVuY3Rpb24gZ2V0UHJlZmVyZW5jZXMoKSB7XG4gICAgY29uc3QgcHJlZmVyZW5jZXMgPSBnZXRMb2NhbFN0b3JhZ2UoJ3ByZWZlcmVuY2VzJylcbiAgICBpZiAocHJlZmVyZW5jZXMpIHtcbiAgICAgICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJydcbiAgICAgICAgcHJlZmVyZW5jZXMuZm9yRWFjaChwcmVmZXJlbmNlID0+IGNvbnRhaW5lci5hcHBlbmQoY3JlYXRlTGFiZWxzKHByZWZlcmVuY2UpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRQcmVmZXJlbmNlc09iamVjdCgpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFnSGFuZGxlcigpIHtcbiAgICBjb25zdCBwcmVmZXJlbmNlc0NvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcmVmZXJlbmNlcycpXG5cbiAgICBuZXcgU29ydGFibGUocHJlZmVyZW5jZXNDb250YWluZXIsIHtcbiAgICAgICAgZHJhZ2dhYmxlOiBcIi5vblwiLFxuICAgICAgICBhbmltYXRpb246IDE1MCxcbiAgICAgICAgb25TdGFydDogKGV2ZW50KSA9PiBhZGRTdHlsaW5nVG9Ecm9wWm9uZXMoZXZlbnQpLFxuICAgICAgICBvbkVuZDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZW1vdmVTdHlsaW5nRnJvbURyb3Bab25lcyhldmVudClcbiAgICAgICAgICAgIHNldFByZWZlcmVuY2VzT2JqZWN0KClcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxpbmdUb0Ryb3Bab25lcyhldmVudCkge1xuICAgIGNvbnN0IGRyYWdMb2NhdGlvbnMgPSBbLi4uZXZlbnQudGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xhYmVsOm5vdCguc29ydGFibGUtY2hvc2VuKScpXVxuICAgIGRyYWdMb2NhdGlvbnMuZm9yRWFjaChsb2NhdGlvbiA9PiBsb2NhdGlvbi5jbGFzc0xpc3QuYWRkKCdvcHRpb25hbC1sb2NhdGlvbicpKVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsaW5nRnJvbURyb3Bab25lcyhldmVudCkge1xuICAgIGNvbnN0IGRyYWdMb2NhdGlvbnMgPSBbLi4uZXZlbnQudGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xhYmVsOm5vdCguc29ydGFibGUtY2hvc2VuKScpXVxuICAgIGRyYWdMb2NhdGlvbnMuZm9yRWFjaChsb2NhdGlvbiA9PiBsb2NhdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdvcHRpb25hbC1sb2NhdGlvbicpKVxufVxuXG4vLyBTYXZpbmcgYW5kIGNoYW5naW5nIHByZWZlcmVuY2VzIFxuZnVuY3Rpb24gc2V0UHJlZmVyZW5jZXNPYmplY3QoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNhY2NvdW50IGZvcm0gbGFiZWwnKV1cbiAgICBsZXQgcHJlZmVyZW5jZXMgPSBbXVxuXG4gICAgaW5wdXRzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICAvLyBEYXRhXG4gICAgICAgIGNvbnN0IGlkID0gbGFiZWwuaWRcbiAgICAgICAgY29uc3QgdGV4dCA9IGxhYmVsLnRleHRDb250ZW50XG4gICAgICAgIGNvbnN0IHN0YXRlID0gbGFiZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKS5jaGVja2VkXG5cbiAgICAgICAgLy8gU2V0IExvY2FsU3RvcmFnZVxuICAgICAgICBjb25zdCBvYmplY3QgPSB7IGlkOiBpZCwgbmFtZTogdGV4dCwgc3RhdGU6IHN0YXRlIH1cbiAgICAgICAgcHJlZmVyZW5jZXMucHVzaChvYmplY3QpXG4gICAgICAgIHNldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnLCBwcmVmZXJlbmNlcylcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByZWZlcmVuY2VzXG59XG5cbmZ1bmN0aW9uIHN0YXRlSGFuZGxlcigpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2FjY291bnQgZm9ybSBsYWJlbCcpXVxuICAgIGNvbnN0IGRhdGEgPSBnZXRMb2NhbFN0b3JhZ2UoJ3ByZWZlcmVuY2VzJylcblxuICAgIGlucHV0cy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgdXBkYXRlU3RhdGUoZGF0YSwgbGFiZWwpXG5cbiAgICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgLy8gRGF0YVxuICAgICAgICAgICAgY29uc3QgaWQgPSBsYWJlbC5pZFxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBldmVudC50YXJnZXQuY2hlY2tlZFxuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgTG9jYWxTdG9yYWdlXG4gICAgICAgICAgICBjb25zdCBwcmVmZXJlbmNlID0gZGF0YS5maW5kKHByZWZlcmVuY2UgPT4gcHJlZmVyZW5jZS5pZCA9PT0gaWQpXG4gICAgICAgICAgICBwcmVmZXJlbmNlLnN0YXRlID0gc3RhdGVcbiAgICAgICAgICAgIHNldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnLCBkYXRhKVxuXG4gICAgICAgICAgICAvLyBDaGFuZ2Ugc3RhdGUgdmlzdWFseVxuICAgICAgICAgICAgaWYgKHByZWZlcmVuY2Uuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdvbicpXG4gICAgICAgICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnb2ZmJylcbiAgICAgICAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKCdvbicpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKVxuICAgICAgICAgICAgICAgIHNldFByZWZlcmVuY2VzT2JqZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShkYXRhLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcHJlZmVyZW5jZSA9IGRhdGEuZmluZChwcmVmZXJlbmNlID0+IHByZWZlcmVuY2UuaWQgPT09IGVsZW1lbnQuaWQpXG4gICAgcHJlZmVyZW5jZS5zdGF0ZSA/IGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmJykgOiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ29uJylcbn1cblxuLy8gUmVhcmFuZ2luZyBvcmRlclxuZnVuY3Rpb24gY3JlYXRlTGFiZWxzKHByZWZlcmVuY2UpIHtcbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICBsYWJlbC5pZCA9IHByZWZlcmVuY2UuaWRcbiAgICBwcmVmZXJlbmNlLnN0YXRlID8gbGFiZWwuY2xhc3NOYW1lID0gJ29uJyA6IGxhYmVsLmNsYXNzTmFtZSA9ICdvZmYnXG5cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3JlcHJlc2VudHMnLCBwcmVmZXJlbmNlLmlkKVxuXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgaW5wdXQudHlwZSA9ICdjaGVja2JveCdcbiAgICBpbnB1dC5jaGVja2VkID0gcHJlZmVyZW5jZS5zdGF0ZVxuXG4gICAgbGFiZWwuYXBwZW5kKGlucHV0KVxuICAgIGxhYmVsLmFwcGVuZChwcmVmZXJlbmNlLm5hbWUpXG5cbiAgICByZXR1cm4gbGFiZWxcbn0iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLm1qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGluZGljYXRlKGl0ZW0pIHtcbiAgICBnZXRVbnJlYWQoKVxuICAgICAgICAudGhlbihudW1iZXJVbnJlYWQgPT4ge1xuICAgICAgICAgICAgaWYgKG51bWJlclVucmVhZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3VucmVhZC1pbmRpY2F0b3InKVxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdudW1iZXItdW5yZWFkJywgbnVtYmVyVW5yZWFkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxufVxuXG5cbmZ1bmN0aW9uIGdldEFubm91bmNlbWVudHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2goJy9hbm5vdW5jZW1lbnRzbGlzdCcsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG59XG5cbmZ1bmN0aW9uIGdldFVucmVhZCgpIHtcbiAgICBjb25zdCBzdG9yZWRIaXN0b3J5ID0gdXRpbHMuZ2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknKVxuICAgIGNvbnN0IG51bWJlclVucmVhZCA9IGdldEFubm91bmNlbWVudHMoKVxuICAgICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFthbm5vdW5jZW1lbnRzLCBjYXRlZ29yaWVzXSA9IGpzb25cbiAgICAgICAgICAgIHJldHVybiBhbm5vdW5jZW1lbnRzXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGFubm91bmNlbWVudHMgPT4ge1xuICAgICAgICAgICAgbGV0IG51bWJlck9mVW5yZWFkID0gMFxuICAgICAgICAgICAgaWYgKHN0b3JlZEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhbm5vdW5jZW1lbnRzLmZvckVhY2goYW5ub3VuY2VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZWRIaXN0b3J5LmluY2x1ZGVzKGFubm91bmNlbWVudC5uZXdzSXRlbUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZVbnJlYWQrK1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21lbnUtcHJpbWFyeS1saW5rcyBhOmxhc3Qtb2YtdHlwZScpLmNsYXNzTGlzdC5hZGQoJ3VucmVhZC1pbmRpY2F0b3InKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZW51LXByaW1hcnktbGlua3MgYTpsYXN0LW9mLXR5cGUnKS5zZXRBdHRyaWJ1dGUoJ251bWJlci11bnJlYWQnLCBhbm5vdW5jZW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1iZXJPZlVucmVhZFxuICAgICAgICB9KVxuICAgIHJldHVybiBudW1iZXJVbnJlYWRcbn0iLCJpbXBvcnQgeyBXQ19zdHVkeXByb2dyZXNzIH0gZnJvbSAnLi4vd2ViLWNvbXBvbmVudHMvc3R1ZHktcHJvZ3Jlc3MubWpzJ1xuaW1wb3J0IHsgV0Nfc2NoZWR1bGVXaWRnZXQgfSBmcm9tICcuLi93ZWItY29tcG9uZW50cy9zY2hlZHVsZS5tanMnXG5pbXBvcnQgeyBXQ19jb3Vyc2VvdmVydmlldyB9IGZyb20gJy4uL3dlYi1jb21wb25lbnRzL2NvdXJzZS1vdmVydmlldy5tanMnXG5pbXBvcnQgeyBXQ19hbm5vdW5jZW1lbnRzV2lkZ2V0IH0gZnJvbSAnLi4vd2ViLWNvbXBvbmVudHMvYW5ub3VuY2VtZW50cy5tanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoWy4uLnZhcmlhYmxlc10pIHtcbiAgICBjb25zdCBleGlzdHMgPSB2YXJpYWJsZXMuZXZlcnkodmFyaWFibGUgPT4gdmFyaWFibGUgIT0gbnVsbClcbiAgICByZXR1cm4gZXhpc3RzXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExvY2FsU3RvcmFnZShuYW1lLCBpdGVtKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkoaXRlbSkpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZShpdGVtKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oaXRlbSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHsgLy9zb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkvVXNpbmdfdGhlX1dlYl9TdG9yYWdlX0FQSVxuICAgIGxldCBzdG9yYWdlXG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXVxuICAgICAgICBsZXQgeCA9ICdfX3N0b3JhZ2VfdGVzdF9fJ1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeClcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiAoXG4gICAgICAgICAgICAgICAgZS5jb2RlID09PSAyMiB8fFxuICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gMTAxNCB8fFxuICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHxcbiAgICAgICAgICAgICAgICBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpICYmXG4gICAgICAgICAgICAoc3RvcmFnZSAmJiBzdG9yYWdlLmxlbmd0aCAhPT0gMClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVmZXJlbmNlcygpIHtcbiAgICBsZXQgd2lkZ2V0RWxlbWVudHNcblxuICAgIGlmIChzdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICBjb25zdCBwcmVmZXJlbmNlcyA9IGdldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnKVxuICAgICAgICBpZiAocHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzID0gY2hlY2tlcihwcmVmZXJlbmNlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzID0gWydhbm5vdW5jZW1lbnRzLXdpZGdldCcsICdzdHVkeS1wcm9ncmVzcycsICdjb3Vyc2Utb3ZlcnZpZXcnLCAnc2NoZWR1bGUtd2lkZ2V0J11cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZGdldEVsZW1lbnRzID0gWydhbm5vdW5jZW1lbnRzLXdpZGdldCcsICdzdHVkeS1wcm9ncmVzcycsICdjb3Vyc2Utb3ZlcnZpZXcnLCAnc2NoZWR1bGUtd2lkZ2V0J11cbiAgICB9XG5cbiAgICByZXR1cm4gd2lkZ2V0RWxlbWVudHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFdpZGdldHMod2lkZ2V0KSB7XG4gICAgLy8gUmVtb3ZlIEVKUyB0ZW1wbGF0ZXNcbiAgICBjb25zdCBkb21FbGVtZW50cyA9IFsnYW5ub3VuY2VtZW50cycsICdzdHVkeS1wcm9ncmVzcycsICdjb3Vyc2Utb3ZlcnZpZXcnLCAnc2NoZWR1bGUnXVxuICAgIGRvbUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KS5yZW1vdmUoKSlcblxuICAgIC8vIEFkZGluZyB3aWRnZXRzXG4gICAgd2lkZ2V0LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3aWRnZXQtY29udGFpbmVyJykuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXRlbSkpXG5cbiAgICAgICAgaWYgKGl0ZW0gPT09ICdzdHVkeS1wcm9ncmVzcycpIHtcbiAgICAgICAgICAgIFdDX3N0dWR5cHJvZ3Jlc3MoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnY291cnNlLW92ZXJ2aWV3Jykge1xuICAgICAgICAgICAgV0NfY291cnNlb3ZlcnZpZXcoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnc2NoZWR1bGUtd2lkZ2V0Jykge1xuICAgICAgICAgICAgV0Nfc2NoZWR1bGVXaWRnZXQoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnYW5ub3VuY2VtZW50cy13aWRnZXQnKSB7XG4gICAgICAgICAgICBXQ19hbm5vdW5jZW1lbnRzV2lkZ2V0KCdkYXNoYm9hcmQnKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrZXIocHJlZmVyZW5jZXMpIHtcbiAgICBjb25zdCB3aWRnZXRFbGVtZW50cyA9IFtdXG5cbiAgICAvLyBBbm5vdW5jZW1lbnRzXG4gICAgcHJlZmVyZW5jZXMuZm9yRWFjaChwcmVmZXJlbmNlID0+IHtcbiAgICAgICAgcHJlZmVyZW5jZS5pZCA9IHBhcnNlSW50KHByZWZlcmVuY2UuaWQpXG5cbiAgICAgICAgaWYgKHByZWZlcmVuY2Uuc3RhdGUgJiYgcHJlZmVyZW5jZS5pZCA9PT0gMCkge1xuICAgICAgICAgICAgd2lkZ2V0RWxlbWVudHMucHVzaCgnYW5ub3VuY2VtZW50cy13aWRnZXQnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJlbmNlLnN0YXRlICYmIHByZWZlcmVuY2UuaWQgPT09IDEpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzLnB1c2goJ3N0dWR5LXByb2dyZXNzJylcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZmVyZW5jZS5zdGF0ZSAmJiBwcmVmZXJlbmNlLmlkID09PSAyKSB7XG4gICAgICAgICAgICB3aWRnZXRFbGVtZW50cy5wdXNoKCdjb3Vyc2Utb3ZlcnZpZXcnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJlbmNlLnN0YXRlICYmIHByZWZlcmVuY2UuaWQgPT09IDMpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzLnB1c2goJ3NjaGVkdWxlLXdpZGdldCcpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHdpZGdldEVsZW1lbnRzXG59IiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vbW9kdWxlcy91dGlscy5tanMnXG5cbmV4cG9ydCB7IGluaXQgYXMgV0NfYW5ub3VuY2VtZW50c1dpZGdldCB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuKjpmb2N1cyB7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cbmgyIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcblx0Zm9udC1mYW1pbHk6IFwiT3BlblNhbnMtUmVndWxhclwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXHRmb250LXdlaWdodDogbGlnaHRlcjtcblx0bGluZS1oZWlnaHQ6IDEuMTtcbn1cbnAge1xuXHRtYXJnaW46IDA7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQge1xuXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyICNhbm5vdW5jZW1lbnQtbGVnZW5kIHAge1xuXHRjb2xvcjogYmxhY2s7XG5cdGZvbnQtc2l6ZTogMTRweDtcblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRtYXJnaW4tcmlnaHQ6IDIwcHg7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcDpsYXN0LW9mLXR5cGUge1xuXHRtYXJnaW4tcmlnaHQ6IDA7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcDo6YmVmb3JlIHtcblx0Y29udGVudDogXCJcIjtcblx0aGVpZ2h0OiAxNXB4O1xuXHRtYXJnaW4tYm90dG9tOiAtMnB4O1xuXHR3aWR0aDogMTVweDtcblx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xuXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5PcGxlaWRpbmc6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNEQzE0M0M7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5GYWN1bHRlaXQ6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNEQ0I2MTQ7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5IdkE6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICMxNDlFREM7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5NZWRlemVnZ2Vuc2NoYXA6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICMxNERDNjk7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgYSB7XG5cdG1hcmdpbjogMCAwIDE1cHggMDtcblx0ZGlzcGxheTogYmxvY2s7XG5cdGNvbG9yOiBibGFjaztcblx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6aG92ZXIge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGMkYyO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6Zm9jdXMge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjREREREREO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQge1xuXHRtYXJnaW46IDA7XG5cdHBhZGRpbmc6IDVweCAwIDVweCAxMHB4O1xuXHRib3JkZXItbGVmdDogNXB4IHNvbGlkO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuT3BsZWlkaW5nIHtcblx0Ym9yZGVyLWNvbG9yOiAjREMxNDNDO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuRmFjdWx0ZWl0IHtcblx0Ym9yZGVyLWNvbG9yOiAjRENCNjE0O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuSHZBIHtcblx0Ym9yZGVyLWNvbG9yOiAjMTQ5RURDO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQuTWVkZXplZ2dlbnNjaGFwIHtcblx0Ym9yZGVyLWNvbG9yOiAjMTREQzY5O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQgcDpmaXJzdC1vZi10eXBlIHtcbiAgICBmb250LWZhbWlseTogXCJPcGVuU2Fucy1Cb2xkXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLnJlYWQgLmFubm91bmNlbWVudCBwOmZpcnN0LW9mLXR5cGUge1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLVJlZ3VsYXJcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbn1cbi5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lciAuYW5ub3VuY2VtZW50IHA6bGFzdC1vZi10eXBlIHtcblx0Y29sb3I6ICM2NjY2NjY7XG5cdGZvbnQtc2l6ZTogMTRweDtcbn0gICAgXG4uYWxsQW5ub3VuY2VtZW50cyB7XG4gICAgbWFyZ2luLXRvcDogMzBweDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZGlzcGxheTogZmxleDtcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5hbGxBbm5vdW5jZW1lbnRzOmhvdmVyLFxuLmFsbEFubm91bmNlbWVudHM6Zm9jdXMge1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5hbGxBbm5vdW5jZW1lbnRzLmhpZGUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAtOTk5OXB4O1xufVxuLmFsbEFubm91bmNlbWVudHMgaW1nIHtcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbn1cbjwvc3R5bGU+XG48ZGl2IGlkPVwiYW5ub3VuY2VtZW50c1wiPjwvZGl2PlxuPGgyPk1lZGVkZWxpbmdlbjwvaDI+XG48ZGl2IGNsYXNzPVwiYW5ub3VuY2VtZW50cy1jb250YWluZXJcIj5cblx0PGRpdiBpZD1cImFubm91bmNlbWVudC1sZWdlbmRcIj48L2Rpdj5cbjwvZGl2PlxuPGEgY2xhc3M9XCJhbGxBbm5vdW5jZW1lbnRzXCIgaHJlZj1cIi9hbm5vdW5jZW1lbnRzL1wiIHRhcmdldD1cIl9zZWxmXCI+QWxsZSBtZWRlZGVsaW5nZW5cblx0PGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvYT5gXG5cbmZ1bmN0aW9uIGluaXQocGFnZU5hbWUpIHtcbiAgICBjbGFzcyBhbm5vdW5jZW1lbnRMaXN0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKClcblxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSlcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKClcbiAgICAgICAgICAgICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Fubm91bmNlbWVudHMsIGNhdGVnb3JpZXNdID0ganNvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUxlZ2VuZGEoY2F0ZWdvcmllcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VOYW1lID09PSAnZGFzaGJvYXJkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3VuY2VtZW50cy5zcGxpY2UoNSwgYW5ub3VuY2VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRBbm5vdW5jZW1lbnRzKGFubm91bmNlbWVudHMpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VtZW50Q29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lcicpXG4gICAgICAgICAgICB0aGlzLmFubm91bmNlbWVudExlZ2VuZCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjYW5ub3VuY2VtZW50LWxlZ2VuZCcpXG5cbiAgICAgICAgICAgIGlmIChwYWdlTmFtZSA9PT0gJ2Fubm91bmNlbWVudHMtb3ZlcnZpZXcnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2phJylcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmFsbEFubm91bmNlbWVudHMnKS5jbGFzc0xpc3QuYWRkKCdoaWRlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKCcvYW5ub3VuY2VtZW50c2xpc3QnLCBvcHRpb25zKS50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgICAgICB9XG5cbiAgICAgICAgY3JlYXRlTGVnZW5kYShjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goY2F0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlbWVudExlZ2VuZC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGA8cCBjbGFzcz1cIiR7Y2F0fVwiPiR7Y2F0fTwvcD5gKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEFubm91bmNlbWVudHMoYW5ub3VuY2VtZW50cykge1xuICAgICAgICAgICAgYW5ub3VuY2VtZW50cy5mb3JFYWNoKGFubm91bmNlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZW1lbnRDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBgXG5cdFx0XHRcdDxhIGhyZWY9XCIvYW5ub3VuY2VtZW50cy8ke2Fubm91bmNlbWVudC5uZXdzSXRlbUlkfVwiIHRhcmdldD1cIl9zZWxmXCIgdWlkPVwiJHthbm5vdW5jZW1lbnQubmV3c0l0ZW1JZH1cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYW5ub3VuY2VtZW50ICR7YW5ub3VuY2VtZW50LnRhZ3NbMF19XCIgaWQ9XCIke2Fubm91bmNlbWVudC5uZXdzSXRlbUlkfVwiPlxuICAgICAgICAgICAgICAgIFx0XHQ8cD4ke2Fubm91bmNlbWVudC50aXRsZX08L3A+XG4gICAgICAgICAgICAgICAgXHRcdDxwPiR7YW5ub3VuY2VtZW50LnB1Ymxpc2hEYXRlfSAtICR7YW5ub3VuY2VtZW50LnRhZ3NbMF19PC9wPlxuICAgICAgICAgICBcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9hPmApXG5cbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkSGlzdG9yeSA9IHV0aWxzLmdldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkSGlzdG9yeSA9IHN0b3JlZEhpc3RvcnkgPyBzdG9yZWRIaXN0b3J5IDogW11cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5hbm5vdW5jZW1lbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignYTpsYXN0LW9mLXR5cGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRIaXN0b3J5LmluY2x1ZGVzKGxpbmsuZ2V0QXR0cmlidXRlKCd1aWQnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZCgncmVhZCcpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuc3RvcmUobGluaykpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3JlKGFubm91bmNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkSGlzdG9yeS5wdXNoKGFubm91bmNlbWVudC5nZXRBdHRyaWJ1dGUoJ3VpZCcpKVxuICAgICAgICAgICAgdXRpbHMuc2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknLCB0aGlzLnJlYWRIaXN0b3J5KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYW5ub3VuY2VtZW50cy13aWRnZXQnLCBhbm5vdW5jZW1lbnRMaXN0KVxufSIsImV4cG9ydCB7IGluaXQgYXMgV0NfY291cnNlb3ZlcnZpZXcgfVxuXG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJylcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbmgyIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcblx0Zm9udC1mYW1pbHk6IFwiT3BlblNhbnMtUmVndWxhclwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXHRmb250LXdlaWdodDogbGlnaHRlcjtcblx0bGluZS1oZWlnaHQ6IDEuMTtcbn1cblxucCB7XG5cdG1hcmdpbjogMDtcbn1cblxuLm5hdmlnYXRvciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbiAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbn1cblxuLm5hdmlnYXRvciBzcGFuICB7XG4gICAgY3Vyc29yOiBkZWZhdWx0O1xufVxuXG4ubmF2aWdhdG9yIGltZyB7XG4gICAgcGFkZGluZzogMTBweDtcbn1cblxuLm5hdmlnYXRvciBpbWc6bm90KC5kaXNhYmxlZCkge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLm5hdmlnYXRvciBpbWcuZGlzYWJsZWQge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIG9wYWNpdHk6IC41O1xufVxuXG4uY291cnNlIHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDFmcjtcbiAgICBncmlkLWNvbHVtbi1nYXA6IDIwcHg7XG4gICAgcGFkZGluZzogMTVweCAyMHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xufVxuXG4uY291cnNlIHA6Zmlyc3Qtb2YtdHlwZSB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtQm9sZFwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbn1cblxuLmNvdXJzZSB1bCB7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG59XG5cbi5jb3Vyc2UgdWwgbGkge1xuICAgIGRpc3BsYXk6IGlubGluZTtcbn1cblxuLmNvdXJzZSB1bCBsaTpub3QoOmxhc3Qtb2YtdHlwZSk6YWZ0ZXIge1xuICAgIGNvbnRlbnQ6IFwiLCBcIjtcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xufVxuXG5hIHtcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbmE6aG92ZXIsXG5hOmZvY3VzIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBvdXRsaW5lOiBub25lO1xufVxuXG5hIGltZyB7XG4gICAgaGVpZ2h0OiAxMnB4O1xuICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xufVxuPC9zdHlsZT5cblxuPGgyPlZha2tlbm92ZXJ6aWNodDwvaDI+XG5cbjxkaXYgY2xhc3M9XCJuYXZpZ2F0b3JcIj5cbiAgICA8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1sZWZ0LnN2Z1wiIGFsdD1cImFycm93LWxlZnRcIj48L2ltZz5cbiAgICA8c3Bhbj48L3NwYW4+XG4gICAgPGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvZGl2PlxuXG48ZGl2IGlkPVwiY291cnNlLW92ZXJ2aWV3XCI+PC9kaXY+XG5cbjxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL3Npcy5odmEubmwvXCI+Vm9sbGVkaWcgb3ZlcnppY2h0XG4gICAgPGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvYT5cbmBcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjbGFzcyBDb3Vyc2VPdmVydmlldyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBTZXR1cFxuICAgICAgICAgICAgc3VwZXIoKVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSlcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgICAgICAgLy8gVmFyaWFibGVzXG4gICAgICAgICAgICB0aGlzLmNvdXJzZUNvbnRhaW5lciA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcjY291cnNlLW92ZXJ2aWV3JylcbiAgICAgICAgICAgIHRoaXMuY291cnNlTW9tZW50ID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5uYXZpZ2F0b3Igc3BhbicpXG4gICAgICAgICAgICB0aGlzLmFycm93UHJldmlvdXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLm5hdmlnYXRvciBpbWc6Zmlyc3Qtb2YtdHlwZScpXG4gICAgICAgICAgICB0aGlzLmFycm93TmV4dCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdG9yIGltZzpsYXN0LW9mLXR5cGUnKVxuICAgICAgICAgICAgdGhpcy55ZWFySW5kZXggPSAyXG4gICAgICAgICAgICB0aGlzLnF1YXJ0ZXJJbmRleCA9IDNcblxuICAgICAgICAgICAgLy8gRGF0YVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5nZXREYXRhKCkudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlSGFuZGxlcigpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ganNvblt0aGlzLnllYXJJbmRleF0ucXVhcnRlcnNbdGhpcy5xdWFydGVySW5kZXhdLmNvdXJzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdXJzZU92ZXJ2aWV3KGRhdGEpXG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBqc29uXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBFdmVudExpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXZpb3VzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5uYXZpZ2F0ZSgncHJldmlvdXMnKSlcbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5uYXZpZ2F0ZSgnbmV4dCcpKVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlTmF2aWdhdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5jb3Vyc2VNb21lbnQudGV4dENvbnRlbnQgPSBgSmFhciAke3RoaXMueWVhckluZGV4ICsgMX0gLSBCbG9rICR7dGhpcy5xdWFydGVySW5kZXggKyAxfWBcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUNvdXJzZU92ZXJ2aWV3KGNvdXJzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY291cnNlQ29udGFpbmVyLnRleHRDb250ZW50ID0gXCJcIlxuICAgICAgICAgICAgdGhpcy51cGRhdGVOYXZpZ2F0b3IoKVxuXG4gICAgICAgICAgICBjb3Vyc2VzLmZvckVhY2goY291cnNlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdjb3Vyc2UnKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY291cnNlTmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICAgICAgICAgIGNvdXJzZU5hbWUudGV4dENvbnRlbnQgPSBjb3Vyc2UuY291cnNlXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZChjb3Vyc2VOYW1lKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJylcbiAgICAgICAgICAgICAgICBjb3Vyc2UubGVjdHVyZXJzLmZvckVhY2gobGVjdHVyZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZWFjaGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKVxuICAgICAgICAgICAgICAgICAgICBsZWN0dXJlciA9PT0gXCJcIiA/IHRlYWNoZXIudGV4dENvbnRlbnQgPSAnR2VlbiBzcGVjaWZpZWtlIGRvY2VudCcgOiB0ZWFjaGVyLnRleHRDb250ZW50ID0gbGVjdHVyZXJcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQodGVhY2hlcilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmQobGlzdClcblxuICAgICAgICAgICAgICAgIHRoaXMuY291cnNlQ29udGFpbmVyLmFwcGVuZChkaXYpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmF2aWdhdGUoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncHJldmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVhcnRlckluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YXJ0ZXJJbmRleC0tXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnF1YXJ0ZXJJbmRleCA9PT0gMCAmJiB0aGlzLnllYXJJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFydGVySW5kZXggPSAzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhckluZGV4LS1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnF1YXJ0ZXJJbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFydGVySW5kZXgrK1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5xdWFydGVySW5kZXggPT09IDMgJiYgdGhpcy55ZWFySW5kZXggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhcnRlckluZGV4ID0gMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXJJbmRleCsrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlSGFuZGxlcigpXG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGFbdGhpcy55ZWFySW5kZXhdLnF1YXJ0ZXJzW3RoaXMucXVhcnRlckluZGV4XS5jb3Vyc2VzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdXJzZU92ZXJ2aWV3KGRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBuYXZpZ2F0ZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICB0aGlzLnllYXJJbmRleCA9PT0gMCAmJiB0aGlzLnF1YXJ0ZXJJbmRleCA9PT0gMCA/XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXZpb3VzLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJykgOiB0aGlzLmFycm93UHJldmlvdXMuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuXG4gICAgICAgICAgICB0aGlzLnllYXJJbmRleCA9PT0gMyAmJiB0aGlzLnF1YXJ0ZXJJbmRleCA9PT0gMyA/XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvd05leHQuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKSA6IHRoaXMuYXJyb3dOZXh0LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlcnNcbiAgICAgICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goJy9jb3Vyc2VvdmVydmlldycsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2NvdXJzZS1vdmVydmlldycsIENvdXJzZU92ZXJ2aWV3KVxufSIsImV4cG9ydCB7IGluaXQgYXMgV0Nfc2NoZWR1bGVXaWRnZXQgfVxuXG5jb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJylcbnRlbXBsYXRlLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbmgyIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcblx0Zm9udC1mYW1pbHk6IFwiT3BlblNhbnMtUmVndWxhclwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXHRmb250LXdlaWdodDogbGlnaHRlcjtcblx0bGluZS1oZWlnaHQ6IDEuMTtcbn1cblxucCB7XG5cdG1hcmdpbjogMDtcbn1cblxuLm5hdmlnYXRvciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbiAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbn1cblxuLm5hdmlnYXRvciBzcGFuICB7XG4gICAgY3Vyc29yOiBkZWZhdWx0O1xufVxuXG4ubmF2aWdhdG9yIGltZyB7XG4gICAgcGFkZGluZzogMTBweDtcbn1cblxuLm5hdmlnYXRvciBpbWc6bm90KC5kaXNhYmxlZCkge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLm5hdmlnYXRvciBpbWcuZGlzYWJsZWQge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIG9wYWNpdHk6IC41O1xufVxuXG4uc2NoZWR1bGUtY291cnNlIHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnI7XG4gICAgZ3JpZC1jb2x1bW4tZ2FwOiAyMHB4O1xuICAgIGdyaWQtcm93LWdhcDogNXB4O1xuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0RERERERDtcbn1cblxuLnNjaGVkdWxlLWNvdXJzZSBwOmZpcnN0LW9mLXR5cGUsXG4uc2NoZWR1bGUtY291cnNlIHA6bnRoLW9mLXR5cGUoMykge1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLUJvbGRcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbn1cblxuYSB7XG4gICAgbWFyZ2luLXRvcDogMzBweDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG5hOmhvdmVyLFxuYTpmb2N1cyB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cblxuYSBpbWcge1xuICAgIGhlaWdodDogMTJweDtcbiAgICBtYXJnaW4tbGVmdDogMjBweDtcbn1cbjwvc3R5bGU+XG48aDI+RGFncm9vc3RlcjwvaDI+XG48ZGl2IGNsYXNzPVwibmF2aWdhdG9yXCI+XG5cdDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LWxlZnQuc3ZnXCIgYWx0PVwiYXJyb3ctbGVmdFwiIGNsYXNzPVwiZGlzYWJsZWRcIj48L2ltZz5cblx0PHNwYW4+PC9zcGFuPlxuXHQ8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1yaWdodC5zdmdcIiBhbHQ9XCJhcnJvdy1yaWdodFwiPjwvaW1nPlxuPC9kaXY+XG48ZGl2IGlkPVwic2NoZWR1bGVzLWNvbnRhaW5lclwiPjwvZGl2PlxuPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vcm9vc3Rlci5odmEubmwvc2NoZWR1bGVcIj5Wb2xsZWRpZyByb29zdGVyXG5cdDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2E+XG5gXG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gICAgY2xhc3Mgc2NoZWR1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmdldERhdGEoKVxuICAgICAgICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKGpzb25bMF0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGpzb25cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRvciA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdG9yJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dQcmV2aW91cyA9IHRoaXMubmF2aWdhdG9yLnF1ZXJ5U2VsZWN0b3IoJ2ltZzpmaXJzdC1vZi10eXBlJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0ID0gdGhpcy5uYXZpZ2F0b3IucXVlcnlTZWxlY3RvcignaW1nOmxhc3Qtb2YtdHlwZScpXG5cbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5uYXZpZ2F0ZSgnbmV4dCcpKVxuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXZpb3VzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5uYXZpZ2F0ZSgncHJldmlvdXMnKSlcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCgnL3NjaGVkdWxlJywgb3B0aW9ucykudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVNjaGVkdWxlKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlc0NvbnRhaW5lciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnc2NoZWR1bGVzLWNvbnRhaW5lcicpXG4gICAgICAgICAgICBzY2hlZHVsZXNDb250YWluZXIudGV4dENvbnRlbnQgPSBcIlwiXG5cbiAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS50ZXh0Q29udGVudCA9IGAke2RhdGEuZGF5fSAtICR7ZGF0YS5tb250aH0gLSAke2RhdGEueWVhcn1gXG5cbiAgICAgICAgICAgIGRhdGEuc2NoZWR1bGVzLmZvckVhY2goc2NoZWR1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzUm9vbSA9IHNjaGVkdWxlLl9lbWJlZGRlZCA/IHNjaGVkdWxlLl9lbWJlZGRlZC5yb29tc1swXS5hYmJyZXZpYXRpb24gOiBcIkdlZW4gbG9rYWFsXCJcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3NjaGVkdWxlLWNvdXJzZScpXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGRpdilcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgICAgICAgICB0aW1lLnRleHRDb250ZW50ID0gYCR7c2NoZWR1bGUuc3RhcnREYXRlVGltZS50aW1lfSAtICR7c2NoZWR1bGUuZW5kRGF0ZVRpbWUudGltZX1gXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRpbWUpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgbmFtZS50ZXh0Q29udGVudCA9IHNjaGVkdWxlLl9saW5rcy5jb3Vyc2VzWzBdLnRpdGxlXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5hbWUpXG5cbiAgICAgICAgICAgICAgICBjb25zdCByb29tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgcm9vbS50ZXh0Q29udGVudCA9IGNsYXNzUm9vbVxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChyb29tKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGVhY2hlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICAgICAgICAgIHRlYWNoZXIudGV4dENvbnRlbnQgPSBzY2hlZHVsZS5fbGlua3MubGVjdHVyZXJzWzBdLnRpdGxlXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRlYWNoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmF2aWdhdGUoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdwcmV2aW91cycgPyB0aGlzLmluZGV4LS0gOiB0aGlzLmluZGV4KytcblxuICAgICAgICAgICAgdGhpcy5pbmRleCA9PT0gMCA/IHRoaXMuYXJyb3dQcmV2aW91cy5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpIDogdGhpcy5hcnJvd1ByZXZpb3VzLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPT09IDQgPyB0aGlzLmFycm93TmV4dC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpIDogdGhpcy5hcnJvd05leHQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKHRoaXMuZGF0YVt0aGlzLmluZGV4XSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NjaGVkdWxlLXdpZGdldCcsIHNjaGVkdWxlKVxufSIsImV4cG9ydCB7IGluaXQgYXMgV0Nfc3R1ZHlwcm9ncmVzcyB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuaDIge1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNEREREREQ7XG4gICAgbWFyZ2luOiAwIDAgMTVweCAwO1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLVJlZ3VsYXJcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbiAgICBmb250LXdlaWdodDogbGlnaHRlcjtcbiAgICBsaW5lLWhlaWdodDogMS4xO1xufVxuXG5wIHtcbiAgICBtYXJnaW46IDA7XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBkaXYge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIDFmciBhdXRvO1xuICAgIGdyaWQtdGVtcGxhdGUtcm93czogMWZyIGF1dG87XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBkaXY6bm90KDpsYXN0LW9mLXR5cGUpIHtcbiAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xufVxuXG4jcmVjZW50LXJlc3VsdHMgc3BhbiB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgZ3JpZC1jb2x1bW46IDEgLyAyO1xuICAgIGdyaWQtcm93OiAxIC8gMztcbiAgICB3aWR0aDogNXB4O1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuc3Bhbi5zdWNjZXNzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjUxNjdBO1xufVxuXG5zcGFuLmZhaWxlZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbn1cblxuI3JlY2VudC1yZXN1bHRzIHA6bnRoLW9mLXR5cGUoMSkge1xuICAgIGdyaWQtY29sdW1uOiAyIC8gMztcbiAgICBwYWRkaW5nOiA0cHggMHB4IDBweCAxMHB4O1xufVxuXG4jcmVjZW50LXJlc3VsdHMgcDpudGgtb2YtdHlwZSgyKSB7XG4gICAgZ3JpZC1yb3c6IDEgLyAzO1xuICAgIGdyaWQtY29sdW1uOiAzIC8gNDtcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBwOm50aC1vZi10eXBlKDMpIHtcbiAgICBwYWRkaW5nOiAwcHggMHB4IDRweCAxMHB4O1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBjb2xvcjogIzY2NjY2Njtcbn1cblxuI3JlY2VudC1yZXN1bHRzIHA6bnRoLW9mLXR5cGUoMSksXG4jcmVjZW50LXJlc3VsdHMgcDpudGgtb2YtdHlwZSgyKSB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtQm9sZFwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3Mge1xuICAgIG1hcmdpbi10b3A6IDMwcHg7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgZGl2IHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnIgYXV0bztcbn1cblxuI3JlY2VudC1wcm9ncmVzcyBkaXYgc3BhbiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB3aWR0aDogNXB4O1xufVxuXG4jcmVjZW50LXByb2dyZXNzIHAge1xuICAgIHBhZGRpbmc6IDVweCAwcHg7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgcDpmaXJzdC1vZi10eXBlIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbn1cblxuI3JlY2VudC1wcm9ncmVzcyAuY3VycmVudC15ZWFyIHNwYW4ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMyNTE2N0E7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciBwIHtcbiAgICBmb250LWZhbWlseTogXCJPcGVuU2Fucy1Cb2xkXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciBwOmxhc3Qtb2YtdHlwZSB7XG4gICAgcGFkZGluZy1yaWdodDogMTBweDtcbn1cblxuI2xpbmstY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cblxuI2xpbmstY29udGFpbmVyIGEge1xuICAgIG1hcmdpbi10b3A6IDMwcHg7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuI2xpbmstY29udGFpbmVyIGE6aG92ZXIsXG4jbGluay1jb250YWluZXIgYTpmb2N1cyB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cblxuI2xpbmstY29udGFpbmVyIGEgaW1nIHtcbiAgICBoZWlnaHQ6IDEycHg7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG59XG5cbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDUwcHgpIHtcbiAgICAjbGluay1jb250YWluZXIge1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cblxuICAgICNsaW5rLWNvbnRhaW5lciBhOmxhc3Qtb2YtdHlwZSB7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgfVxufVxuPC9zdHlsZT5cblxuPGgyPlN0dWRpZXJlc3VsdGF0ZW4gZW4gLXZvb3J0Z2FuZzwvaDI+XG5cbjxkaXYgaWQ9XCJyZWNlbnQtcmVzdWx0c1wiPjwvZGl2PlxuPGRpdiBpZD1cInJlY2VudC1wcm9ncmVzc1wiPjwvZGl2PlxuXG48ZGl2IGlkPVwibGluay1jb250YWluZXJcIj5cbjxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL3Npcy5odmEubmw6ODAxMS9wc2MvUzJQUkQvRU1QTE9ZRUUvU0EvYy9TTlNfTUVOVV9GTEQuU05TX1NTX1NURF9SRVNfRkwuR0JMXCI+Sm91dyByZXN1bHRhdGVuXG4gICAgPGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvYT5cblxuPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vc2lzLmh2YS5ubDo4MDExL3BzYy9TMlBSRC9FTVBMT1lFRS9TQS9jL1NOU19NRU5VX0ZMRC5TTlNfU1NfRkxEX0FEQi5HQkxcIj5Kb3V3IHN0dWRpZXZvb3J0Z2FuZ1xuICAgIDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2E+XG48L2Rpdj5cbmBcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjbGFzcyBTdHVkeVByb2dyZXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIFNldHVwXG4gICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgICAgICB0aGlzLmdldERhdGEoKS50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZXN1bHRzLCBwcm9ncmVzc10gPSBqc29uXG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdENvbXBvbmVudChyZXN1bHRzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDb21wb25lbnQocHJvZ3Jlc3MpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNDb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI3JlY2VudC1yZXN1bHRzJylcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI3JlY2VudC1wcm9ncmVzcycpXG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmVzc0NvbXBvbmVudChyZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY3VycmVudFllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQteWVhcicpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBgXG4gICAgICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxwPkxlZXJqYWFyICR7cmVzdWx0LnN0dWR5WWVhcn08L3A+XG4gICAgICAgICAgICAgICAgPHA+JHtyZXN1bHQuc3R1ZHlwb2ludHMuYWNoaWV2ZWR9LyR7cmVzdWx0LnN0dWR5cG9pbnRzLmF2YWlsYWJsZX0gc3R1ZGllcHVudGVuPC9wPmBcblxuICAgICAgICAgICAgICAgIC8vIEluc2VydEFkamFjZW50SHRtbFxuICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlIGVuZ2luZSB1aXR6b2VrZW4gdm9vciBXZWJjb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzQ29udGFpbmVyLmFwcGVuZChkaXYpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cblxuICAgICAgICByZXN1bHRDb21wb25lbnQocmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgICAgICAgICBsZXQgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZ3JhZGUgPT09ICdudW1iZXInICYmIHJlc3VsdC5ncmFkZSA+PSA1LjUgfHwgcmVzdWx0LmdyYWRlID09PSAnVicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yID0gYDxzcGFuIGNsYXNzPVwic3VjY2Vzc1wiPjwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0LmdyYWRlID09PSAnbnVtYmVyJyAmJiByZXN1bHQuZ3JhZGUgPCA1LjUgfHwgcmVzdWx0LmdyYWRlID09PSAnLScgfHwgcmVzdWx0LmdyYWRlID09PSAnR1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciA9IGA8c3BhbiBjbGFzcz1cImZhaWxlZFwiPjwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBgXG4gICAgICAgICAgICAgICAgJHtpbmRpY2F0b3J9XG4gICAgICAgICAgICAgICAgPHA+JHtyZXN1bHQuX2xpbmtzLmNvdXJzZS50aXRsZX08L3A+XG4gICAgICAgICAgICAgICAgPHA+JHtyZXN1bHQuZ3JhZGV9PC9wPlxuICAgICAgICAgICAgICAgIDxwPiR7cmVzdWx0LmZ1bGxEYXRlfTwvcD5cbiAgICAgICAgICAgICAgICBgXG5cbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHNDb250YWluZXIuYXBwZW5kKGRpdilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZWxwZXJzXG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKCcvc3R1ZHlwcm9ncmVzcycsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0dWR5LXByb2dyZXNzJywgU3R1ZHlQcm9ncmVzcylcbn0iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLm1qcydcblxuZXhwb3J0IHsgdGVtcGxhdGUgYXMgV0NfdXJnZW50QW5ub3VuY2VtZW50IH1cblxuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpXG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG4gICAgZGl2IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBwYWRkaW5nOiAxNnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUNFN0ZBO1xuICAgICAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgICAgICB0b3A6IDA7XG4gICAgfVxuXG4gICAgZGl2LmhpZGUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IC05OTk5cHg7XG4gICAgfVxuXG4gICAgcCB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTBweDtcbiAgICB9XG5cbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2OHB4KSB7XG4gICAgICAgIGRpdiB7XG4gICAgICAgICAgICB0b3A6IDYwcHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbWcge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJoaWRlXCI+XG4gICAgPHA+PC9wPlxuICAgIDxpbWcgc3JjPVwiLi9tZWRpYS9pY29ucy9ub3RpZmljYXRpb24tZXhpdC5zdmdcIiBhbHQ9XCJoaWRlIG5vdGlmaWNhdGlvblwiPlxuPC9kaXY+YFxuXG5cblxuY2xhc3MgdXJnZW50QW5ub3VuY2VtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdwJykudGV4dENvbnRlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWVzc2FnZScpXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdpbWcnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgICAgICB0aGlzLnN0b3JlKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIFsndWlkJ11cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBuZXdWYWx1ZSAmJiBuZXdWYWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCB1aWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgndWlkJylcbiAgICAgICAgICAgIGlmICh1dGlscy5zdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZEhpc3RvcnkgPSB1dGlscy5nZXRMb2NhbFN0b3JhZ2UoJ3JlYWQtaGlzdG9yeScpXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZWRIaXN0b3J5LmluY2x1ZGVzKHVpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50KClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDb250ZW50KCkge1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcigncCcpLnRleHRDb250ZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnKVxuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJylcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbicpLmNsYXNzTGlzdC5hZGQoJ3Nob3dzTm90aWZpY2F0aW9uJylcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZGl2JykuY2xhc3NMaXN0LmFkZCgnaGlkZScpXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4nKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93c05vdGlmaWNhdGlvbicpXG4gICAgfVxuXG4gICAgc3RvcmUoKSB7XG4gICAgICAgIGlmICh1dGlscy5zdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkSGlzdG9yeSA9IHV0aWxzLmdldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JylcbiAgICAgICAgICAgIGNvbnN0IHJlYWRIaXN0b3J5ID0gc3RvcmVkSGlzdG9yeSA/IHN0b3JlZEhpc3RvcnkgOiBbXVxuXG4gICAgICAgICAgICByZWFkSGlzdG9yeS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKCd1aWQnKSlcbiAgICAgICAgICAgIHV0aWxzLnNldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JywgcmVhZEhpc3RvcnkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3VyZ2VudC1hbm5vdW5jZW1lbnQnLCB1cmdlbnRBbm5vdW5jZW1lbnQpIl19"}