{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/sortablejs/Sortable.js","src/js/index.js","src/js/modules/notify.mjs","src/js/modules/preferences/dashboard.mjs","src/js/modules/preferences/menu.mjs","src/js/modules/search.mjs","src/js/modules/unreadAnnouncements.mjs","src/js/modules/utils.mjs","src/js/web-components/announcements.mjs","src/js/web-components/course-overview.mjs","src/js/web-components/schedule.mjs","src/js/web-components/study-progress.mjs","src/js/web-components/urgent-announcement.mjs"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7nHA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEA,IAAM,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAuB,MAAvB,EAA+B,EAA/B,CAAkC,WAAlC,EAAb;;AAEA,IAAI,IAAI,KAAK,SAAb,EAAwB;AACpB;AACH,C,CAED;;;AACA,IAAI,IAAI,KAAK,WAAb,EAA0B;AACtB,EAAA,KAAK,CAAC,aAAN,CAAoB,KAAK,CAAC,cAAN,EAApB;AACH;;AAED,IAAI,IAAI,KAAK,SAAb,EAAwB;AACpB;AACA;AACH;;AAED,IAAI,IAAI,KAAK,wBAAb,EAAuC;AACnC,MAAM,gBAAgB,GAAG,QAAQ,CAAC,cAAT,CAAwB,eAAxB,CAAzB;AACA,EAAA,gBAAgB,CAAC,MAAjB;AACA,EAAA,QAAQ,CAAC,aAAT,CAAuB,cAAvB,EAAuC,MAAvC,CAA8C,QAAQ,CAAC,aAAT,CAAuB,sBAAvB,CAA9C;AACA,6CAAuB,IAAvB;AACH,C,CAGD;;;AACA,IAAI,SAAS,CAAC,MAAd,EAAsB;AAClB;AACA,MAAM,MAAM,GAAG,EAAE,EAAjB,CAFkB,CAIlB;;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","file":"index.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**!\n * Sortable 1.10.2\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Sortable = factory());\n}(this, function () { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var version = \"1.10.2\";\n\n  function userAgent(pattern) {\n    if (typeof window !== 'undefined' && window.navigator) {\n      return !!\n      /*@__PURE__*/\n      navigator.userAgent.match(pattern);\n    }\n  }\n\n  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\n  var Edge = userAgent(/Edge/i);\n  var FireFox = userAgent(/firefox/i);\n  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\n  var IOS = userAgent(/iP(ad|od|hone)/i);\n  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n\n  var captureMode = {\n    capture: false,\n    passive: false\n  };\n\n  function on(el, event, fn) {\n    el.addEventListener(event, fn, !IE11OrLess && captureMode);\n  }\n\n  function off(el, event, fn) {\n    el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n  }\n\n  function matches(\n  /**HTMLElement*/\n  el,\n  /**String*/\n  selector) {\n    if (!selector) return;\n    selector[0] === '>' && (selector = selector.substring(1));\n\n    if (el) {\n      try {\n        if (el.matches) {\n          return el.matches(selector);\n        } else if (el.msMatchesSelector) {\n          return el.msMatchesSelector(selector);\n        } else if (el.webkitMatchesSelector) {\n          return el.webkitMatchesSelector(selector);\n        }\n      } catch (_) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  function getParentOrHost(el) {\n    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n  }\n\n  function closest(\n  /**HTMLElement*/\n  el,\n  /**String*/\n  selector,\n  /**HTMLElement*/\n  ctx, includeCTX) {\n    if (el) {\n      ctx = ctx || document;\n\n      do {\n        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n          return el;\n        }\n\n        if (el === ctx) break;\n        /* jshint boss:true */\n      } while (el = getParentOrHost(el));\n    }\n\n    return null;\n  }\n\n  var R_SPACE = /\\s+/g;\n\n  function toggleClass(el, name, state) {\n    if (el && name) {\n      if (el.classList) {\n        el.classList[state ? 'add' : 'remove'](name);\n      } else {\n        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n      }\n    }\n  }\n\n  function css(el, prop, val) {\n    var style = el && el.style;\n\n    if (style) {\n      if (val === void 0) {\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n          val = document.defaultView.getComputedStyle(el, '');\n        } else if (el.currentStyle) {\n          val = el.currentStyle;\n        }\n\n        return prop === void 0 ? val : val[prop];\n      } else {\n        if (!(prop in style) && prop.indexOf('webkit') === -1) {\n          prop = '-webkit-' + prop;\n        }\n\n        style[prop] = val + (typeof val === 'string' ? '' : 'px');\n      }\n    }\n  }\n\n  function matrix(el, selfOnly) {\n    var appliedTransforms = '';\n\n    if (typeof el === 'string') {\n      appliedTransforms = el;\n    } else {\n      do {\n        var transform = css(el, 'transform');\n\n        if (transform && transform !== 'none') {\n          appliedTransforms = transform + ' ' + appliedTransforms;\n        }\n        /* jshint boss:true */\n\n      } while (!selfOnly && (el = el.parentNode));\n    }\n\n    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n    /*jshint -W056 */\n\n    return matrixFn && new matrixFn(appliedTransforms);\n  }\n\n  function find(ctx, tagName, iterator) {\n    if (ctx) {\n      var list = ctx.getElementsByTagName(tagName),\n          i = 0,\n          n = list.length;\n\n      if (iterator) {\n        for (; i < n; i++) {\n          iterator(list[i], i);\n        }\n      }\n\n      return list;\n    }\n\n    return [];\n  }\n\n  function getWindowScrollingElement() {\n    var scrollingElement = document.scrollingElement;\n\n    if (scrollingElement) {\n      return scrollingElement;\n    } else {\n      return document.documentElement;\n    }\n  }\n  /**\r\n   * Returns the \"bounding client rect\" of given element\r\n   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\r\n   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\r\n   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\r\n   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\r\n   * @param  {[HTMLElement]} container              The parent the element will be placed in\r\n   * @return {Object}                               The boundingClientRect of el, with specified adjustments\r\n   */\n\n\n  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n    if (!el.getBoundingClientRect && el !== window) return;\n    var elRect, top, left, bottom, right, height, width;\n\n    if (el !== window && el !== getWindowScrollingElement()) {\n      elRect = el.getBoundingClientRect();\n      top = elRect.top;\n      left = elRect.left;\n      bottom = elRect.bottom;\n      right = elRect.right;\n      height = elRect.height;\n      width = elRect.width;\n    } else {\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      height = window.innerHeight;\n      width = window.innerWidth;\n    }\n\n    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n      // Adjust for translate()\n      container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n      // Not needed on <= IE11\n\n      if (!IE11OrLess) {\n        do {\n          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n            var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n            top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n            left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n            bottom = top + elRect.height;\n            right = left + elRect.width;\n            break;\n          }\n          /* jshint boss:true */\n\n        } while (container = container.parentNode);\n      }\n    }\n\n    if (undoScale && el !== window) {\n      // Adjust for scale()\n      var elMatrix = matrix(container || el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d;\n\n      if (elMatrix) {\n        top /= scaleY;\n        left /= scaleX;\n        width /= scaleX;\n        height /= scaleY;\n        bottom = top + height;\n        right = left + width;\n      }\n    }\n\n    return {\n      top: top,\n      left: left,\n      bottom: bottom,\n      right: right,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Checks if a side of an element is scrolled past a side of its parents\r\n   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\r\n   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\r\n   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\r\n   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n   */\n\n\n  function isScrolledPast(el, elSide, parentSide) {\n    var parent = getParentAutoScrollElement(el, true),\n        elSideVal = getRect(el)[elSide];\n    /* jshint boss:true */\n\n    while (parent) {\n      var parentSideVal = getRect(parent)[parentSide],\n          visible = void 0;\n\n      if (parentSide === 'top' || parentSide === 'left') {\n        visible = elSideVal >= parentSideVal;\n      } else {\n        visible = elSideVal <= parentSideVal;\n      }\n\n      if (!visible) return parent;\n      if (parent === getWindowScrollingElement()) break;\n      parent = getParentAutoScrollElement(parent, false);\n    }\n\n    return false;\n  }\n  /**\r\n   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\r\n   * and non-draggable elements\r\n   * @param  {HTMLElement} el       The parent element\r\n   * @param  {Number} childNum      The index of the child\r\n   * @param  {Object} options       Parent Sortable's options\r\n   * @return {HTMLElement}          The child at index childNum, or null if not found\r\n   */\n\n\n  function getChild(el, childNum, options) {\n    var currentChild = 0,\n        i = 0,\n        children = el.children;\n\n    while (i < children.length) {\n      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {\n        if (currentChild === childNum) {\n          return children[i];\n        }\n\n        currentChild++;\n      }\n\n      i++;\n    }\n\n    return null;\n  }\n  /**\r\n   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n   * @param  {HTMLElement} el       Parent element\r\n   * @param  {selector} selector    Any other elements that should be ignored\r\n   * @return {HTMLElement}          The last child, ignoring ghostEl\r\n   */\n\n\n  function lastChild(el, selector) {\n    var last = el.lastElementChild;\n\n    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n      last = last.previousElementSibling;\n    }\n\n    return last || null;\n  }\n  /**\r\n   * Returns the index of an element within its parent for a selected set of\r\n   * elements\r\n   * @param  {HTMLElement} el\r\n   * @param  {selector} selector\r\n   * @return {number}\r\n   */\n\n\n  function index(el, selector) {\n    var index = 0;\n\n    if (!el || !el.parentNode) {\n      return -1;\n    }\n    /* jshint boss:true */\n\n\n    while (el = el.previousElementSibling) {\n      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n        index++;\n      }\n    }\n\n    return index;\n  }\n  /**\r\n   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\r\n   * The value is returned in real pixels.\r\n   * @param  {HTMLElement} el\r\n   * @return {Array}             Offsets in the format of [left, top]\r\n   */\n\n\n  function getRelativeScrollOffset(el) {\n    var offsetLeft = 0,\n        offsetTop = 0,\n        winScroller = getWindowScrollingElement();\n\n    if (el) {\n      do {\n        var elMatrix = matrix(el),\n            scaleX = elMatrix.a,\n            scaleY = elMatrix.d;\n        offsetLeft += el.scrollLeft * scaleX;\n        offsetTop += el.scrollTop * scaleY;\n      } while (el !== winScroller && (el = el.parentNode));\n    }\n\n    return [offsetLeft, offsetTop];\n  }\n  /**\r\n   * Returns the index of the object within the given array\r\n   * @param  {Array} arr   Array that may or may not hold the object\r\n   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\r\n   * @return {Number}      The index of the object in the array, or -1\r\n   */\n\n\n  function indexOfObject(arr, obj) {\n    for (var i in arr) {\n      if (!arr.hasOwnProperty(i)) continue;\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n      }\n    }\n\n    return -1;\n  }\n\n  function getParentAutoScrollElement(el, includeSelf) {\n    // skip to window\n    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n    var elem = el;\n    var gotSelf = false;\n\n    do {\n      // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n        var elemCSS = css(elem);\n\n        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n          if (gotSelf || includeSelf) return elem;\n          gotSelf = true;\n        }\n      }\n      /* jshint boss:true */\n\n    } while (elem = elem.parentNode);\n\n    return getWindowScrollingElement();\n  }\n\n  function extend(dst, src) {\n    if (dst && src) {\n      for (var key in src) {\n        if (src.hasOwnProperty(key)) {\n          dst[key] = src[key];\n        }\n      }\n    }\n\n    return dst;\n  }\n\n  function isRectEqual(rect1, rect2) {\n    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n  }\n\n  var _throttleTimeout;\n\n  function throttle(callback, ms) {\n    return function () {\n      if (!_throttleTimeout) {\n        var args = arguments,\n            _this = this;\n\n        if (args.length === 1) {\n          callback.call(_this, args[0]);\n        } else {\n          callback.apply(_this, args);\n        }\n\n        _throttleTimeout = setTimeout(function () {\n          _throttleTimeout = void 0;\n        }, ms);\n      }\n    };\n  }\n\n  function cancelThrottle() {\n    clearTimeout(_throttleTimeout);\n    _throttleTimeout = void 0;\n  }\n\n  function scrollBy(el, x, y) {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n\n  function clone(el) {\n    var Polymer = window.Polymer;\n    var $ = window.jQuery || window.Zepto;\n\n    if (Polymer && Polymer.dom) {\n      return Polymer.dom(el).cloneNode(true);\n    } else if ($) {\n      return $(el).clone(true)[0];\n    } else {\n      return el.cloneNode(true);\n    }\n  }\n\n  function setRect(el, rect) {\n    css(el, 'position', 'absolute');\n    css(el, 'top', rect.top);\n    css(el, 'left', rect.left);\n    css(el, 'width', rect.width);\n    css(el, 'height', rect.height);\n  }\n\n  function unsetRect(el) {\n    css(el, 'position', '');\n    css(el, 'top', '');\n    css(el, 'left', '');\n    css(el, 'width', '');\n    css(el, 'height', '');\n  }\n\n  var expando = 'Sortable' + new Date().getTime();\n\n  function AnimationStateManager() {\n    var animationStates = [],\n        animationCallbackId;\n    return {\n      captureAnimationState: function captureAnimationState() {\n        animationStates = [];\n        if (!this.options.animation) return;\n        var children = [].slice.call(this.el.children);\n        children.forEach(function (child) {\n          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n          animationStates.push({\n            target: child,\n            rect: getRect(child)\n          });\n\n          var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n          if (child.thisAnimationDuration) {\n            var childMatrix = matrix(child, true);\n\n            if (childMatrix) {\n              fromRect.top -= childMatrix.f;\n              fromRect.left -= childMatrix.e;\n            }\n          }\n\n          child.fromRect = fromRect;\n        });\n      },\n      addAnimationState: function addAnimationState(state) {\n        animationStates.push(state);\n      },\n      removeAnimationState: function removeAnimationState(target) {\n        animationStates.splice(indexOfObject(animationStates, {\n          target: target\n        }), 1);\n      },\n      animateAll: function animateAll(callback) {\n        var _this = this;\n\n        if (!this.options.animation) {\n          clearTimeout(animationCallbackId);\n          if (typeof callback === 'function') callback();\n          return;\n        }\n\n        var animating = false,\n            animationTime = 0;\n        animationStates.forEach(function (state) {\n          var time = 0,\n              target = state.target,\n              fromRect = target.fromRect,\n              toRect = getRect(target),\n              prevFromRect = target.prevFromRect,\n              prevToRect = target.prevToRect,\n              animatingRect = state.rect,\n              targetMatrix = matrix(target, true);\n\n          if (targetMatrix) {\n            // Compensate for current animation\n            toRect.top -= targetMatrix.f;\n            toRect.left -= targetMatrix.e;\n          }\n\n          target.toRect = toRect;\n\n          if (target.thisAnimationDuration) {\n            // Could also check if animatingRect is between fromRect and toRect\n            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n              // If returning to same place as started from animation and on same axis\n              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n            }\n          } // if fromRect != toRect: animate\n\n\n          if (!isRectEqual(toRect, fromRect)) {\n            target.prevFromRect = fromRect;\n            target.prevToRect = toRect;\n\n            if (!time) {\n              time = _this.options.animation;\n            }\n\n            _this.animate(target, animatingRect, toRect, time);\n          }\n\n          if (time) {\n            animating = true;\n            animationTime = Math.max(animationTime, time);\n            clearTimeout(target.animationResetTimer);\n            target.animationResetTimer = setTimeout(function () {\n              target.animationTime = 0;\n              target.prevFromRect = null;\n              target.fromRect = null;\n              target.prevToRect = null;\n              target.thisAnimationDuration = null;\n            }, time);\n            target.thisAnimationDuration = time;\n          }\n        });\n        clearTimeout(animationCallbackId);\n\n        if (!animating) {\n          if (typeof callback === 'function') callback();\n        } else {\n          animationCallbackId = setTimeout(function () {\n            if (typeof callback === 'function') callback();\n          }, animationTime);\n        }\n\n        animationStates = [];\n      },\n      animate: function animate(target, currentRect, toRect, duration) {\n        if (duration) {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          var elMatrix = matrix(this.el),\n              scaleX = elMatrix && elMatrix.a,\n              scaleY = elMatrix && elMatrix.d,\n              translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n              translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n          target.animatingX = !!translateX;\n          target.animatingY = !!translateY;\n          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n          repaint(target); // repaint\n\n          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n          css(target, 'transform', 'translate3d(0,0,0)');\n          typeof target.animated === 'number' && clearTimeout(target.animated);\n          target.animated = setTimeout(function () {\n            css(target, 'transition', '');\n            css(target, 'transform', '');\n            target.animated = false;\n            target.animatingX = false;\n            target.animatingY = false;\n          }, duration);\n        }\n      }\n    };\n  }\n\n  function repaint(target) {\n    return target.offsetWidth;\n  }\n\n  function calculateRealTime(animatingRect, fromRect, toRect, options) {\n    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n  }\n\n  var plugins = [];\n  var defaults = {\n    initializeByDefault: true\n  };\n  var PluginManager = {\n    mount: function mount(plugin) {\n      // Set default static properties\n      for (var option in defaults) {\n        if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n          plugin[option] = defaults[option];\n        }\n      }\n\n      plugins.push(plugin);\n    },\n    pluginEvent: function pluginEvent(eventName, sortable, evt) {\n      var _this = this;\n\n      this.eventCanceled = false;\n\n      evt.cancel = function () {\n        _this.eventCanceled = true;\n      };\n\n      var eventNameGlobal = eventName + 'Global';\n      plugins.forEach(function (plugin) {\n        if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n        if (sortable[plugin.pluginName][eventNameGlobal]) {\n          sortable[plugin.pluginName][eventNameGlobal](_objectSpread({\n            sortable: sortable\n          }, evt));\n        } // Only fire plugin event if plugin is enabled in this sortable,\n        // and plugin has event defined\n\n\n        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n          sortable[plugin.pluginName][eventName](_objectSpread({\n            sortable: sortable\n          }, evt));\n        }\n      });\n    },\n    initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n      plugins.forEach(function (plugin) {\n        var pluginName = plugin.pluginName;\n        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n        var initialized = new plugin(sortable, el, sortable.options);\n        initialized.sortable = sortable;\n        initialized.options = sortable.options;\n        sortable[pluginName] = initialized; // Add default options from plugin\n\n        _extends(defaults, initialized.defaults);\n      });\n\n      for (var option in sortable.options) {\n        if (!sortable.options.hasOwnProperty(option)) continue;\n        var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n        if (typeof modified !== 'undefined') {\n          sortable.options[option] = modified;\n        }\n      }\n    },\n    getEventProperties: function getEventProperties(name, sortable) {\n      var eventProperties = {};\n      plugins.forEach(function (plugin) {\n        if (typeof plugin.eventProperties !== 'function') return;\n\n        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n      });\n      return eventProperties;\n    },\n    modifyOption: function modifyOption(sortable, name, value) {\n      var modifiedValue;\n      plugins.forEach(function (plugin) {\n        // Plugin must exist on the Sortable\n        if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n        }\n      });\n      return modifiedValue;\n    }\n  };\n\n  function dispatchEvent(_ref) {\n    var sortable = _ref.sortable,\n        rootEl = _ref.rootEl,\n        name = _ref.name,\n        targetEl = _ref.targetEl,\n        cloneEl = _ref.cloneEl,\n        toEl = _ref.toEl,\n        fromEl = _ref.fromEl,\n        oldIndex = _ref.oldIndex,\n        newIndex = _ref.newIndex,\n        oldDraggableIndex = _ref.oldDraggableIndex,\n        newDraggableIndex = _ref.newDraggableIndex,\n        originalEvent = _ref.originalEvent,\n        putSortable = _ref.putSortable,\n        extraEventProperties = _ref.extraEventProperties;\n    sortable = sortable || rootEl && rootEl[expando];\n    if (!sortable) return;\n    var evt,\n        options = sortable.options,\n        onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\n      evt = new CustomEvent(name, {\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      evt = document.createEvent('Event');\n      evt.initEvent(name, true, true);\n    }\n\n    evt.to = toEl || rootEl;\n    evt.from = fromEl || rootEl;\n    evt.item = targetEl || rootEl;\n    evt.clone = cloneEl;\n    evt.oldIndex = oldIndex;\n    evt.newIndex = newIndex;\n    evt.oldDraggableIndex = oldDraggableIndex;\n    evt.newDraggableIndex = newDraggableIndex;\n    evt.originalEvent = originalEvent;\n    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n    var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));\n\n    for (var option in allEventProperties) {\n      evt[option] = allEventProperties[option];\n    }\n\n    if (rootEl) {\n      rootEl.dispatchEvent(evt);\n    }\n\n    if (options[onName]) {\n      options[onName].call(sortable, evt);\n    }\n  }\n\n  var pluginEvent = function pluginEvent(eventName, sortable) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        originalEvent = _ref.evt,\n        data = _objectWithoutProperties(_ref, [\"evt\"]);\n\n    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({\n      dragEl: dragEl,\n      parentEl: parentEl,\n      ghostEl: ghostEl,\n      rootEl: rootEl,\n      nextEl: nextEl,\n      lastDownEl: lastDownEl,\n      cloneEl: cloneEl,\n      cloneHidden: cloneHidden,\n      dragStarted: moved,\n      putSortable: putSortable,\n      activeSortable: Sortable.active,\n      originalEvent: originalEvent,\n      oldIndex: oldIndex,\n      oldDraggableIndex: oldDraggableIndex,\n      newIndex: newIndex,\n      newDraggableIndex: newDraggableIndex,\n      hideGhostForTarget: _hideGhostForTarget,\n      unhideGhostForTarget: _unhideGhostForTarget,\n      cloneNowHidden: function cloneNowHidden() {\n        cloneHidden = true;\n      },\n      cloneNowShown: function cloneNowShown() {\n        cloneHidden = false;\n      },\n      dispatchSortableEvent: function dispatchSortableEvent(name) {\n        _dispatchEvent({\n          sortable: sortable,\n          name: name,\n          originalEvent: originalEvent\n        });\n      }\n    }, data));\n  };\n\n  function _dispatchEvent(info) {\n    dispatchEvent(_objectSpread({\n      putSortable: putSortable,\n      cloneEl: cloneEl,\n      targetEl: dragEl,\n      rootEl: rootEl,\n      oldIndex: oldIndex,\n      oldDraggableIndex: oldDraggableIndex,\n      newIndex: newIndex,\n      newDraggableIndex: newDraggableIndex\n    }, info));\n  }\n\n  var dragEl,\n      parentEl,\n      ghostEl,\n      rootEl,\n      nextEl,\n      lastDownEl,\n      cloneEl,\n      cloneHidden,\n      oldIndex,\n      newIndex,\n      oldDraggableIndex,\n      newDraggableIndex,\n      activeGroup,\n      putSortable,\n      awaitingDragStarted = false,\n      ignoreNextClick = false,\n      sortables = [],\n      tapEvt,\n      touchEvt,\n      lastDx,\n      lastDy,\n      tapDistanceLeft,\n      tapDistanceTop,\n      moved,\n      lastTarget,\n      lastDirection,\n      pastFirstInvertThresh = false,\n      isCircumstantialInvert = false,\n      targetMoveDistance,\n      // For positioning ghost absolutely\n  ghostRelativeParent,\n      ghostRelativeParentInitialScroll = [],\n      // (left, top)\n  _silent = false,\n      savedInputChecked = [];\n  /** @const */\n\n  var documentExists = typeof document !== 'undefined',\n      PositionGhostAbsolutely = IOS,\n      CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n      // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n      supportCssPointerEvents = function () {\n    if (!documentExists) return; // false when <= IE11\n\n    if (IE11OrLess) {\n      return false;\n    }\n\n    var el = document.createElement('x');\n    el.style.cssText = 'pointer-events:auto';\n    return el.style.pointerEvents === 'auto';\n  }(),\n      _detectDirection = function _detectDirection(el, options) {\n    var elCSS = css(el),\n        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n        child1 = getChild(el, 0, options),\n        child2 = getChild(el, 1, options),\n        firstChildCSS = child1 && css(child1),\n        secondChildCSS = child2 && css(child2),\n        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n    if (elCSS.display === 'flex') {\n      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n    }\n\n    if (elCSS.display === 'grid') {\n      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n    }\n\n    if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n      var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n    }\n\n    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n  },\n      _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n        dragElOppLength = vertical ? dragRect.width : dragRect.height,\n        targetS1Opp = vertical ? targetRect.left : targetRect.top,\n        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n        targetOppLength = vertical ? targetRect.width : targetRect.height;\n    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n  },\n\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n    var ret;\n    sortables.some(function (sortable) {\n      if (lastChild(sortable)) return;\n      var rect = getRect(sortable),\n          threshold = sortable[expando].options.emptyInsertThreshold,\n          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return ret = sortable;\n      }\n    });\n    return ret;\n  },\n      _prepareGroup = function _prepareGroup(options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === 'clone') {\n          return value;\n        } else if (typeof value === 'function') {\n          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n        } else {\n          var otherGroup = (pull ? to : from).options.group.name;\n          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n        }\n      };\n    }\n\n    var group = {};\n    var originalGroup = options.group;\n\n    if (!originalGroup || _typeof(originalGroup) != 'object') {\n      originalGroup = {\n        name: originalGroup\n      };\n    }\n\n    group.name = originalGroup.name;\n    group.checkPull = toFn(originalGroup.pull, true);\n    group.checkPut = toFn(originalGroup.put);\n    group.revertClone = originalGroup.revertClone;\n    options.group = group;\n  },\n      _hideGhostForTarget = function _hideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', 'none');\n    }\n  },\n      _unhideGhostForTarget = function _unhideGhostForTarget() {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, 'display', '');\n    }\n  }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\n  if (documentExists) {\n    document.addEventListener('click', function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    }, true);\n  }\n\n  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n    if (dragEl) {\n      evt = evt.touches ? evt.touches[0] : evt;\n\n      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n      if (nearest) {\n        // Create imitation event\n        var event = {};\n\n        for (var i in evt) {\n          if (evt.hasOwnProperty(i)) {\n            event[i] = evt[i];\n          }\n        }\n\n        event.target = event.rootEl = nearest;\n        event.preventDefault = void 0;\n        event.stopPropagation = void 0;\n\n        nearest[expando]._onDragOver(event);\n      }\n    }\n  };\n\n  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n    if (dragEl) {\n      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n    }\n  };\n  /**\n   * @class  Sortable\n   * @param  {HTMLElement}  el\n   * @param  {Object}       [options]\n   */\n\n\n  function Sortable(el, options) {\n    if (!(el && el.nodeType && el.nodeType === 1)) {\n      throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n    }\n\n    this.el = el; // root element\n\n    this.options = options = _extends({}, options); // Export instance\n\n    el[expando] = this;\n    var defaults = {\n      group: null,\n      sort: true,\n      disabled: false,\n      store: null,\n      handle: null,\n      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n      swapThreshold: 1,\n      // percentage; 0 <= x <= 1\n      invertSwap: false,\n      // invert always\n      invertedSwapThreshold: null,\n      // will be set to same as swapThreshold if default\n      removeCloneOnHide: true,\n      direction: function direction() {\n        return _detectDirection(el, this.options);\n      },\n      ghostClass: 'sortable-ghost',\n      chosenClass: 'sortable-chosen',\n      dragClass: 'sortable-drag',\n      ignore: 'a, img',\n      filter: null,\n      preventOnFilter: true,\n      animation: 0,\n      easing: null,\n      setData: function setData(dataTransfer, dragEl) {\n        dataTransfer.setData('Text', dragEl.textContent);\n      },\n      dropBubble: false,\n      dragoverBubble: false,\n      dataIdAttr: 'data-id',\n      delay: 0,\n      delayOnTouchOnly: false,\n      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n      forceFallback: false,\n      fallbackClass: 'sortable-fallback',\n      fallbackOnBody: false,\n      fallbackTolerance: 0,\n      fallbackOffset: {\n        x: 0,\n        y: 0\n      },\n      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,\n      emptyInsertThreshold: 5\n    };\n    PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n    for (var name in defaults) {\n      !(name in options) && (options[name] = defaults[name]);\n    }\n\n    _prepareGroup(options); // Bind all private methods\n\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    } // Setup drag mode\n\n\n    this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n    if (this.nativeDraggable) {\n      // Touch start threshold cannot be greater than the native dragstart threshold\n      this.options.touchStartThreshold = 1;\n    } // Bind events\n\n\n    if (options.supportPointer) {\n      on(el, 'pointerdown', this._onTapStart);\n    } else {\n      on(el, 'mousedown', this._onTapStart);\n      on(el, 'touchstart', this._onTapStart);\n    }\n\n    if (this.nativeDraggable) {\n      on(el, 'dragover', this);\n      on(el, 'dragenter', this);\n    }\n\n    sortables.push(this.el); // Restore sorting\n\n    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n    _extends(this, AnimationStateManager());\n  }\n\n  Sortable.prototype =\n  /** @lends Sortable.prototype */\n  {\n    constructor: Sortable,\n    _isOutsideThisEl: function _isOutsideThisEl(target) {\n      if (!this.el.contains(target) && target !== this.el) {\n        lastTarget = null;\n      }\n    },\n    _getDirection: function _getDirection(evt, target) {\n      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n    },\n    _onTapStart: function _onTapStart(\n    /** Event|TouchEvent */\n    evt) {\n      if (!evt.cancelable) return;\n\n      var _this = this,\n          el = this.el,\n          options = this.options,\n          preventOnFilter = options.preventOnFilter,\n          type = evt.type,\n          touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n          target = (touch || evt).target,\n          originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n          filter = options.filter;\n\n      _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n      if (dragEl) {\n        return;\n      }\n\n      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n        return; // only left button and enabled\n      } // cancel dnd if original target is content editable\n\n\n      if (originalTarget.isContentEditable) {\n        return;\n      }\n\n      target = closest(target, options.draggable, el, false);\n\n      if (target && target.animated) {\n        return;\n      }\n\n      if (lastDownEl === target) {\n        // Ignoring duplicate `down`\n        return;\n      } // Get the index of the dragged element within its parent\n\n\n      oldIndex = index(target);\n      oldDraggableIndex = index(target, options.draggable); // Check filter\n\n      if (typeof filter === 'function') {\n        if (filter.call(this, evt, target, this)) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: originalTarget,\n            name: 'filter',\n            targetEl: target,\n            toEl: el,\n            fromEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          preventOnFilter && evt.cancelable && evt.preventDefault();\n          return; // cancel dnd\n        }\n      } else if (filter) {\n        filter = filter.split(',').some(function (criteria) {\n          criteria = closest(originalTarget, criteria.trim(), el, false);\n\n          if (criteria) {\n            _dispatchEvent({\n              sortable: _this,\n              rootEl: criteria,\n              name: 'filter',\n              targetEl: target,\n              fromEl: el,\n              toEl: el\n            });\n\n            pluginEvent('filter', _this, {\n              evt: evt\n            });\n            return true;\n          }\n        });\n\n        if (filter) {\n          preventOnFilter && evt.cancelable && evt.preventDefault();\n          return; // cancel dnd\n        }\n      }\n\n      if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n        return;\n      } // Prepare `dragstart`\n\n\n      this._prepareDragStart(evt, touch, target);\n    },\n    _prepareDragStart: function _prepareDragStart(\n    /** Event */\n    evt,\n    /** Touch */\n    touch,\n    /** HTMLElement */\n    target) {\n      var _this = this,\n          el = _this.el,\n          options = _this.options,\n          ownerDocument = el.ownerDocument,\n          dragStartFn;\n\n      if (target && !dragEl && target.parentNode === el) {\n        var dragRect = getRect(target);\n        rootEl = el;\n        dragEl = target;\n        parentEl = dragEl.parentNode;\n        nextEl = dragEl.nextSibling;\n        lastDownEl = target;\n        activeGroup = options.group;\n        Sortable.dragged = dragEl;\n        tapEvt = {\n          target: dragEl,\n          clientX: (touch || evt).clientX,\n          clientY: (touch || evt).clientY\n        };\n        tapDistanceLeft = tapEvt.clientX - dragRect.left;\n        tapDistanceTop = tapEvt.clientY - dragRect.top;\n        this._lastX = (touch || evt).clientX;\n        this._lastY = (touch || evt).clientY;\n        dragEl.style['will-change'] = 'all';\n\n        dragStartFn = function dragStartFn() {\n          pluginEvent('delayEnded', _this, {\n            evt: evt\n          });\n\n          if (Sortable.eventCanceled) {\n            _this._onDrop();\n\n            return;\n          } // Delayed drag has been triggered\n          // we can re-enable the events: touchmove/mousemove\n\n\n          _this._disableDelayedDragEvents();\n\n          if (!FireFox && _this.nativeDraggable) {\n            dragEl.draggable = true;\n          } // Bind the events: dragstart/dragend\n\n\n          _this._triggerDragStart(evt, touch); // Drag start event\n\n\n          _dispatchEvent({\n            sortable: _this,\n            name: 'choose',\n            originalEvent: evt\n          }); // Chosen item\n\n\n          toggleClass(dragEl, options.chosenClass, true);\n        }; // Disable \"draggable\"\n\n\n        options.ignore.split(',').forEach(function (criteria) {\n          find(dragEl, criteria.trim(), _disableDraggable);\n        });\n        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n        on(ownerDocument, 'mouseup', _this._onDrop);\n        on(ownerDocument, 'touchend', _this._onDrop);\n        on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n        if (FireFox && this.nativeDraggable) {\n          this.options.touchStartThreshold = 4;\n          dragEl.draggable = true;\n        }\n\n        pluginEvent('delayStart', this, {\n          evt: evt\n        }); // Delay is impossible for native DnD in Edge or IE\n\n        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n          if (Sortable.eventCanceled) {\n            this._onDrop();\n\n            return;\n          } // If the user moves the pointer or let go the click or touch\n          // before the delay has been reached:\n          // disable the delayed drag\n\n\n          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n        } else {\n          dragStartFn();\n        }\n      }\n    },\n    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n    /** TouchEvent|PointerEvent **/\n    e) {\n      var touch = e.touches ? e.touches[0] : e;\n\n      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n        this._disableDelayedDrag();\n      }\n    },\n    _disableDelayedDrag: function _disableDelayedDrag() {\n      dragEl && _disableDraggable(dragEl);\n      clearTimeout(this._dragStartTimer);\n\n      this._disableDelayedDragEvents();\n    },\n    _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n      var ownerDocument = this.el.ownerDocument;\n      off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n      off(ownerDocument, 'touchend', this._disableDelayedDrag);\n      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n    },\n    _triggerDragStart: function _triggerDragStart(\n    /** Event */\n    evt,\n    /** Touch */\n    touch) {\n      touch = touch || evt.pointerType == 'touch' && evt;\n\n      if (!this.nativeDraggable || touch) {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._onTouchMove);\n        } else if (touch) {\n          on(document, 'touchmove', this._onTouchMove);\n        } else {\n          on(document, 'mousemove', this._onTouchMove);\n        }\n      } else {\n        on(dragEl, 'dragend', this);\n        on(rootEl, 'dragstart', this._onDragStart);\n      }\n\n      try {\n        if (document.selection) {\n          // Timeout neccessary for IE9\n          _nextTick(function () {\n            document.selection.empty();\n          });\n        } else {\n          window.getSelection().removeAllRanges();\n        }\n      } catch (err) {}\n    },\n    _dragStarted: function _dragStarted(fallback, evt) {\n\n      awaitingDragStarted = false;\n\n      if (rootEl && dragEl) {\n        pluginEvent('dragStarted', this, {\n          evt: evt\n        });\n\n        if (this.nativeDraggable) {\n          on(document, 'dragover', _checkOutsideTargetEl);\n        }\n\n        var options = this.options; // Apply effect\n\n        !fallback && toggleClass(dragEl, options.dragClass, false);\n        toggleClass(dragEl, options.ghostClass, true);\n        Sortable.active = this;\n        fallback && this._appendGhost(); // Drag start event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'start',\n          originalEvent: evt\n        });\n      } else {\n        this._nulling();\n      }\n    },\n    _emulateDragOver: function _emulateDragOver() {\n      if (touchEvt) {\n        this._lastX = touchEvt.clientX;\n        this._lastY = touchEvt.clientY;\n\n        _hideGhostForTarget();\n\n        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        var parent = target;\n\n        while (target && target.shadowRoot) {\n          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n          if (target === parent) break;\n          parent = target;\n        }\n\n        dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n        if (parent) {\n          do {\n            if (parent[expando]) {\n              var inserted = void 0;\n              inserted = parent[expando]._onDragOver({\n                clientX: touchEvt.clientX,\n                clientY: touchEvt.clientY,\n                target: target,\n                rootEl: parent\n              });\n\n              if (inserted && !this.options.dragoverBubble) {\n                break;\n              }\n            }\n\n            target = parent; // store last element\n          }\n          /* jshint boss:true */\n          while (parent = parent.parentNode);\n        }\n\n        _unhideGhostForTarget();\n      }\n    },\n    _onTouchMove: function _onTouchMove(\n    /**TouchEvent*/\n    evt) {\n      if (tapEvt) {\n        var options = this.options,\n            fallbackTolerance = options.fallbackTolerance,\n            fallbackOffset = options.fallbackOffset,\n            touch = evt.touches ? evt.touches[0] : evt,\n            ghostMatrix = ghostEl && matrix(ghostEl, true),\n            scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n            scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n            relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n            dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n            dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n        if (!Sortable.active && !awaitingDragStarted) {\n          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n            return;\n          }\n\n          this._onDragStart(evt, true);\n        }\n\n        if (ghostEl) {\n          if (ghostMatrix) {\n            ghostMatrix.e += dx - (lastDx || 0);\n            ghostMatrix.f += dy - (lastDy || 0);\n          } else {\n            ghostMatrix = {\n              a: 1,\n              b: 0,\n              c: 0,\n              d: 1,\n              e: dx,\n              f: dy\n            };\n          }\n\n          var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n          css(ghostEl, 'webkitTransform', cssMatrix);\n          css(ghostEl, 'mozTransform', cssMatrix);\n          css(ghostEl, 'msTransform', cssMatrix);\n          css(ghostEl, 'transform', cssMatrix);\n          lastDx = dx;\n          lastDy = dy;\n          touchEvt = touch;\n        }\n\n        evt.cancelable && evt.preventDefault();\n      }\n    },\n    _appendGhost: function _appendGhost() {\n      // Bug if using scale(): https://stackoverflow.com/questions/2637058\n      // Not being adjusted for\n      if (!ghostEl) {\n        var container = this.options.fallbackOnBody ? document.body : rootEl,\n            rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n            options = this.options; // Position absolutely\n\n        if (PositionGhostAbsolutely) {\n          // Get relatively positioned parent\n          ghostRelativeParent = container;\n\n          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n            ghostRelativeParent = ghostRelativeParent.parentNode;\n          }\n\n          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n            rect.top += ghostRelativeParent.scrollTop;\n            rect.left += ghostRelativeParent.scrollLeft;\n          } else {\n            ghostRelativeParent = getWindowScrollingElement();\n          }\n\n          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n        }\n\n        ghostEl = dragEl.cloneNode(true);\n        toggleClass(ghostEl, options.ghostClass, false);\n        toggleClass(ghostEl, options.fallbackClass, true);\n        toggleClass(ghostEl, options.dragClass, true);\n        css(ghostEl, 'transition', '');\n        css(ghostEl, 'transform', '');\n        css(ghostEl, 'box-sizing', 'border-box');\n        css(ghostEl, 'margin', 0);\n        css(ghostEl, 'top', rect.top);\n        css(ghostEl, 'left', rect.left);\n        css(ghostEl, 'width', rect.width);\n        css(ghostEl, 'height', rect.height);\n        css(ghostEl, 'opacity', '0.8');\n        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n        css(ghostEl, 'zIndex', '100000');\n        css(ghostEl, 'pointerEvents', 'none');\n        Sortable.ghost = ghostEl;\n        container.appendChild(ghostEl); // Set transform-origin\n\n        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n      }\n    },\n    _onDragStart: function _onDragStart(\n    /**Event*/\n    evt,\n    /**boolean*/\n    fallback) {\n      var _this = this;\n\n      var dataTransfer = evt.dataTransfer;\n      var options = _this.options;\n      pluginEvent('dragStart', this, {\n        evt: evt\n      });\n\n      if (Sortable.eventCanceled) {\n        this._onDrop();\n\n        return;\n      }\n\n      pluginEvent('setupClone', this);\n\n      if (!Sortable.eventCanceled) {\n        cloneEl = clone(dragEl);\n        cloneEl.draggable = false;\n        cloneEl.style['will-change'] = '';\n\n        this._hideClone();\n\n        toggleClass(cloneEl, this.options.chosenClass, false);\n        Sortable.clone = cloneEl;\n      } // #1143: IFrame support workaround\n\n\n      _this.cloneId = _nextTick(function () {\n        pluginEvent('clone', _this);\n        if (Sortable.eventCanceled) return;\n\n        if (!_this.options.removeCloneOnHide) {\n          rootEl.insertBefore(cloneEl, dragEl);\n        }\n\n        _this._hideClone();\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'clone'\n        });\n      });\n      !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n      if (fallback) {\n        ignoreNextClick = true;\n        _this._loopId = setInterval(_this._emulateDragOver, 50);\n      } else {\n        // Undo what was set in _prepareDragStart before drag started\n        off(document, 'mouseup', _this._onDrop);\n        off(document, 'touchend', _this._onDrop);\n        off(document, 'touchcancel', _this._onDrop);\n\n        if (dataTransfer) {\n          dataTransfer.effectAllowed = 'move';\n          options.setData && options.setData.call(_this, dataTransfer, dragEl);\n        }\n\n        on(document, 'drop', _this); // #1276 fix:\n\n        css(dragEl, 'transform', 'translateZ(0)');\n      }\n\n      awaitingDragStarted = true;\n      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n      on(document, 'selectstart', _this);\n      moved = true;\n\n      if (Safari) {\n        css(document.body, 'user-select', 'none');\n      }\n    },\n    // Returns true - if no further action is needed (either inserted or another condition)\n    _onDragOver: function _onDragOver(\n    /**Event*/\n    evt) {\n      var el = this.el,\n          target = evt.target,\n          dragRect,\n          targetRect,\n          revert,\n          options = this.options,\n          group = options.group,\n          activeSortable = Sortable.active,\n          isOwner = activeGroup === group,\n          canSort = options.sort,\n          fromSortable = putSortable || activeSortable,\n          vertical,\n          _this = this,\n          completedFired = false;\n\n      if (_silent) return;\n\n      function dragOverEvent(name, extra) {\n        pluginEvent(name, _this, _objectSpread({\n          evt: evt,\n          isOwner: isOwner,\n          axis: vertical ? 'vertical' : 'horizontal',\n          revert: revert,\n          dragRect: dragRect,\n          targetRect: targetRect,\n          canSort: canSort,\n          fromSortable: fromSortable,\n          target: target,\n          completed: completed,\n          onMove: function onMove(target, after) {\n            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n          },\n          changed: changed\n        }, extra));\n      } // Capture animation state\n\n\n      function capture() {\n        dragOverEvent('dragOverAnimationCapture');\n\n        _this.captureAnimationState();\n\n        if (_this !== fromSortable) {\n          fromSortable.captureAnimationState();\n        }\n      } // Return invocation when dragEl is inserted (or completed)\n\n\n      function completed(insertion) {\n        dragOverEvent('dragOverCompleted', {\n          insertion: insertion\n        });\n\n        if (insertion) {\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n          if (isOwner) {\n            activeSortable._hideClone();\n          } else {\n            activeSortable._showClone(_this);\n          }\n\n          if (_this !== fromSortable) {\n            // Set ghost class to new sortable's ghost class\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n            toggleClass(dragEl, options.ghostClass, true);\n          }\n\n          if (putSortable !== _this && _this !== Sortable.active) {\n            putSortable = _this;\n          } else if (_this === Sortable.active && putSortable) {\n            putSortable = null;\n          } // Animation\n\n\n          if (fromSortable === _this) {\n            _this._ignoreWhileAnimating = target;\n          }\n\n          _this.animateAll(function () {\n            dragOverEvent('dragOverAnimationComplete');\n            _this._ignoreWhileAnimating = null;\n          });\n\n          if (_this !== fromSortable) {\n            fromSortable.animateAll();\n            fromSortable._ignoreWhileAnimating = null;\n          }\n        } // Null lastTarget if it is not inside a previously swapped element\n\n\n        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n          lastTarget = null;\n        } // no bubbling and not fallback\n\n\n        if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n          dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n          !insertion && nearestEmptyInsertDetectEvent(evt);\n        }\n\n        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n        return completedFired = true;\n      } // Call when dragEl has been inserted\n\n\n      function changed() {\n        newIndex = index(dragEl);\n        newDraggableIndex = index(dragEl, options.draggable);\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'change',\n          toEl: el,\n          newIndex: newIndex,\n          newDraggableIndex: newDraggableIndex,\n          originalEvent: evt\n        });\n      }\n\n      if (evt.preventDefault !== void 0) {\n        evt.cancelable && evt.preventDefault();\n      }\n\n      target = closest(target, options.draggable, el, true);\n      dragOverEvent('dragOver');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n        return completed(false);\n      }\n\n      ignoreNextClick = false;\n\n      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n        vertical = this._getDirection(evt, target) === 'vertical';\n        dragRect = getRect(dragEl);\n        dragOverEvent('dragOverValid');\n        if (Sortable.eventCanceled) return completedFired;\n\n        if (revert) {\n          parentEl = rootEl; // actualization\n\n          capture();\n\n          this._hideClone();\n\n          dragOverEvent('revert');\n\n          if (!Sortable.eventCanceled) {\n            if (nextEl) {\n              rootEl.insertBefore(dragEl, nextEl);\n            } else {\n              rootEl.appendChild(dragEl);\n            }\n          }\n\n          return completed(true);\n        }\n\n        var elLastChild = lastChild(el, options.draggable);\n\n        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n          // If already at end of list: Do not insert\n          if (elLastChild === dragEl) {\n            return completed(false);\n          } // assign target only if condition is true\n\n\n          if (elLastChild && el === evt.target) {\n            target = elLastChild;\n          }\n\n          if (target) {\n            targetRect = getRect(target);\n          }\n\n          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n            capture();\n            el.appendChild(dragEl);\n            parentEl = el; // actualization\n\n            changed();\n            return completed(true);\n          }\n        } else if (target.parentNode === el) {\n          targetRect = getRect(target);\n          var direction = 0,\n              targetBeforeFirstSwap,\n              differentLevel = dragEl.parentNode !== el,\n              differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n              side1 = vertical ? 'top' : 'left',\n              scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n              scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n          if (lastTarget !== target) {\n            targetBeforeFirstSwap = targetRect[side1];\n            pastFirstInvertThresh = false;\n            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n          }\n\n          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n          var sibling;\n\n          if (direction !== 0) {\n            // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n            var dragIndex = index(dragEl);\n\n            do {\n              dragIndex -= direction;\n              sibling = parentEl.children[dragIndex];\n            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n          } // If dragEl is already beside target: Do not insert\n\n\n          if (direction === 0 || sibling === target) {\n            return completed(false);\n          }\n\n          lastTarget = target;\n          lastDirection = direction;\n          var nextSibling = target.nextElementSibling,\n              after = false;\n          after = direction === 1;\n\n          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n          if (moveVector !== false) {\n            if (moveVector === 1 || moveVector === -1) {\n              after = moveVector === 1;\n            }\n\n            _silent = true;\n            setTimeout(_unsilent, 30);\n            capture();\n\n            if (after && !nextSibling) {\n              el.appendChild(dragEl);\n            } else {\n              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n            } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n            if (scrolledPastTop) {\n              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n            }\n\n            parentEl = dragEl.parentNode; // actualization\n            // must be done before animation\n\n            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n            }\n\n            changed();\n            return completed(true);\n          }\n        }\n\n        if (el.contains(dragEl)) {\n          return completed(false);\n        }\n      }\n\n      return false;\n    },\n    _ignoreWhileAnimating: null,\n    _offMoveEvents: function _offMoveEvents() {\n      off(document, 'mousemove', this._onTouchMove);\n      off(document, 'touchmove', this._onTouchMove);\n      off(document, 'pointermove', this._onTouchMove);\n      off(document, 'dragover', nearestEmptyInsertDetectEvent);\n      off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n      off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n    },\n    _offUpEvents: function _offUpEvents() {\n      var ownerDocument = this.el.ownerDocument;\n      off(ownerDocument, 'mouseup', this._onDrop);\n      off(ownerDocument, 'touchend', this._onDrop);\n      off(ownerDocument, 'pointerup', this._onDrop);\n      off(ownerDocument, 'touchcancel', this._onDrop);\n      off(document, 'selectstart', this);\n    },\n    _onDrop: function _onDrop(\n    /**Event*/\n    evt) {\n      var el = this.el,\n          options = this.options; // Get the index of the dragged element within its parent\n\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      pluginEvent('drop', this, {\n        evt: evt\n      });\n      parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      if (Sortable.eventCanceled) {\n        this._nulling();\n\n        return;\n      }\n\n      awaitingDragStarted = false;\n      isCircumstantialInvert = false;\n      pastFirstInvertThresh = false;\n      clearInterval(this._loopId);\n      clearTimeout(this._dragStartTimer);\n\n      _cancelNextTick(this.cloneId);\n\n      _cancelNextTick(this._dragStartId); // Unbind events\n\n\n      if (this.nativeDraggable) {\n        off(document, 'drop', this);\n        off(el, 'dragstart', this._onDragStart);\n      }\n\n      this._offMoveEvents();\n\n      this._offUpEvents();\n\n      if (Safari) {\n        css(document.body, 'user-select', '');\n      }\n\n      css(dragEl, 'transform', '');\n\n      if (evt) {\n        if (moved) {\n          evt.cancelable && evt.preventDefault();\n          !options.dropBubble && evt.stopPropagation();\n        }\n\n        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n          // Remove clone(s)\n          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n        }\n\n        if (dragEl) {\n          if (this.nativeDraggable) {\n            off(dragEl, 'dragend', this);\n          }\n\n          _disableDraggable(dragEl);\n\n          dragEl.style['will-change'] = ''; // Remove classes\n          // ghostClass is added in dragStarted\n\n          if (moved && !awaitingDragStarted) {\n            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n          }\n\n          toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'unchoose',\n            toEl: parentEl,\n            newIndex: null,\n            newDraggableIndex: null,\n            originalEvent: evt\n          });\n\n          if (rootEl !== parentEl) {\n            if (newIndex >= 0) {\n              // Add event\n              _dispatchEvent({\n                rootEl: parentEl,\n                name: 'add',\n                toEl: parentEl,\n                fromEl: rootEl,\n                originalEvent: evt\n              }); // Remove event\n\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'remove',\n                toEl: parentEl,\n                originalEvent: evt\n              }); // drag from one list and drop into another\n\n\n              _dispatchEvent({\n                rootEl: parentEl,\n                name: 'sort',\n                toEl: parentEl,\n                fromEl: rootEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n\n            putSortable && putSortable.save();\n          } else {\n            if (newIndex !== oldIndex) {\n              if (newIndex >= 0) {\n                // drag & drop within the same list\n                _dispatchEvent({\n                  sortable: this,\n                  name: 'update',\n                  toEl: parentEl,\n                  originalEvent: evt\n                });\n\n                _dispatchEvent({\n                  sortable: this,\n                  name: 'sort',\n                  toEl: parentEl,\n                  originalEvent: evt\n                });\n              }\n            }\n          }\n\n          if (Sortable.active) {\n            /* jshint eqnull:true */\n            if (newIndex == null || newIndex === -1) {\n              newIndex = oldIndex;\n              newDraggableIndex = oldDraggableIndex;\n            }\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'end',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // Save sorting\n\n\n            this.save();\n          }\n        }\n      }\n\n      this._nulling();\n    },\n    _nulling: function _nulling() {\n      pluginEvent('nulling', this);\n      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n      savedInputChecked.forEach(function (el) {\n        el.checked = true;\n      });\n      savedInputChecked.length = lastDx = lastDy = 0;\n    },\n    handleEvent: function handleEvent(\n    /**Event*/\n    evt) {\n      switch (evt.type) {\n        case 'drop':\n        case 'dragend':\n          this._onDrop(evt);\n\n          break;\n\n        case 'dragenter':\n        case 'dragover':\n          if (dragEl) {\n            this._onDragOver(evt);\n\n            _globalDragOver(evt);\n          }\n\n          break;\n\n        case 'selectstart':\n          evt.preventDefault();\n          break;\n      }\n    },\n\n    /**\n     * Serializes the item into an array of string.\n     * @returns {String[]}\n     */\n    toArray: function toArray() {\n      var order = [],\n          el,\n          children = this.el.children,\n          i = 0,\n          n = children.length,\n          options = this.options;\n\n      for (; i < n; i++) {\n        el = children[i];\n\n        if (closest(el, options.draggable, this.el, false)) {\n          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n        }\n      }\n\n      return order;\n    },\n\n    /**\n     * Sorts the elements according to the array.\n     * @param  {String[]}  order  order of the items\n     */\n    sort: function sort(order) {\n      var items = {},\n          rootEl = this.el;\n      this.toArray().forEach(function (id, i) {\n        var el = rootEl.children[i];\n\n        if (closest(el, this.options.draggable, rootEl, false)) {\n          items[id] = el;\n        }\n      }, this);\n      order.forEach(function (id) {\n        if (items[id]) {\n          rootEl.removeChild(items[id]);\n          rootEl.appendChild(items[id]);\n        }\n      });\n    },\n\n    /**\n     * Save the current sorting\n     */\n    save: function save() {\n      var store = this.options.store;\n      store && store.set && store.set(this);\n    },\n\n    /**\n     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n     * @param   {HTMLElement}  el\n     * @param   {String}       [selector]  default: `options.draggable`\n     * @returns {HTMLElement|null}\n     */\n    closest: function closest$1(el, selector) {\n      return closest(el, selector || this.options.draggable, this.el, false);\n    },\n\n    /**\n     * Set/get option\n     * @param   {string} name\n     * @param   {*}      [value]\n     * @returns {*}\n     */\n    option: function option(name, value) {\n      var options = this.options;\n\n      if (value === void 0) {\n        return options[name];\n      } else {\n        var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n        if (typeof modifiedValue !== 'undefined') {\n          options[name] = modifiedValue;\n        } else {\n          options[name] = value;\n        }\n\n        if (name === 'group') {\n          _prepareGroup(options);\n        }\n      }\n    },\n\n    /**\n     * Destroy\n     */\n    destroy: function destroy() {\n      pluginEvent('destroy', this);\n      var el = this.el;\n      el[expando] = null;\n      off(el, 'mousedown', this._onTapStart);\n      off(el, 'touchstart', this._onTapStart);\n      off(el, 'pointerdown', this._onTapStart);\n\n      if (this.nativeDraggable) {\n        off(el, 'dragover', this);\n        off(el, 'dragenter', this);\n      } // Remove draggable attributes\n\n\n      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n        el.removeAttribute('draggable');\n      });\n\n      this._onDrop();\n\n      this._disableDelayedDragEvents();\n\n      sortables.splice(sortables.indexOf(this.el), 1);\n      this.el = el = null;\n    },\n    _hideClone: function _hideClone() {\n      if (!cloneHidden) {\n        pluginEvent('hideClone', this);\n        if (Sortable.eventCanceled) return;\n        css(cloneEl, 'display', 'none');\n\n        if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n          cloneEl.parentNode.removeChild(cloneEl);\n        }\n\n        cloneHidden = true;\n      }\n    },\n    _showClone: function _showClone(putSortable) {\n      if (putSortable.lastPutMode !== 'clone') {\n        this._hideClone();\n\n        return;\n      }\n\n      if (cloneHidden) {\n        pluginEvent('showClone', this);\n        if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n        if (rootEl.contains(dragEl) && !this.options.group.revertClone) {\n          rootEl.insertBefore(cloneEl, dragEl);\n        } else if (nextEl) {\n          rootEl.insertBefore(cloneEl, nextEl);\n        } else {\n          rootEl.appendChild(cloneEl);\n        }\n\n        if (this.options.group.revertClone) {\n          this.animate(dragEl, cloneEl);\n        }\n\n        css(cloneEl, 'display', '');\n        cloneHidden = false;\n      }\n    }\n  };\n\n  function _globalDragOver(\n  /**Event*/\n  evt) {\n    if (evt.dataTransfer) {\n      evt.dataTransfer.dropEffect = 'move';\n    }\n\n    evt.cancelable && evt.preventDefault();\n  }\n\n  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n    var evt,\n        sortable = fromEl[expando],\n        onMoveFn = sortable.options.onMove,\n        retVal; // Support for new CustomEvent feature\n\n    if (window.CustomEvent && !IE11OrLess && !Edge) {\n      evt = new CustomEvent('move', {\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      evt = document.createEvent('Event');\n      evt.initEvent('move', true, true);\n    }\n\n    evt.to = toEl;\n    evt.from = fromEl;\n    evt.dragged = dragEl;\n    evt.draggedRect = dragRect;\n    evt.related = targetEl || toEl;\n    evt.relatedRect = targetRect || getRect(toEl);\n    evt.willInsertAfter = willInsertAfter;\n    evt.originalEvent = originalEvent;\n    fromEl.dispatchEvent(evt);\n\n    if (onMoveFn) {\n      retVal = onMoveFn.call(sortable, evt, originalEvent);\n    }\n\n    return retVal;\n  }\n\n  function _disableDraggable(el) {\n    el.draggable = false;\n  }\n\n  function _unsilent() {\n    _silent = false;\n  }\n\n  function _ghostIsLast(evt, vertical, sortable) {\n    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n    var spacer = 10;\n    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n  }\n\n  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n        targetLength = vertical ? targetRect.height : targetRect.width,\n        targetS1 = vertical ? targetRect.top : targetRect.left,\n        targetS2 = vertical ? targetRect.bottom : targetRect.right,\n        invert = false;\n\n    if (!invertSwap) {\n      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n        // check if past first invert threshold on side opposite of lastDirection\n        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n          // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n          pastFirstInvertThresh = true;\n        }\n\n        if (!pastFirstInvertThresh) {\n          // dragEl shadow (target move distance shadow)\n          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n          : mouseOnAxis > targetS2 - targetMoveDistance) {\n            return -lastDirection;\n          }\n        } else {\n          invert = true;\n        }\n      } else {\n        // Regular\n        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n          return _getInsertDirection(target);\n        }\n      }\n    }\n\n    invert = invert || invertSwap;\n\n    if (invert) {\n      // Invert of regular\n      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * Gets the direction dragEl must be swapped relative to target in order to make it\n   * seem that dragEl has been \"inserted\" into that element's position\n   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n   * @return {Number}                   Direction dragEl must be swapped\n   */\n\n\n  function _getInsertDirection(target) {\n    if (index(dragEl) < index(target)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * Generate id\n   * @param   {HTMLElement} el\n   * @returns {String}\n   * @private\n   */\n\n\n  function _generateId(el) {\n    var str = el.tagName + el.className + el.src + el.href + el.textContent,\n        i = str.length,\n        sum = 0;\n\n    while (i--) {\n      sum += str.charCodeAt(i);\n    }\n\n    return sum.toString(36);\n  }\n\n  function _saveInputCheckedState(root) {\n    savedInputChecked.length = 0;\n    var inputs = root.getElementsByTagName('input');\n    var idx = inputs.length;\n\n    while (idx--) {\n      var el = inputs[idx];\n      el.checked && savedInputChecked.push(el);\n    }\n  }\n\n  function _nextTick(fn) {\n    return setTimeout(fn, 0);\n  }\n\n  function _cancelNextTick(id) {\n    return clearTimeout(id);\n  } // Fixed #973:\n\n\n  if (documentExists) {\n    on(document, 'touchmove', function (evt) {\n      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n        evt.preventDefault();\n      }\n    });\n  } // Export utils\n\n\n  Sortable.utils = {\n    on: on,\n    off: off,\n    css: css,\n    find: find,\n    is: function is(el, selector) {\n      return !!closest(el, selector, el, false);\n    },\n    extend: extend,\n    throttle: throttle,\n    closest: closest,\n    toggleClass: toggleClass,\n    clone: clone,\n    index: index,\n    nextTick: _nextTick,\n    cancelNextTick: _cancelNextTick,\n    detectDirection: _detectDirection,\n    getChild: getChild\n  };\n  /**\n   * Get the Sortable instance of an element\n   * @param  {HTMLElement} element The element\n   * @return {Sortable|undefined}         The instance of Sortable\n   */\n\n  Sortable.get = function (element) {\n    return element[expando];\n  };\n  /**\n   * Mount a plugin to Sortable\n   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n   */\n\n\n  Sortable.mount = function () {\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n\n    if (plugins[0].constructor === Array) plugins = plugins[0];\n    plugins.forEach(function (plugin) {\n      if (!plugin.prototype || !plugin.prototype.constructor) {\n        throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n      }\n\n      if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);\n      PluginManager.mount(plugin);\n    });\n  };\n  /**\n   * Create sortable instance\n   * @param {HTMLElement}  el\n   * @param {Object}      [options]\n   */\n\n\n  Sortable.create = function (el, options) {\n    return new Sortable(el, options);\n  }; // Export\n\n\n  Sortable.version = version;\n\n  var autoScrolls = [],\n      scrollEl,\n      scrollRootEl,\n      scrolling = false,\n      lastAutoScrollX,\n      lastAutoScrollY,\n      touchEvt$1,\n      pointerElemChangedInterval;\n\n  function AutoScrollPlugin() {\n    function AutoScroll() {\n      this.defaults = {\n        scroll: true,\n        scrollSensitivity: 30,\n        scrollSpeed: 10,\n        bubbleScroll: true\n      }; // Bind all private methods\n\n      for (var fn in this) {\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n          this[fn] = this[fn].bind(this);\n        }\n      }\n    }\n\n    AutoScroll.prototype = {\n      dragStarted: function dragStarted(_ref) {\n        var originalEvent = _ref.originalEvent;\n\n        if (this.sortable.nativeDraggable) {\n          on(document, 'dragover', this._handleAutoScroll);\n        } else {\n          if (this.options.supportPointer) {\n            on(document, 'pointermove', this._handleFallbackAutoScroll);\n          } else if (originalEvent.touches) {\n            on(document, 'touchmove', this._handleFallbackAutoScroll);\n          } else {\n            on(document, 'mousemove', this._handleFallbackAutoScroll);\n          }\n        }\n      },\n      dragOverCompleted: function dragOverCompleted(_ref2) {\n        var originalEvent = _ref2.originalEvent;\n\n        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n        if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n          this._handleAutoScroll(originalEvent);\n        }\n      },\n      drop: function drop() {\n        if (this.sortable.nativeDraggable) {\n          off(document, 'dragover', this._handleAutoScroll);\n        } else {\n          off(document, 'pointermove', this._handleFallbackAutoScroll);\n          off(document, 'touchmove', this._handleFallbackAutoScroll);\n          off(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n\n        clearPointerElemChangedInterval();\n        clearAutoScrolls();\n        cancelThrottle();\n      },\n      nulling: function nulling() {\n        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n        autoScrolls.length = 0;\n      },\n      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n        this._handleAutoScroll(evt, true);\n      },\n      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n        var _this = this;\n\n        var x = (evt.touches ? evt.touches[0] : evt).clientX,\n            y = (evt.touches ? evt.touches[0] : evt).clientY,\n            elem = document.elementFromPoint(x, y);\n        touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n        // Edge's autoscroll seems too conditional,\n        // MACOS Safari does not have autoscroll,\n        // Firefox and Chrome are good\n\n        if (fallback || Edge || IE11OrLess || Safari) {\n          autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n          var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n            pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n            pointerElemChangedInterval = setInterval(function () {\n              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n              if (newElem !== ogElemScroller) {\n                ogElemScroller = newElem;\n                clearAutoScrolls();\n              }\n\n              autoScroll(evt, _this.options, newElem, fallback);\n            }, 10);\n            lastAutoScrollX = x;\n            lastAutoScrollY = y;\n          }\n        } else {\n          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n            clearAutoScrolls();\n            return;\n          }\n\n          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n        }\n      }\n    };\n    return _extends(AutoScroll, {\n      pluginName: 'scroll',\n      initializeByDefault: true\n    });\n  }\n\n  function clearAutoScrolls() {\n    autoScrolls.forEach(function (autoScroll) {\n      clearInterval(autoScroll.pid);\n    });\n    autoScrolls = [];\n  }\n\n  function clearPointerElemChangedInterval() {\n    clearInterval(pointerElemChangedInterval);\n  }\n\n  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n    if (!options.scroll) return;\n    var x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        sens = options.scrollSensitivity,\n        speed = options.scrollSpeed,\n        winScroller = getWindowScrollingElement();\n    var scrollThisInstance = false,\n        scrollCustomFn; // New scroll root, set scrollEl\n\n    if (scrollRootEl !== rootEl) {\n      scrollRootEl = rootEl;\n      clearAutoScrolls();\n      scrollEl = options.scroll;\n      scrollCustomFn = options.scrollFn;\n\n      if (scrollEl === true) {\n        scrollEl = getParentAutoScrollElement(rootEl, true);\n      }\n    }\n\n    var layersOut = 0;\n    var currentParent = scrollEl;\n\n    do {\n      var el = currentParent,\n          rect = getRect(el),\n          top = rect.top,\n          bottom = rect.bottom,\n          left = rect.left,\n          right = rect.right,\n          width = rect.width,\n          height = rect.height,\n          canScrollX = void 0,\n          canScrollY = void 0,\n          scrollWidth = el.scrollWidth,\n          scrollHeight = el.scrollHeight,\n          elCSS = css(el),\n          scrollPosX = el.scrollLeft,\n          scrollPosY = el.scrollTop;\n\n      if (el === winScroller) {\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n      } else {\n        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n      }\n\n      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n      if (!autoScrolls[layersOut]) {\n        for (var i = 0; i <= layersOut; i++) {\n          if (!autoScrolls[i]) {\n            autoScrolls[i] = {};\n          }\n        }\n      }\n\n      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n        autoScrolls[layersOut].el = el;\n        autoScrolls[layersOut].vx = vx;\n        autoScrolls[layersOut].vy = vy;\n        clearInterval(autoScrolls[layersOut].pid);\n\n        if (vx != 0 || vy != 0) {\n          scrollThisInstance = true;\n          /* jshint loopfunc:true */\n\n          autoScrolls[layersOut].pid = setInterval(function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n            }\n\n            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n            if (typeof scrollCustomFn === 'function') {\n              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({\n            layer: layersOut\n          }), 24);\n        }\n      }\n\n      layersOut++;\n    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n  }, 30);\n\n  var drop = function drop(_ref) {\n    var originalEvent = _ref.originalEvent,\n        putSortable = _ref.putSortable,\n        dragEl = _ref.dragEl,\n        activeSortable = _ref.activeSortable,\n        dispatchSortableEvent = _ref.dispatchSortableEvent,\n        hideGhostForTarget = _ref.hideGhostForTarget,\n        unhideGhostForTarget = _ref.unhideGhostForTarget;\n    if (!originalEvent) return;\n    var toSortable = putSortable || activeSortable;\n    hideGhostForTarget();\n    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n    var target = document.elementFromPoint(touch.clientX, touch.clientY);\n    unhideGhostForTarget();\n\n    if (toSortable && !toSortable.el.contains(target)) {\n      dispatchSortableEvent('spill');\n      this.onSpill({\n        dragEl: dragEl,\n        putSortable: putSortable\n      });\n    }\n  };\n\n  function Revert() {}\n\n  Revert.prototype = {\n    startIndex: null,\n    dragStart: function dragStart(_ref2) {\n      var oldDraggableIndex = _ref2.oldDraggableIndex;\n      this.startIndex = oldDraggableIndex;\n    },\n    onSpill: function onSpill(_ref3) {\n      var dragEl = _ref3.dragEl,\n          putSortable = _ref3.putSortable;\n      this.sortable.captureAnimationState();\n\n      if (putSortable) {\n        putSortable.captureAnimationState();\n      }\n\n      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n      if (nextSibling) {\n        this.sortable.el.insertBefore(dragEl, nextSibling);\n      } else {\n        this.sortable.el.appendChild(dragEl);\n      }\n\n      this.sortable.animateAll();\n\n      if (putSortable) {\n        putSortable.animateAll();\n      }\n    },\n    drop: drop\n  };\n\n  _extends(Revert, {\n    pluginName: 'revertOnSpill'\n  });\n\n  function Remove() {}\n\n  Remove.prototype = {\n    onSpill: function onSpill(_ref4) {\n      var dragEl = _ref4.dragEl,\n          putSortable = _ref4.putSortable;\n      var parentSortable = putSortable || this.sortable;\n      parentSortable.captureAnimationState();\n      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n      parentSortable.animateAll();\n    },\n    drop: drop\n  };\n\n  _extends(Remove, {\n    pluginName: 'removeOnSpill'\n  });\n\n  var lastSwapEl;\n\n  function SwapPlugin() {\n    function Swap() {\n      this.defaults = {\n        swapClass: 'sortable-swap-highlight'\n      };\n    }\n\n    Swap.prototype = {\n      dragStart: function dragStart(_ref) {\n        var dragEl = _ref.dragEl;\n        lastSwapEl = dragEl;\n      },\n      dragOverValid: function dragOverValid(_ref2) {\n        var completed = _ref2.completed,\n            target = _ref2.target,\n            onMove = _ref2.onMove,\n            activeSortable = _ref2.activeSortable,\n            changed = _ref2.changed,\n            cancel = _ref2.cancel;\n        if (!activeSortable.options.swap) return;\n        var el = this.sortable.el,\n            options = this.options;\n\n        if (target && target !== el) {\n          var prevSwapEl = lastSwapEl;\n\n          if (onMove(target) !== false) {\n            toggleClass(target, options.swapClass, true);\n            lastSwapEl = target;\n          } else {\n            lastSwapEl = null;\n          }\n\n          if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n            toggleClass(prevSwapEl, options.swapClass, false);\n          }\n        }\n\n        changed();\n        completed(true);\n        cancel();\n      },\n      drop: function drop(_ref3) {\n        var activeSortable = _ref3.activeSortable,\n            putSortable = _ref3.putSortable,\n            dragEl = _ref3.dragEl;\n        var toSortable = putSortable || this.sortable;\n        var options = this.options;\n        lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n        if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n          if (dragEl !== lastSwapEl) {\n            toSortable.captureAnimationState();\n            if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n            swapNodes(dragEl, lastSwapEl);\n            toSortable.animateAll();\n            if (toSortable !== activeSortable) activeSortable.animateAll();\n          }\n        }\n      },\n      nulling: function nulling() {\n        lastSwapEl = null;\n      }\n    };\n    return _extends(Swap, {\n      pluginName: 'swap',\n      eventProperties: function eventProperties() {\n        return {\n          swapItem: lastSwapEl\n        };\n      }\n    });\n  }\n\n  function swapNodes(n1, n2) {\n    var p1 = n1.parentNode,\n        p2 = n2.parentNode,\n        i1,\n        i2;\n    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n    i1 = index(n1);\n    i2 = index(n2);\n\n    if (p1.isEqualNode(p2) && i1 < i2) {\n      i2++;\n    }\n\n    p1.insertBefore(n2, p1.children[i1]);\n    p2.insertBefore(n1, p2.children[i2]);\n  }\n\n  var multiDragElements = [],\n      multiDragClones = [],\n      lastMultiDragSelect,\n      // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n      initialFolding = false,\n      // Initial multi-drag fold when drag started\n  folding = false,\n      // Folding any other time\n  dragStarted = false,\n      dragEl$1,\n      clonesFromRect,\n      clonesHidden;\n\n  function MultiDragPlugin() {\n    function MultiDrag(sortable) {\n      // Bind all private methods\n      for (var fn in this) {\n        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n          this[fn] = this[fn].bind(this);\n        }\n      }\n\n      if (sortable.options.supportPointer) {\n        on(document, 'pointerup', this._deselectMultiDrag);\n      } else {\n        on(document, 'mouseup', this._deselectMultiDrag);\n        on(document, 'touchend', this._deselectMultiDrag);\n      }\n\n      on(document, 'keydown', this._checkKeyDown);\n      on(document, 'keyup', this._checkKeyUp);\n      this.defaults = {\n        selectedClass: 'sortable-selected',\n        multiDragKey: null,\n        setData: function setData(dataTransfer, dragEl) {\n          var data = '';\n\n          if (multiDragElements.length && multiDragSortable === sortable) {\n            multiDragElements.forEach(function (multiDragElement, i) {\n              data += (!i ? '' : ', ') + multiDragElement.textContent;\n            });\n          } else {\n            data = dragEl.textContent;\n          }\n\n          dataTransfer.setData('Text', data);\n        }\n      };\n    }\n\n    MultiDrag.prototype = {\n      multiDragKeyDown: false,\n      isMultiDrag: false,\n      delayStartGlobal: function delayStartGlobal(_ref) {\n        var dragged = _ref.dragEl;\n        dragEl$1 = dragged;\n      },\n      delayEnded: function delayEnded() {\n        this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n      },\n      setupClone: function setupClone(_ref2) {\n        var sortable = _ref2.sortable,\n            cancel = _ref2.cancel;\n        if (!this.isMultiDrag) return;\n\n        for (var i = 0; i < multiDragElements.length; i++) {\n          multiDragClones.push(clone(multiDragElements[i]));\n          multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n          multiDragClones[i].draggable = false;\n          multiDragClones[i].style['will-change'] = '';\n          toggleClass(multiDragClones[i], this.options.selectedClass, false);\n          multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n        }\n\n        sortable._hideClone();\n\n        cancel();\n      },\n      clone: function clone(_ref3) {\n        var sortable = _ref3.sortable,\n            rootEl = _ref3.rootEl,\n            dispatchSortableEvent = _ref3.dispatchSortableEvent,\n            cancel = _ref3.cancel;\n        if (!this.isMultiDrag) return;\n\n        if (!this.options.removeCloneOnHide) {\n          if (multiDragElements.length && multiDragSortable === sortable) {\n            insertMultiDragClones(true, rootEl);\n            dispatchSortableEvent('clone');\n            cancel();\n          }\n        }\n      },\n      showClone: function showClone(_ref4) {\n        var cloneNowShown = _ref4.cloneNowShown,\n            rootEl = _ref4.rootEl,\n            cancel = _ref4.cancel;\n        if (!this.isMultiDrag) return;\n        insertMultiDragClones(false, rootEl);\n        multiDragClones.forEach(function (clone) {\n          css(clone, 'display', '');\n        });\n        cloneNowShown();\n        clonesHidden = false;\n        cancel();\n      },\n      hideClone: function hideClone(_ref5) {\n        var _this = this;\n\n        var sortable = _ref5.sortable,\n            cloneNowHidden = _ref5.cloneNowHidden,\n            cancel = _ref5.cancel;\n        if (!this.isMultiDrag) return;\n        multiDragClones.forEach(function (clone) {\n          css(clone, 'display', 'none');\n\n          if (_this.options.removeCloneOnHide && clone.parentNode) {\n            clone.parentNode.removeChild(clone);\n          }\n        });\n        cloneNowHidden();\n        clonesHidden = true;\n        cancel();\n      },\n      dragStartGlobal: function dragStartGlobal(_ref6) {\n        var sortable = _ref6.sortable;\n\n        if (!this.isMultiDrag && multiDragSortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n        }\n\n        multiDragElements.forEach(function (multiDragElement) {\n          multiDragElement.sortableIndex = index(multiDragElement);\n        }); // Sort multi-drag elements\n\n        multiDragElements = multiDragElements.sort(function (a, b) {\n          return a.sortableIndex - b.sortableIndex;\n        });\n        dragStarted = true;\n      },\n      dragStarted: function dragStarted(_ref7) {\n        var _this2 = this;\n\n        var sortable = _ref7.sortable;\n        if (!this.isMultiDrag) return;\n\n        if (this.options.sort) {\n          // Capture rects,\n          // hide multi drag elements (by positioning them absolute),\n          // set multi drag elements rects to dragRect,\n          // show multi drag elements,\n          // animate to rects,\n          // unset rects & remove from DOM\n          sortable.captureAnimationState();\n\n          if (this.options.animation) {\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              css(multiDragElement, 'position', 'absolute');\n            });\n            var dragRect = getRect(dragEl$1, false, true, true);\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              setRect(multiDragElement, dragRect);\n            });\n            folding = true;\n            initialFolding = true;\n          }\n        }\n\n        sortable.animateAll(function () {\n          folding = false;\n          initialFolding = false;\n\n          if (_this2.options.animation) {\n            multiDragElements.forEach(function (multiDragElement) {\n              unsetRect(multiDragElement);\n            });\n          } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n          if (_this2.options.sort) {\n            removeMultiDragElements();\n          }\n        });\n      },\n      dragOver: function dragOver(_ref8) {\n        var target = _ref8.target,\n            completed = _ref8.completed,\n            cancel = _ref8.cancel;\n\n        if (folding && ~multiDragElements.indexOf(target)) {\n          completed(false);\n          cancel();\n        }\n      },\n      revert: function revert(_ref9) {\n        var fromSortable = _ref9.fromSortable,\n            rootEl = _ref9.rootEl,\n            sortable = _ref9.sortable,\n            dragRect = _ref9.dragRect;\n\n        if (multiDragElements.length > 1) {\n          // Setup unfold animation\n          multiDragElements.forEach(function (multiDragElement) {\n            sortable.addAnimationState({\n              target: multiDragElement,\n              rect: folding ? getRect(multiDragElement) : dragRect\n            });\n            unsetRect(multiDragElement);\n            multiDragElement.fromRect = dragRect;\n            fromSortable.removeAnimationState(multiDragElement);\n          });\n          folding = false;\n          insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n        }\n      },\n      dragOverCompleted: function dragOverCompleted(_ref10) {\n        var sortable = _ref10.sortable,\n            isOwner = _ref10.isOwner,\n            insertion = _ref10.insertion,\n            activeSortable = _ref10.activeSortable,\n            parentEl = _ref10.parentEl,\n            putSortable = _ref10.putSortable;\n        var options = this.options;\n\n        if (insertion) {\n          // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n          if (isOwner) {\n            activeSortable._hideClone();\n          }\n\n          initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n          if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n            // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n            var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n            multiDragElements.forEach(function (multiDragElement) {\n              if (multiDragElement === dragEl$1) return;\n              setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n              // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n              parentEl.appendChild(multiDragElement);\n            });\n            folding = true;\n          } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n          if (!isOwner) {\n            // Only remove if not folding (folding will remove them anyways)\n            if (!folding) {\n              removeMultiDragElements();\n            }\n\n            if (multiDragElements.length > 1) {\n              var clonesHiddenBefore = clonesHidden;\n\n              activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n              if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n                multiDragClones.forEach(function (clone) {\n                  activeSortable.addAnimationState({\n                    target: clone,\n                    rect: clonesFromRect\n                  });\n                  clone.fromRect = clonesFromRect;\n                  clone.thisAnimationDuration = null;\n                });\n              }\n            } else {\n              activeSortable._showClone(sortable);\n            }\n          }\n        }\n      },\n      dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n        var dragRect = _ref11.dragRect,\n            isOwner = _ref11.isOwner,\n            activeSortable = _ref11.activeSortable;\n        multiDragElements.forEach(function (multiDragElement) {\n          multiDragElement.thisAnimationDuration = null;\n        });\n\n        if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n          clonesFromRect = _extends({}, dragRect);\n          var dragMatrix = matrix(dragEl$1, true);\n          clonesFromRect.top -= dragMatrix.f;\n          clonesFromRect.left -= dragMatrix.e;\n        }\n      },\n      dragOverAnimationComplete: function dragOverAnimationComplete() {\n        if (folding) {\n          folding = false;\n          removeMultiDragElements();\n        }\n      },\n      drop: function drop(_ref12) {\n        var evt = _ref12.originalEvent,\n            rootEl = _ref12.rootEl,\n            parentEl = _ref12.parentEl,\n            sortable = _ref12.sortable,\n            dispatchSortableEvent = _ref12.dispatchSortableEvent,\n            oldIndex = _ref12.oldIndex,\n            putSortable = _ref12.putSortable;\n        var toSortable = putSortable || this.sortable;\n        if (!evt) return;\n        var options = this.options,\n            children = parentEl.children; // Multi-drag selection\n\n        if (!dragStarted) {\n          if (options.multiDragKey && !this.multiDragKeyDown) {\n            this._deselectMultiDrag();\n          }\n\n          toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n          if (!~multiDragElements.indexOf(dragEl$1)) {\n            multiDragElements.push(dragEl$1);\n            dispatchEvent({\n              sortable: sortable,\n              rootEl: rootEl,\n              name: 'select',\n              targetEl: dragEl$1,\n              originalEvt: evt\n            }); // Modifier activated, select from last to dragEl\n\n            if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n              var lastIndex = index(lastMultiDragSelect),\n                  currentIndex = index(dragEl$1);\n\n              if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n                // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n                // (but previous selection existed)\n                var n, i;\n\n                if (currentIndex > lastIndex) {\n                  i = lastIndex;\n                  n = currentIndex;\n                } else {\n                  i = currentIndex;\n                  n = lastIndex + 1;\n                }\n\n                for (; i < n; i++) {\n                  if (~multiDragElements.indexOf(children[i])) continue;\n                  toggleClass(children[i], options.selectedClass, true);\n                  multiDragElements.push(children[i]);\n                  dispatchEvent({\n                    sortable: sortable,\n                    rootEl: rootEl,\n                    name: 'select',\n                    targetEl: children[i],\n                    originalEvt: evt\n                  });\n                }\n              }\n            } else {\n              lastMultiDragSelect = dragEl$1;\n            }\n\n            multiDragSortable = toSortable;\n          } else {\n            multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n            lastMultiDragSelect = null;\n            dispatchEvent({\n              sortable: sortable,\n              rootEl: rootEl,\n              name: 'deselect',\n              targetEl: dragEl$1,\n              originalEvt: evt\n            });\n          }\n        } // Multi-drag drop\n\n\n        if (dragStarted && this.isMultiDrag) {\n          // Do not \"unfold\" after around dragEl if reverted\n          if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n            var dragRect = getRect(dragEl$1),\n                multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n            if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n            toSortable.captureAnimationState();\n\n            if (!initialFolding) {\n              if (options.animation) {\n                dragEl$1.fromRect = dragRect;\n                multiDragElements.forEach(function (multiDragElement) {\n                  multiDragElement.thisAnimationDuration = null;\n\n                  if (multiDragElement !== dragEl$1) {\n                    var rect = folding ? getRect(multiDragElement) : dragRect;\n                    multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                    toSortable.addAnimationState({\n                      target: multiDragElement,\n                      rect: rect\n                    });\n                  }\n                });\n              } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n              // properly they must all be removed\n\n\n              removeMultiDragElements();\n              multiDragElements.forEach(function (multiDragElement) {\n                if (children[multiDragIndex]) {\n                  parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n                } else {\n                  parentEl.appendChild(multiDragElement);\n                }\n\n                multiDragIndex++;\n              }); // If initial folding is done, the elements may have changed position because they are now\n              // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n              // must be fired here as Sortable will not.\n\n              if (oldIndex === index(dragEl$1)) {\n                var update = false;\n                multiDragElements.forEach(function (multiDragElement) {\n                  if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                    update = true;\n                    return;\n                  }\n                });\n\n                if (update) {\n                  dispatchSortableEvent('update');\n                }\n              }\n            } // Must be done after capturing individual rects (scroll bar)\n\n\n            multiDragElements.forEach(function (multiDragElement) {\n              unsetRect(multiDragElement);\n            });\n            toSortable.animateAll();\n          }\n\n          multiDragSortable = toSortable;\n        } // Remove clones if necessary\n\n\n        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n          multiDragClones.forEach(function (clone) {\n            clone.parentNode && clone.parentNode.removeChild(clone);\n          });\n        }\n      },\n      nullingGlobal: function nullingGlobal() {\n        this.isMultiDrag = dragStarted = false;\n        multiDragClones.length = 0;\n      },\n      destroyGlobal: function destroyGlobal() {\n        this._deselectMultiDrag();\n\n        off(document, 'pointerup', this._deselectMultiDrag);\n        off(document, 'mouseup', this._deselectMultiDrag);\n        off(document, 'touchend', this._deselectMultiDrag);\n        off(document, 'keydown', this._checkKeyDown);\n        off(document, 'keyup', this._checkKeyUp);\n      },\n      _deselectMultiDrag: function _deselectMultiDrag(evt) {\n        if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n        if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n        if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n        if (evt && evt.button !== 0) return;\n\n        while (multiDragElements.length) {\n          var el = multiDragElements[0];\n          toggleClass(el, this.options.selectedClass, false);\n          multiDragElements.shift();\n          dispatchEvent({\n            sortable: this.sortable,\n            rootEl: this.sortable.el,\n            name: 'deselect',\n            targetEl: el,\n            originalEvt: evt\n          });\n        }\n      },\n      _checkKeyDown: function _checkKeyDown(evt) {\n        if (evt.key === this.options.multiDragKey) {\n          this.multiDragKeyDown = true;\n        }\n      },\n      _checkKeyUp: function _checkKeyUp(evt) {\n        if (evt.key === this.options.multiDragKey) {\n          this.multiDragKeyDown = false;\n        }\n      }\n    };\n    return _extends(MultiDrag, {\n      // Static methods & properties\n      pluginName: 'multiDrag',\n      utils: {\n        /**\r\n         * Selects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be selected\r\n         */\n        select: function select(el) {\n          var sortable = el.parentNode[expando];\n          if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n          if (multiDragSortable && multiDragSortable !== sortable) {\n            multiDragSortable.multiDrag._deselectMultiDrag();\n\n            multiDragSortable = sortable;\n          }\n\n          toggleClass(el, sortable.options.selectedClass, true);\n          multiDragElements.push(el);\n        },\n\n        /**\r\n         * Deselects the provided multi-drag item\r\n         * @param  {HTMLElement} el    The element to be deselected\r\n         */\n        deselect: function deselect(el) {\n          var sortable = el.parentNode[expando],\n              index = multiDragElements.indexOf(el);\n          if (!sortable || !sortable.options.multiDrag || !~index) return;\n          toggleClass(el, sortable.options.selectedClass, false);\n          multiDragElements.splice(index, 1);\n        }\n      },\n      eventProperties: function eventProperties() {\n        var _this3 = this;\n\n        var oldIndicies = [],\n            newIndicies = [];\n        multiDragElements.forEach(function (multiDragElement) {\n          oldIndicies.push({\n            multiDragElement: multiDragElement,\n            index: multiDragElement.sortableIndex\n          }); // multiDragElements will already be sorted if folding\n\n          var newIndex;\n\n          if (folding && multiDragElement !== dragEl$1) {\n            newIndex = -1;\n          } else if (folding) {\n            newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n          } else {\n            newIndex = index(multiDragElement);\n          }\n\n          newIndicies.push({\n            multiDragElement: multiDragElement,\n            index: newIndex\n          });\n        });\n        return {\n          items: _toConsumableArray(multiDragElements),\n          clones: [].concat(multiDragClones),\n          oldIndicies: oldIndicies,\n          newIndicies: newIndicies\n        };\n      },\n      optionListeners: {\n        multiDragKey: function multiDragKey(key) {\n          key = key.toLowerCase();\n\n          if (key === 'ctrl') {\n            key = 'Control';\n          } else if (key.length > 1) {\n            key = key.charAt(0).toUpperCase() + key.substr(1);\n          }\n\n          return key;\n        }\n      }\n    });\n  }\n\n  function insertMultiDragElements(clonesInserted, rootEl) {\n    multiDragElements.forEach(function (multiDragElement, i) {\n      var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n      if (target) {\n        rootEl.insertBefore(multiDragElement, target);\n      } else {\n        rootEl.appendChild(multiDragElement);\n      }\n    });\n  }\n  /**\r\n   * Insert multi-drag clones\r\n   * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n   * @param  {HTMLElement} rootEl\r\n   */\n\n\n  function insertMultiDragClones(elementsInserted, rootEl) {\n    multiDragClones.forEach(function (clone, i) {\n      var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n      if (target) {\n        rootEl.insertBefore(clone, target);\n      } else {\n        rootEl.appendChild(clone);\n      }\n    });\n  }\n\n  function removeMultiDragElements() {\n    multiDragElements.forEach(function (multiDragElement) {\n      if (multiDragElement === dragEl$1) return;\n      multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n    });\n  }\n\n  Sortable.mount(new AutoScrollPlugin());\n  Sortable.mount(Remove, Revert);\n\n  Sortable.mount(new SwapPlugin());\n  Sortable.mount(new MultiDragPlugin());\n\n  return Sortable;\n\n}));\n","import * as utils from './modules/utils.mjs'\nimport * as search from './modules/search.mjs'\nimport setDashboardPreferences from './modules/preferences/dashboard.mjs'\nimport { cloneAndUpdateMenu } from './modules/utils.mjs'\nimport setMenuPreferences from './modules/preferences/menu.mjs'\nimport urgentAnnouncement from './web-components/urgent-announcement.mjs'\nimport { WC_announcementsWidget } from './web-components/announcements.mjs'\nimport * as unreadAnnouncements from './modules/unreadAnnouncements.mjs'\nimport * as notify from './modules/notify.mjs'\n\nconst page = document.querySelector('main').id.toLowerCase()\n\nif (page !== 'account') {\n    cloneAndUpdateMenu()\n}\n\n//init web components\nif (page === 'dashboard') {\n    utils.appendWidgets(utils.getPreferences())\n}\n\nif (page === 'account') {\n    setDashboardPreferences()\n    setMenuPreferences()\n}\n\nif (page === 'announcements-overview') {\n    const announcementList = document.getElementById('announcements')\n    announcementList.remove()\n    document.querySelector('main section').append(document.createElement('announcements-widget'))\n    WC_announcementsWidget(page)\n}\n\n\n//check if browser is online\nif (navigator.onLine) {\n    //urgent announcements\n    const socket = io()\n\n    //subscribe to urgent-announcements\n    socket.emit('join', page)\n\n    //on urgent-announcement hook update interface (see WC_urgentAnnouncement)\n    socket.on('urgent-announcement', announcement => {\n        const urgentAnnouncement = document.querySelector('urgent-announcement')\n\n        if (utils.exists([urgentAnnouncement])) {\n            urgentAnnouncement.setAttribute('message', announcement.content)\n            urgentAnnouncement.setAttribute('uid', announcement.newsItemId)\n        }\n\n        if ('Notification' in window) {\n            navigator.serviceWorker.ready //wait for sw to be ready\n                .then(registration => {\n                    Notification.requestPermission(status => {\n                        notify.displayNotification(announcement.title, announcement.content)\n                    })\n                })\n        }\n    })\n}\n\n\n\n\n//menu \nconst menuIcon = document.getElementById('menu-icon')\nconst menu = document.getElementById('menu')\n\nif (utils.exists([menuIcon, menu])) {\n    document.querySelector('#fallback').remove()\n\n    //toggle menu (on mobile)\n    menuIcon.addEventListener('click', event => {\n        event.preventDefault()\n\n        menu.classList.toggle('hide')\n    })\n}\n\n\n\n\n//search \nconst searchBar = document.getElementById('search-bar')\nconst searchResetIcon = document.getElementById('search-reset')\nconst searchIcon = document.querySelector('#search-container input[type=submit]')\n\nif (utils.exists([searchBar, searchResetIcon, searchIcon])) {\n\n    //control search-reset icon \n    searchBar.addEventListener('focus', () => search.showReset())\n    searchBar.addEventListener('blur', () => search.hideReset())\n\n\n    //reset search input\n    searchResetIcon.addEventListener('click', e => search.reset(e))\n\n\n    //depending on search-query either give focus to searchbar or submit search-query\n    searchIcon.addEventListener('click', e => {\n        if (searchBar.value === \"\") {\n            search.focus(e)\n        }\n    })\n\n\n    //listen to keyboard input\n    document.addEventListener('keypress', e => {\n        switch (e.key) {\n            case \"/\":\n                search.focus(e) //give searchbar focus and hide search-reset icon\n                break\n        }\n    })\n}\n\n\n//unread announcement indicator in menu\nconst announcementMenuItem = document.querySelector('#menu-primary-links a:last-of-type')\n\nif (utils.exists([announcementMenuItem]) && utils.storageAvailable('localStorage')) {\n    unreadAnnouncements.indicate(announcementMenuItem)\n}","export function displayNotification(title, body) {\n    if (Notification.permission === 'granted') {\n        navigator.serviceWorker.getRegistration().then(reg => {\n            const options = {\n                body,\n                icon: './media/icons/hva-logo-purple.svg',\n                vibrate: [100, 50, 100],\n                data: {\n                    timestamp: Date.now()\n                },\n                actions: [{\n                        action: 'goto',\n                        title: 'Go to HvA Portal',\n                        icon: './media/icons/hva-logo-purple.svg'\n                    },\n                    {\n                        action: 'close',\n                        title: 'Close notification',\n                        icon: './media/icons/hva-logo-purple.svg'\n                    },\n                ]\n            }\n            reg.showNotification(title, options)\n        })\n    }\n}","import { setLocalStorage, getLocalStorage } from '../../modules/utils.mjs'\nimport Sortable from 'sortablejs'\n\nconst container = document.querySelector('#preferences')\nexport default function setDashboardPreferences() {\n    container.classList.remove('disabled')\n\n    getPreferences()\n    stateHandler()\n    dragHandler()\n}\n\nfunction getPreferences() {\n    const preferences = getLocalStorage('preferences')\n    if (preferences) {\n        container.textContent = ''\n        preferences.forEach(preference => container.append(createLabels(preference)))\n    } else {\n        setPreferencesObject()\n    }\n}\n\nfunction dragHandler() {\n    const preferencesContainer = document.querySelector('#preferences')\n\n    new Sortable(preferencesContainer, {\n        draggable: \".on\",\n        animation: 150,\n        onStart: (event) => addStylingToDropZones(event),\n        onEnd: (event) => {\n            removeStylingFromDropZones(event)\n            setPreferencesObject()\n        }\n    })\n}\n\nfunction addStylingToDropZones(event) {\n    const dragLocations = [...event.target.querySelectorAll('label:not(.sortable-chosen)')]\n    dragLocations.forEach(location => location.classList.add('optional-location'))\n}\n\nfunction removeStylingFromDropZones(event) {\n    const dragLocations = [...event.target.querySelectorAll('label:not(.sortable-chosen)')]\n    dragLocations.forEach(location => location.classList.remove('optional-location'))\n}\n\n// Saving and changing preferences \nfunction setPreferencesObject() {\n    const inputs = [...document.querySelectorAll('#preferences label')]\n    let preferences = []\n\n    inputs.forEach(label => {\n        // Data\n        const id = label.id\n        const text = label.textContent\n        const state = label.querySelector('input').checked\n\n        // Set LocalStorage\n        const object = { id: id, name: text, state: state }\n        preferences.push(object)\n        setLocalStorage('preferences', preferences)\n    })\n\n    return preferences\n}\n\nfunction stateHandler() {\n    const inputs = [...document.querySelectorAll('#preferences label')]\n    const data = getLocalStorage('preferences')\n\n    inputs.forEach(label => {\n        updateState(data, label)\n\n        label.addEventListener('change', event => {\n            // Data\n            const id = label.id\n            const state = event.target.checked\n\n            // Change LocalStorage\n            const preference = data.find(preference => preference.id === id)\n            preference.state = state\n            setLocalStorage('preferences', data)\n\n            // Change state visualy\n            if (preference.state) {\n                label.classList.add('on')\n                label.classList.remove('off')\n            } else {\n                label.classList.add('off')\n                label.classList.remove('on')\n                container.appendChild(label)\n                setPreferencesObject()\n            }\n        })\n    })\n}\n\nfunction updateState(data, element) {\n    const preference = data.find(preference => preference.id === element.id)\n    preference.state ? element.classList.remove('off') : element.classList.add('on')\n}\n\n// Rearanging order\nfunction createLabels(preference) {\n    const label = document.createElement('label')\n    label.id = preference.id\n    preference.state ? label.className = 'on' : label.className = 'off'\n\n    label.setAttribute('represents', preference.id)\n\n    const input = document.createElement('input')\n    input.type = 'checkbox'\n    input.checked = preference.state\n\n    label.append(input)\n    label.append(preference.name)\n\n    return label\n}","import { setLocalStorage, getLocalStorage, storageAvailable } from '../../modules/utils.mjs'\nimport Sortable from 'sortablejs'\n\nconst container = document.querySelector('#menu-preferences')\nconst secondaryLinks = document.querySelector('#menu-secondary-links')\nconst clonedLinks = [...secondaryLinks.cloneNode(true).children]\n\nexport default function setMenuPreferences() {\n    container.classList.remove('disabled')\n\n    checker() ? renderPreferences() : setPreferences()\n    stateHandler()\n    dragHandler()\n    cloneAndUpdateMenu()\n}\n\nfunction cloneAndUpdateMenu() {\n    let selectedMenuItems = []\n\n    // LocalStorage\n    const preferences = getLocalStorage('menu-preferences')\n    preferences.forEach(preference => {\n        clonedLinks.forEach(link => {\n            const name = link.querySelector('p:first-of-type').textContent\n\n            if (preference.name === name && preference.state) {\n                selectedMenuItems.push(link)\n            }\n        })\n    })\n\n    secondaryLinks.textContent = ''\n    selectedMenuItems.forEach(item => secondaryLinks.append(item))\n}\n\nfunction stateHandler() {\n    const labels = [...container.querySelectorAll('label')]\n\n    labels.forEach(label => {\n        label.addEventListener('change', () => {\n            setPreferences()\n\n            if (label.className === 'off') {\n                container.append(label)\n                setPreferences()\n            }\n\n            if (label.className === 'on') {\n                const firstOff = document.querySelector('#menu-preferences .off')\n                container.insertBefore(label, firstOff)\n            }\n        })\n    })\n}\n\nfunction renderPreferences() {\n    const elements = createElements()\n    appendElements(elements)\n}\n\nfunction appendElements(elements) {\n    container.textContent = ''\n    elements.forEach(element => container.append(element))\n}\n\nfunction createElements() {\n    const preferences = getLocalStorage('menu-preferences')\n    const elements = []\n\n    preferences.forEach(preference => {\n        const label = document.createElement('label')\n        preference.state ? label.className = 'on' : label.className = 'off'\n\n        const handle = document.createElement('span')\n        handle.classList.add('handle')\n\n        const input = document.createElement('input')\n        input.type = 'checkbox'\n        input.checked = preference.state\n\n        label.append(handle)\n        label.append(input)\n        label.append(preference.name)\n\n        elements.push(label)\n    })\n\n    return elements\n}\n\nfunction checker() {\n    return storageAvailable('localStorage') && getLocalStorage('menu-preferences') ?\n        true : false\n}\n\nfunction dragHandler() {\n    new Sortable(container, {\n        animation: 150,\n        onStart: (event) => addStylingToDropZones(event),\n        onEnd: () => {\n            removeStylingFromDropZones(event)\n            setPreferences()\n        }\n    })\n}\n\nfunction addStylingToDropZones(event) {\n    const dragLocations = [...event.target.querySelectorAll('label:not(.sortable-chosen)')]\n    dragLocations.forEach(location => location.classList.add('optional-location'))\n}\n\nfunction removeStylingFromDropZones(event) {\n    const dragLocations = [...event.target.querySelectorAll('label:not(.sortable-chosen)')]\n    dragLocations.forEach(location => location.classList.remove('optional-location'))\n}\n\nfunction setPreferences() {\n    const labels = [...container.querySelectorAll('label')]\n    let preferences = []\n\n    labels.forEach(label => {\n        const text = label.textContent\n        const state = label.querySelector('input').checked\n        state ? label.className = 'on' : label.className = 'off'\n\n        const object = { name: text, state: state }\n        preferences.push(object)\n    })\n\n    setLocalStorage('menu-preferences', preferences)\n    cloneAndUpdateMenu()\n}","const searchBar = document.getElementById('search-bar')\nconst searchResetIcon = document.getElementById('search-reset')\n\nexport function focus(e) {\n    e.preventDefault()\n    searchBar.focus()\n}\n\nexport function showReset() {\n    searchResetIcon.classList.remove('hide')\n}\n\nexport function hideReset() {\n    if (searchBar.value === \"\") {\n        searchResetIcon.classList.add('hide')\n    }\n}\n\nexport function reset(e) {\n    searchBar.value = \"\"\n    focus(e)\n}","import * as utils from '../modules/utils.mjs'\n\nexport function indicate(item) {\n    getUnread()\n        .then(numberUnread => {\n            if (numberUnread > 0) {\n                item.classList.add('unread-indicator')\n                item.setAttribute('number-unread', numberUnread)\n            }\n        })\n}\n\n\nfunction getAnnouncements() {\n    const options = {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n    }\n\n    return fetch('/announcementslist', options).then(res => res.json())\n}\n\nfunction getUnread() {\n    const storedHistory = utils.getLocalStorage('read-history')\n    const numberUnread = getAnnouncements()\n        .then(json => {\n            const [announcements, categories] = json\n            return announcements\n        })\n        .then(announcements => {\n            let numberOfUnread = 0\n            if (storedHistory) {\n                announcements.forEach(announcement => {\n                    if (!storedHistory.includes(announcement.newsItemId)) {\n                        numberOfUnread++\n                    }\n                })\n            } else {\n                document.querySelector('#menu-primary-links a:last-of-type').classList.add('unread-indicator')\n                document.querySelector('#menu-primary-links a:last-of-type').setAttribute('number-unread', announcements.length)\n            }\n            return numberOfUnread\n        })\n    return numberUnread\n}","import { WC_studyprogress } from '../web-components/study-progress.mjs'\nimport { WC_scheduleWidget } from '../web-components/schedule.mjs'\nimport { WC_courseoverview } from '../web-components/course-overview.mjs'\nimport { WC_announcementsWidget } from '../web-components/announcements.mjs'\n\nexport function exists([...variables]) {\n    const exists = variables.every(variable => variable != null)\n    return exists\n}\n\n\nexport function setLocalStorage(name, item) {\n    localStorage.setItem(name, JSON.stringify(item))\n}\n\n\nexport function getLocalStorage(item) {\n    return JSON.parse(localStorage.getItem(item))\n}\n\nexport function storageAvailable(type) { //source: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n    let storage\n    try {\n        storage = window[type]\n        let x = '__storage_test__'\n        storage.setItem(x, x)\n        storage.removeItem(x)\n        return true\n    } catch (e) {\n        return e instanceof DOMException && (\n                e.code === 22 ||\n                e.code === 1014 ||\n                e.name === 'QuotaExceededError' ||\n                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            (storage && storage.length !== 0)\n    }\n}\n\nexport function getPreferences() {\n    let widgetElements\n\n    if (storageAvailable('localStorage')) {\n        const preferences = getLocalStorage('preferences')\n        if (preferences) {\n            widgetElements = checker(preferences)\n        } else {\n            widgetElements = ['announcements-widget', 'study-progress', 'course-overview', 'schedule-widget']\n        }\n    } else {\n        widgetElements = ['announcements-widget', 'study-progress', 'course-overview', 'schedule-widget']\n    }\n\n    return widgetElements\n}\n\nexport function appendWidgets(widget) {\n    // Remove EJS templates\n    const domElements = ['announcements', 'study-progress', 'course-overview', 'schedule']\n    domElements.forEach(element => document.getElementById(element).remove())\n\n    // Adding widgets\n    widget.forEach(item => {\n        document.querySelector('#widget-container').append(document.createElement(item))\n\n        if (item === 'study-progress') {\n            WC_studyprogress()\n        }\n        if (item === 'course-overview') {\n            WC_courseoverview()\n        }\n        if (item === 'schedule-widget') {\n            WC_scheduleWidget()\n        }\n        if (item === 'announcements-widget') {\n            WC_announcementsWidget('dashboard')\n        }\n    })\n}\n\nexport function checker(preferences) {\n    const widgetElements = []\n\n    // Announcements\n    preferences.forEach(preference => {\n        preference.id = parseInt(preference.id)\n\n        if (preference.state && preference.id === 0) {\n            widgetElements.push('announcements-widget')\n        }\n        if (preference.state && preference.id === 1) {\n            widgetElements.push('study-progress')\n        }\n        if (preference.state && preference.id === 2) {\n            widgetElements.push('course-overview')\n        }\n        if (preference.state && preference.id === 3) {\n            widgetElements.push('schedule-widget')\n        }\n    })\n\n    return widgetElements\n}\n\nexport function cloneAndUpdateMenu() {\n    const secondaryLinks = document.querySelector('#menu-secondary-links')\n    const clonedLinks = [...secondaryLinks.cloneNode(true).children]\n    let selectedMenuItems = []\n\n    // LocalStorage\n    const preferences = getLocalStorage('menu-preferences')\n    if (preferences) {\n        preferences.forEach(preference => {\n            clonedLinks.forEach(link => {\n                const name = link.querySelector('p:first-of-type').textContent\n\n                if (preference.name === name && preference.state) {\n                    selectedMenuItems.push(link)\n                }\n            })\n        })\n\n        secondaryLinks.textContent = ''\n        selectedMenuItems.forEach(item => secondaryLinks.append(item))\n    }\n}","import * as utils from '../modules/utils.mjs'\n\nexport { init as WC_announcementsWidget }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\n*:focus {\n    outline: none;\n}\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\np {\n\tmargin: 0;\n}\n.announcements-container #announcement-legend {\n\tmargin-bottom: 20px;\n}\n.announcements-container #announcement-legend p {\n\tcolor: black;\n\tfont-size: 14px;\n\tdisplay: inline-block;\n    margin-right: 20px;\n    cursor: pointer;\n}\n.announcements-container #announcement-legend p:last-of-type {\n\tmargin-right: 0;\n}\n.announcements-container #announcement-legend p::before {\n\tcontent: \"\";\n\theight: 15px;\n\tmargin-bottom: -2px;\n\twidth: 15px;\n\tmargin-right: 10px;\n    display: inline-block;\n    cursor: pointer;\n}\n.announcements-container #announcement-legend p.Opleiding::before {\n\tbackground-color: #DC143C;\n}\n.announcements-container #announcement-legend p.Faculteit::before {\n\tbackground-color: #DCB614;\n}\n.announcements-container #announcement-legend p.HvA::before {\n\tbackground-color: #149EDC;\n}\n.announcements-container #announcement-legend p.Medezeggenschap::before {\n\tbackground-color: #14DC69;\n}\n.announcements-container #announcement-legend p.unactive {\n    color: #666666;\n}\n.announcements-container #announcement-legend p.unactive::before {\n    background-color: #DDDDDD;\n}\n.announcements-container a {\n\tmargin: 0 0 15px 0;\n\tdisplay: block;\n\tcolor: black;\n\ttext-decoration: none;\n}\n.announcements-container a.hide {\n    position: absolute;\n    left: -9999px;\n}\n.announcements-container a:hover {\n\tbackground-color: #F2F2F2;\n}\n.announcements-container a:focus {\n    background-color: #DDDDDD;\n}\n.announcements-container a:focus .read-indicator {\n    left: unset;\n}\n.announcements-container a:focus .read-indicator:hover {\n    background-color: #F2F2F2;\n    border: 1px solid #F2F2F2;\n}\n.announcements-container .announcement {\n\tmargin: 0;\n\tpadding: 5px 0 5px 10px;\n    border-left: 5px solid;\n    position: relative;\n}\n.announcements-container .announcement.Opleiding {\n\tborder-color: #DC143C;\n}\n.announcements-container .announcement.Faculteit {\n\tborder-color: #DCB614;\n}\n.announcements-container .announcement.HvA {\n\tborder-color: #149EDC;\n}\n.announcements-container .announcement.Medezeggenschap {\n\tborder-color: #14DC69;\n}\n.announcements-container .announcement p:first-of-type {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n.announcements-container .read .announcement p:first-of-type {\n    font-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n}\n.announcements-container .announcement p:last-of-type {\n\tcolor: #666666;\n\tfont-size: 14px;\n}    \n.announcements-container .announcement:hover .read-indicator {\n    left: unset;\n}\n.allAnnouncements {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n\talign-items: center;\n}\n.allAnnouncements:hover,\n.allAnnouncements:focus {\n        text-decoration: underline;\n}\n.allAnnouncements.hide {\n    position: absolute;\n    left: -9999px;\n}\n.allAnnouncements img {\n        height: 12px;\n        margin-left: 20px;\n}\n\n#announcement-legend:empty {\n    height: 150px;\n    width: 100%;\n    background: url(media/icons/loader.gif);\n    background-repeat: no-repeat;\n    background-position: center center;\n    background-size: 200px 200px;\n}\n.read-indicator {\n    position: absolute;\n    top: 50%;\n    right: 15px;\n    transform: translateY(-50%);\n    padding: 13px;\n    border: 1px solid transparent;\n    border-radius: 999px;\n    background-image: url(../media/icons/mark-as-read.svg);\n    background-repeat: no-repeat;\n    background-size: 20px;\n    background-position: center;\n    position: absolute;\n    left: -9999px;\n}\n.read-indicator:hover {\n    background-color: #DDDDDD;\n    border: 1px solid #DDDDDD;\n}\n.read-indicator:focus {\n    background-color: #F2F2F2;\n    border: 1px solid #F2F2F2;\n}\n.read-indicator.marked {\n    background-image: url(../media/icons/mark-as-unread.svg);\n}\n</style>\n<div id=\"announcements\"></div>\n<h2>Mededelingen</h2>\n<div class=\"announcements-container\">\n\t<div id=\"announcement-legend\"></div>\n</div>\n<a class=\"allAnnouncements\" href=\"/announcements/\" target=\"_self\">Alle mededelingen\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>`\n\nfunction init(pageName) {\n    class announcementList extends HTMLElement {\n        constructor() {\n            super()\n\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.getData()\n                .then(json => {\n                    const [announcements, categories] = json\n                    this.createLegenda(categories)\n                    if (pageName === 'dashboard') {\n                        announcements.splice(5, announcements.length)\n                    }\n                    this.appendAnnouncements(announcements)\n\n                    if (this.filteredCats && this.filteredCats.length > 0) {\n                        this.filteredCats.forEach(cat => {\n                            this.shadowRoot.querySelectorAll(`.announcements-container > a`).forEach(item => {\n                                if (item.classList.contains(cat)) {\n                                    item.classList.add('hide')\n                                }\n                            })\n\n\n                            const catFilter = this.shadowRoot.querySelector(`.${cat}`)\n                            catFilter.classList.add('unactive')\n                        })\n                    }\n                })\n\n            this.announcementContainer = this.shadowRoot.querySelector('.announcements-container')\n            this.announcementLegend = this.shadowRoot.querySelector('#announcement-legend')\n\n            if (utils.storageAvailable('localStorage')) {\n                const storedFilters = utils.getLocalStorage('filters')\n                this.filteredCats = storedFilters ? storedFilters : []\n            }\n\n            if (pageName === 'announcements-overview') {\n                this.shadowRoot.querySelector('.allAnnouncements').classList.add('hide')\n            }\n        }\n\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/announcementslist', options).then(res => res.json())\n        }\n\n        createLegenda(categories) {\n            categories.forEach(cat => {\n                this.announcementLegend.insertAdjacentHTML('beforeend', `<p class=\"${cat}\">${cat}</p>`)\n\n                const legendItem = this.shadowRoot.querySelector(`.${cat}`)\n                legendItem.addEventListener('click', e => this.filter(e.target))\n            })\n        }\n\n        appendAnnouncements(announcements) {\n            announcements.forEach(announcement => {\n                this.announcementContainer.insertAdjacentHTML('beforeend', `\n\t\t\t\t<a href=\"/announcements/${announcement.newsItemId}\" target=\"_self\" uid=\"${announcement.newsItemId}\" class=\"${announcement.tags[0]}\">\n\t\t\t\t\t<div class=\"announcement ${announcement.tags[0]}\" id=\"${announcement.newsItemId}\">\n                \t\t<p>${announcement.title}</p>\n                        <p>${announcement.publishDate} - ${announcement.tags[0]}</p>\n                        <span class=\"read-indicator\"></span>\n           \t\t\t</div>\n\t\t\t\t</a>`)\n\n                if (utils.storageAvailable('localStorage')) {\n                    const storedHistory = utils.getLocalStorage('read-history')\n                    this.readHistory = storedHistory ? storedHistory : []\n\n                    const link = this.announcementContainer.querySelector('a:last-of-type')\n\n                    if (this.readHistory.includes(link.getAttribute('uid'))) {\n                        link.classList.add('read')\n                    }\n                    link.addEventListener('click', () => this.store(link))\n                }\n            })\n        }\n\n        store(announcement) {\n            this.readHistory.push(announcement.getAttribute('uid'))\n            utils.setLocalStorage('read-history', this.readHistory)\n        }\n\n        filter(el) {\n            if (!this.filteredCats.includes(el.textContent)) {\n                this.filteredCats.push(el.textContent)\n            } else {\n                const index = this.filteredCats.indexOf(el.textContent)\n                this.filteredCats.splice(index, 1)\n            }\n\n            el.classList.toggle('unactive')\n\n            utils.setLocalStorage('filters', this.filteredCats)\n\n            const announcementsInFilteredCat = []\n            this.filteredCats.forEach(cat => {\n                const announcementsInCat = this.shadowRoot.querySelectorAll(`.announcements-container > a.${cat}`)\n                announcementsInFilteredCat.push(...announcementsInCat)\n            })\n\n            this.shadowRoot.querySelectorAll(`.announcements-container > a`).forEach(item => {\n                if (announcementsInFilteredCat.includes(item)) {\n                    item.classList.add('hide')\n                } else {\n                    item.classList.remove('hide')\n                }\n            })\n        }\n    }\n\n    window.customElements.define('announcements-widget', announcementList)\n}","export { init as WC_courseoverview }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\n\np {\n\tmargin: 0;\n}\n\n.navigator {\n    background-color: #DDDDDD;\n    padding: 5px 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color: #25167A;\n    font-size: 16px;\n}\n\n.navigator span  {\n    cursor: default;\n}\n\n.navigator img {\n    padding: 10px;\n}\n\n.navigator img:not(.disabled) {\n    cursor: pointer;\n}\n\n.navigator img.disabled {\n    pointer-events: none;\n    opacity: .5;\n}\n\n.course {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    grid-column-gap: 20px;\n    padding: 15px 20px;\n    border-bottom: 1px solid #DDDDDD;\n}\n\n.course p:first-of-type {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n    align-self: center;\n}\n\n.course ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    align-self: center;\n}\n\n.course ul li {\n    display: inline;\n}\n\n.course ul li:not(:last-of-type):after {\n    content: \", \";\n    white-space: pre;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n\n#course-overview:empty {\n    height: 150px;\n    width: 100%;\n    background: url(media/icons/loader.gif);\n    background-repeat: no-repeat;\n    background-position: center center;\n    background-size: 200px 200px;\n}\n</style>\n\n<h2>Vakkenoverzicht</h2>\n\n<div class=\"navigator\">\n    <img src=\"/media/icons/arrow-left.svg\" alt=\"arrow-left\"></img>\n    <span></span>\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</div>\n\n<div id=\"course-overview\"></div>\n\n<a target=\"_blank\" href=\"https://sis.hva.nl/\">Volledig overzicht\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class CourseOverview extends HTMLElement {\n        constructor() {\n            // Setup\n            super()\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            // Variables\n            this.courseContainer = this.shadowRoot.querySelector('#course-overview')\n            this.courseMoment = this.shadowRoot.querySelector('.navigator span')\n            this.arrowPrevious = this.shadowRoot.querySelector('.navigator img:first-of-type')\n            this.arrowNext = this.shadowRoot.querySelector('.navigator img:last-of-type')\n            this.yearIndex = 2\n            this.quarterIndex = 3\n\n            // Data\n            this.data = this.getData().then(json => {\n                this.navigateHandler()\n\n                const data = json[this.yearIndex].quarters[this.quarterIndex].courses\n                this.updateCourseOverview(data)\n\n                this.data = json\n            })\n\n            // EventListeners\n            this.arrowPrevious.addEventListener('click', () => this.navigate('previous'))\n            this.arrowNext.addEventListener('click', () => this.navigate('next'))\n        }\n\n        updateNavigator() {\n            this.courseMoment.textContent = `Jaar ${this.yearIndex + 1} - Blok ${this.quarterIndex + 1}`\n        }\n\n        updateCourseOverview(courses) {\n            this.courseContainer.textContent = \"\"\n            this.updateNavigator()\n\n            courses.forEach(course => {\n                const div = document.createElement('div')\n                div.classList.add('course')\n\n                const courseName = document.createElement('p')\n                courseName.textContent = course.course\n                div.append(courseName)\n\n                const list = document.createElement('ul')\n                course.lecturers.forEach(lecturer => {\n                    const teacher = document.createElement('li')\n                    lecturer === \"\" ? teacher.textContent = 'Geen specifieke docent' : teacher.textContent = lecturer\n                    list.append(teacher)\n                })\n                div.append(list)\n\n                this.courseContainer.append(div)\n            })\n        }\n\n        navigate(direction) {\n            if (direction === 'previous') {\n                if (this.quarterIndex > 0) {\n                    this.quarterIndex--\n                } else if (this.quarterIndex === 0 && this.yearIndex > 0) {\n                    this.quarterIndex = 3\n                    this.yearIndex--\n                }\n            }\n\n            if (direction === 'next') {\n                if (this.quarterIndex < 3) {\n                    this.quarterIndex++\n                } else if (this.quarterIndex === 3 && this.yearIndex < 3) {\n                    this.quarterIndex = 0\n                    this.yearIndex++\n                }\n            }\n\n            this.navigateHandler()\n\n            const data = this.data[this.yearIndex].quarters[this.quarterIndex].courses\n            this.updateCourseOverview(data)\n        }\n\n        navigateHandler() {\n            this.yearIndex === 0 && this.quarterIndex === 0 ?\n                this.arrowPrevious.classList.add('disabled') : this.arrowPrevious.classList.remove('disabled')\n\n            this.yearIndex === 3 && this.quarterIndex === 3 ?\n                this.arrowNext.classList.add('disabled') : this.arrowNext.classList.remove('disabled')\n        }\n\n        // Helpers\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/courseoverview', options).then(res => res.json())\n        }\n    }\n\n    customElements.define('course-overview', CourseOverview)\n}","export { init as WC_scheduleWidget }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n\tfont-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n\tfont-weight: lighter;\n\tline-height: 1.1;\n}\n\np {\n\tmargin: 0;\n}\n\n.navigator {\n    background-color: #DDDDDD;\n    padding: 5px 10px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    color: #25167A;\n    font-size: 16px;\n}\n\n.navigator span  {\n    cursor: default;\n}\n\n.navigator img {\n    padding: 10px;\n}\n\n.navigator img:not(.disabled) {\n    cursor: pointer;\n}\n\n.navigator img.disabled {\n    pointer-events: none;\n    opacity: .5;\n}\n\n.schedule-course {\n    display: grid;\n    grid-template-columns: auto 1fr;\n    grid-column-gap: 20px;\n    grid-row-gap: 5px;\n    padding: 15px 20px;\n    border-bottom: 1px solid #DDDDDD;\n}\n\n.schedule-course p:first-of-type,\n.schedule-course p:nth-of-type(3) {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n\na {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\na:hover,\na:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\na img {\n    height: 12px;\n    margin-left: 20px;\n}\n\n#schedule-container:empty {\n    height: 150px;\n    width: 100%;\n    background: url(media/icons/loader.gif);\n    background-repeat: no-repeat;\n    background-position: center center;\n    background-size: 200px 200px;\n}\n</style>\n<h2>Dagrooster</h2>\n<div class=\"navigator\">\n\t<img src=\"/media/icons/arrow-left.svg\" alt=\"arrow-left\" class=\"disabled\"></img>\n\t<span></span>\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</div>\n<div id=\"schedules-container\"></div>\n<a target=\"_blank\" href=\"https://rooster.hva.nl/schedule\">Volledig rooster\n\t<img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n`\n\nfunction init() {\n    class schedule extends HTMLElement {\n        constructor() {\n            super()\n\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.data = this.getData()\n                .then(json => {\n                    this.updateSchedule(json[0])\n                    this.data = json\n                })\n\n            this.navigator = this.shadowRoot.querySelector('.navigator')\n            this.arrowPrevious = this.navigator.querySelector('img:first-of-type')\n            this.arrowNext = this.navigator.querySelector('img:last-of-type')\n\n            this.arrowNext.addEventListener('click', () => this.navigate('next'))\n            this.arrowPrevious.addEventListener('click', () => this.navigate('previous'))\n            this.index = 0\n        }\n\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/schedule', options).then(res => res.json())\n        }\n\n        updateSchedule(data) {\n            const schedulesContainer = this.shadowRoot.getElementById('schedules-container')\n            schedulesContainer.textContent = \"\"\n\n            this.navigator.querySelector('span').textContent = `${data.day} - ${data.month} - ${data.year}`\n\n            data.schedules.forEach(schedule => {\n                const classRoom = schedule._embedded ? schedule._embedded.rooms[0].abbreviation : \"Geen lokaal\"\n\n                const div = document.createElement('div')\n                div.classList.add('schedule-course')\n                schedulesContainer.appendChild(div)\n\n                const time = document.createElement('p')\n                time.textContent = `${schedule.startDateTime.time} - ${schedule.endDateTime.time}`\n                div.appendChild(time)\n\n                const name = document.createElement('p')\n                name.textContent = schedule._links.courses[0].title\n                div.appendChild(name)\n\n                const room = document.createElement('p')\n                room.textContent = classRoom\n                div.appendChild(room)\n\n                const teacher = document.createElement('p')\n                teacher.textContent = schedule._links.lecturers[0].title\n                div.appendChild(teacher)\n            })\n        }\n\n        navigate(direction) {\n            direction === 'previous' ? this.index-- : this.index++\n\n            this.index === 0 ? this.arrowPrevious.classList.add('disabled') : this.arrowPrevious.classList.remove('disabled')\n            this.index === 4 ? this.arrowNext.classList.add('disabled') : this.arrowNext.classList.remove('disabled')\n\n            this.updateSchedule(this.data[this.index])\n        }\n    }\n\n    window.customElements.define('schedule-widget', schedule)\n}","export { init as WC_studyprogress }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\nh2 {\n    font-size: 24px;\n    color: #25167A;\n    text-transform: uppercase;\n    padding-bottom: 8px;\n    border-bottom: 1px solid #DDDDDD;\n    margin: 0 0 15px 0;\n    font-family: \"OpenSans-Regular\", sans-serif, Arial, Helvetica;\n    font-weight: lighter;\n    line-height: 1.1;\n}\n\np {\n    margin: 0;\n}\n\n#recent-results div {\n    display: grid;\n    grid-template-columns: auto 1fr auto;\n    grid-template-rows: 1fr auto;\n}\n\n#recent-results div:not(:last-of-type) {\n    margin-bottom: 15px;\n}\n\n#recent-results span {\n    display: block;\n    grid-column: 1 / 2;\n    grid-row: 1 / 3;\n    width: 5px;\n    height: 100%;\n}\n\nspan.success {\n    background-color: #25167A;\n}\n\nspan.failed {\n    background-color: #DDDDDD;\n}\n\n#recent-results p:nth-of-type(1) {\n    grid-column: 2 / 3;\n    padding: 4px 0px 0px 10px;\n}\n\n#recent-results p:nth-of-type(2) {\n    grid-row: 1 / 3;\n    grid-column: 3 / 4;\n    align-self: center;\n}\n\n#recent-results p:nth-of-type(3) {\n    padding: 0px 0px 4px 10px;\n    font-size: 14px;\n    color: #666666;\n}\n\n#recent-results p:nth-of-type(1),\n#recent-results p:nth-of-type(2) {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n\n}\n\n#recent-progress {\n    margin-top: 30px;\n}\n\n#recent-progress div {\n    display: grid;\n    grid-template-columns: auto 1fr auto;\n}\n\n#recent-progress div span {\n        display: block;\n        width: 5px;\n}\n\n#recent-progress p {\n    padding: 5px 0px;\n}\n\n#recent-progress p:first-of-type {\n    padding-left: 10px;\n}\n\n#recent-progress .current-year {\n    background-color: #DDDDDD;\n}\n\n#recent-progress .current-year span {\n    background-color: #25167A;\n}\n\n#recent-progress .current-year p {\n    font-family: \"OpenSans-Bold\", sans-serif, Arial, Helvetica;\n}\n\n#recent-progress .current-year p:last-of-type {\n    padding-right: 10px;\n}\n\n#link-container {\n    display: flex;\n    justify-content: space-between;\n}\n\n#link-container a {\n    margin-top: 30px;\n    text-decoration: none;\n    color: #25167A;\n    display: flex;\n    align-items: center;\n}\n\n#link-container a:hover,\n#link-container a:focus {\n    text-decoration: underline;\n    outline: none;\n}\n\n#link-container a img {\n    height: 12px;\n    margin-left: 20px;\n}\n\n@media only screen and (max-width: 450px) {\n    #link-container {\n        flex-direction: column;\n    }\n\n    #link-container a:last-of-type {\n        margin-top: 10px;\n    }\n}\n\n#recent-results:empty {\n    height: 150px;\n    width: 100%;\n    background: url(media/icons/loader.gif);\n    background-repeat: no-repeat;\n    background-position: center center;\n    background-size: 200px 200px;\n}\n</style>\n\n<h2>Studieresultaten en -voortgang</h2>\n\n<div id=\"recent-results\"></div>\n<div id=\"recent-progress\"></div>\n\n<div id=\"link-container\">\n<a target=\"_blank\" href=\"https://sis.hva.nl:8011/psc/S2PRD/EMPLOYEE/SA/c/SNS_MENU_FLD.SNS_SS_STD_RES_FL.GBL\">Jouw resultaten\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n\n<a target=\"_blank\" href=\"https://sis.hva.nl:8011/psc/S2PRD/EMPLOYEE/SA/c/SNS_MENU_FLD.SNS_SS_FLD_ADB.GBL\">Jouw studievoortgang\n    <img src=\"/media/icons/arrow-right.svg\" alt=\"arrow-right\"></img>\n</a>\n</div>\n`\n\nfunction init() {\n    class StudyProgress extends HTMLElement {\n        constructor() {\n            // Setup\n            super()\n            this.attachShadow({ mode: 'open' })\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n\n            this.getData().then(json => {\n                const [results, progress] = json\n\n                this.resultComponent(results)\n                this.progressComponent(progress)\n            })\n\n            this.resultsContainer = this.shadowRoot.querySelector('#recent-results')\n            this.progressContainer = this.shadowRoot.querySelector('#recent-progress')\n        }\n\n        progressComponent(results) {\n            results.forEach(result => {\n                const div = document.createElement('div')\n                if (result.currentYear) {\n                    div.classList.add('current-year')\n                }\n\n                const template = `\n                <span></span>\n                <p>Leerjaar ${result.studyYear}</p>\n                <p>${result.studypoints.achieved}/${result.studypoints.available} studiepunten</p>`\n\n                // InsertAdjacentHtml\n                // Template engine uitzoeken voor Webcomponents\n\n                div.innerHTML = template\n                this.progressContainer.append(div)\n            })\n        }\n\n\n        resultComponent(results) {\n            results.forEach(result => {\n                // Parent container\n                const div = document.createElement('div')\n\n                let indicator\n                if (typeof result.grade === 'number' && result.grade >= 5.5 || result.grade === 'V') {\n                    indicator = `<span class=\"success\"></span>`\n                } else if (typeof result.grade === 'number' && result.grade < 5.5 || result.grade === '-' || result.grade === 'GR') {\n                    indicator = `<span class=\"failed\"></span>`\n                }\n\n                const template = `\n                ${indicator}\n                <p>${result._links.course.title}</p>\n                <p>${result.grade}</p>\n                <p>${result.fullDate}</p>\n                `\n\n                div.innerHTML = template\n                this.resultsContainer.append(div)\n            })\n        }\n\n        // Helpers\n        getData() {\n            const options = {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            }\n\n            return fetch('/studyprogress', options).then(res => res.json())\n        }\n    }\n\n    customElements.define('study-progress', StudyProgress)\n}","import * as utils from '../modules/utils.mjs'\n\nexport { template as WC_urgentAnnouncement }\n\nconst template = document.createElement('template')\ntemplate.innerHTML = `\n<style>\n    div {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        padding: 16px;\n        background-color: #ECE7FA;\n        position: sticky;\n        top: 0;\n    }\n\n    div.hide {\n        position: absolute;\n        left: -9999px;\n    }\n\n    p {\n        margin: 0;\n        padding-right: 10px;\n    }\n\n    @media only screen and (max-width: 768px) {\n        div {\n            top: 60px;\n        }\n    }\n\n    img {\n        cursor: pointer;\n    }\n</style>\n<div class=\"hide\">\n    <p></p>\n    <img src=\"./media/icons/notification-exit.svg\" alt=\"hide notification\">\n</div>`\n\n\n\nclass urgentAnnouncement extends HTMLElement {\n\n    constructor() {\n        super()\n\n        this.attachShadow({ mode: 'open' })\n        this.shadowRoot.appendChild(template.content.cloneNode(true))\n        this.shadowRoot.querySelector('p').textContent = this.getAttribute('message')\n        this.shadowRoot.querySelector('img').addEventListener('click', () => {\n            this.hide()\n            this.store()\n        })\n    }\n\n    static get observedAttributes() {\n        return ['uid']\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue != newValue && newValue != \"\") {\n            const uid = this.getAttribute('uid')\n            if (utils.storageAvailable('localStorage')) {\n                const storedHistory = utils.getLocalStorage('read-history')\n                if (storedHistory) {\n                    if (!storedHistory.includes(uid)) {\n                        this.updateContent()\n                        this.show()\n                    }\n                } else {\n                    this.updateContent()\n                    this.show()\n                }\n            }\n        }\n    }\n\n    updateContent() {\n        this.shadowRoot.querySelector('p').textContent = this.getAttribute('message')\n    }\n\n    show() {\n        this.shadowRoot.querySelector('div').classList.remove('hide')\n        document.querySelector('main').classList.add('showsNotification')\n    }\n\n    hide() {\n        this.shadowRoot.querySelector('div').classList.add('hide')\n        document.querySelector('main').classList.remove('showsNotification')\n    }\n\n    store() {\n        if (utils.storageAvailable('localStorage')) {\n            const storedHistory = utils.getLocalStorage('read-history')\n            const readHistory = storedHistory ? storedHistory : []\n\n            readHistory.push(this.getAttribute('uid'))\n            utils.setLocalStorage('read-history', readHistory)\n        }\n    }\n}\n\nwindow.customElements.define('urgent-announcement', urgentAnnouncement)"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc29ydGFibGVqcy9Tb3J0YWJsZS5qcyIsInNyYy9qcy9pbmRleC5qcyIsInNyYy9qcy9tb2R1bGVzL25vdGlmeS5tanMiLCJzcmMvanMvbW9kdWxlcy9wcmVmZXJlbmNlcy9kYXNoYm9hcmQubWpzIiwic3JjL2pzL21vZHVsZXMvcHJlZmVyZW5jZXMvbWVudS5tanMiLCJzcmMvanMvbW9kdWxlcy9zZWFyY2gubWpzIiwic3JjL2pzL21vZHVsZXMvdW5yZWFkQW5ub3VuY2VtZW50cy5tanMiLCJzcmMvanMvbW9kdWxlcy91dGlscy5tanMiLCJzcmMvanMvd2ViLWNvbXBvbmVudHMvYW5ub3VuY2VtZW50cy5tanMiLCJzcmMvanMvd2ViLWNvbXBvbmVudHMvY291cnNlLW92ZXJ2aWV3Lm1qcyIsInNyYy9qcy93ZWItY29tcG9uZW50cy9zY2hlZHVsZS5tanMiLCJzcmMvanMvd2ViLWNvbXBvbmVudHMvc3R1ZHktcHJvZ3Jlc3MubWpzIiwic3JjL2pzL3dlYi1jb21wb25lbnRzL3VyZ2VudC1hbm5vdW5jZW1lbnQubWpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0FoQjRCLFc7O0FBNkRqQyxNQUFNLENBQUMsY0FBUCxDQUFzQixNQUF0QixDQUE2QixxQkFBN0IsRUFBb0Qsa0JBQXBEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyoqIVxuICogU29ydGFibGUgMS4xMC4yXG4gKiBAYXV0aG9yXHRSdWJhWGEgICA8dHJhc2hAcnViYXhhLm9yZz5cbiAqIEBhdXRob3JcdG93ZW5tICAgIDxvd2VuMjMzNTVAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuU29ydGFibGUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICAgIHZhciBrZXksIGk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gXCIxLjEwLjJcIjtcblxuICBmdW5jdGlvbiB1c2VyQWdlbnQocGF0dGVybikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgICByZXR1cm4gISFcbiAgICAgIC8qQF9fUFVSRV9fKi9cbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gocGF0dGVybik7XG4gICAgfVxuICB9XG5cbiAgdmFyIElFMTFPckxlc3MgPSB1c2VyQWdlbnQoLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llfGllbW9iaWxlfFdpbmRvd3MgUGhvbmUpL2kpO1xuICB2YXIgRWRnZSA9IHVzZXJBZ2VudCgvRWRnZS9pKTtcbiAgdmFyIEZpcmVGb3ggPSB1c2VyQWdlbnQoL2ZpcmVmb3gvaSk7XG4gIHZhciBTYWZhcmkgPSB1c2VyQWdlbnQoL3NhZmFyaS9pKSAmJiAhdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgIXVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcbiAgdmFyIElPUyA9IHVzZXJBZ2VudCgvaVAoYWR8b2R8aG9uZSkvaSk7XG4gIHZhciBDaHJvbWVGb3JBbmRyb2lkID0gdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgdXNlckFnZW50KC9hbmRyb2lkL2kpO1xuXG4gIHZhciBjYXB0dXJlTW9kZSA9IHtcbiAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIG9uKGVsLCBldmVudCwgZm4pIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKGVsLCBldmVudCwgZm4pIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hlcyhcbiAgLyoqSFRNTEVsZW1lbnQqL1xuICBlbCxcbiAgLyoqU3RyaW5nKi9cbiAgc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG4gICAgc2VsZWN0b3JbMF0gPT09ICc+JyAmJiAoc2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHJpbmcoMSkpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZWwubWF0Y2hlcykge1xuICAgICAgICAgIHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBlbC5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudE9ySG9zdChlbCkge1xuICAgIHJldHVybiBlbC5ob3N0ICYmIGVsICE9PSBkb2N1bWVudCAmJiBlbC5ob3N0Lm5vZGVUeXBlID8gZWwuaG9zdCA6IGVsLnBhcmVudE5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZXN0KFxuICAvKipIVE1MRWxlbWVudCovXG4gIGVsLFxuICAvKipTdHJpbmcqL1xuICBzZWxlY3RvcixcbiAgLyoqSFRNTEVsZW1lbnQqL1xuICBjdHgsIGluY2x1ZGVDVFgpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGN0eCA9IGN0eCB8fCBkb2N1bWVudDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiAoc2VsZWN0b3JbMF0gPT09ICc+JyA/IGVsLnBhcmVudE5vZGUgPT09IGN0eCAmJiBtYXRjaGVzKGVsLCBzZWxlY3RvcikgOiBtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHx8IGluY2x1ZGVDVFggJiYgZWwgPT09IGN0eCkge1xuICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbCA9PT0gY3R4KSBicmVhaztcbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgICAgfSB3aGlsZSAoZWwgPSBnZXRQYXJlbnRPckhvc3QoZWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBSX1NQQUNFID0gL1xccysvZztcblxuICBmdW5jdGlvbiB0b2dnbGVDbGFzcyhlbCwgbmFtZSwgc3RhdGUpIHtcbiAgICBpZiAoZWwgJiYgbmFtZSkge1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICBlbC5jbGFzc0xpc3Rbc3RhdGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKFJfU1BBQ0UsICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSAoY2xhc3NOYW1lICsgKHN0YXRlID8gJyAnICsgbmFtZSA6ICcnKSkucmVwbGFjZShSX1NQQUNFLCAnICcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNzcyhlbCwgcHJvcCwgdmFsKSB7XG4gICAgdmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgIHZhbCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICB2YWwgPSBlbC5jdXJyZW50U3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEocHJvcCBpbiBzdHlsZSkgJiYgcHJvcC5pbmRleE9mKCd3ZWJraXQnKSA9PT0gLTEpIHtcbiAgICAgICAgICBwcm9wID0gJy13ZWJraXQtJyArIHByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZVtwcm9wXSA9IHZhbCArICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICcnIDogJ3B4Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWF0cml4KGVsLCBzZWxmT25seSkge1xuICAgIHZhciBhcHBsaWVkVHJhbnNmb3JtcyA9ICcnO1xuXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFwcGxpZWRUcmFuc2Zvcm1zID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGNzcyhlbCwgJ3RyYW5zZm9ybScpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBhcHBsaWVkVHJhbnNmb3JtcyA9IHRyYW5zZm9ybSArICcgJyArIGFwcGxpZWRUcmFuc2Zvcm1zO1xuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgICAgfSB3aGlsZSAoIXNlbGZPbmx5ICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0cml4Rm4gPSB3aW5kb3cuRE9NTWF0cml4IHx8IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggfHwgd2luZG93LkNTU01hdHJpeCB8fCB3aW5kb3cuTVNDU1NNYXRyaXg7XG4gICAgLypqc2hpbnQgLVcwNTYgKi9cblxuICAgIHJldHVybiBtYXRyaXhGbiAmJiBuZXcgbWF0cml4Rm4oYXBwbGllZFRyYW5zZm9ybXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZChjdHgsIHRhZ05hbWUsIGl0ZXJhdG9yKSB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgdmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBpdGVyYXRvcihsaXN0W2ldLCBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkge1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudDtcblxuICAgIGlmIChzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgXCJib3VuZGluZyBjbGllbnQgcmVjdFwiIG9mIGdpdmVuIGVsZW1lbnRcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbGVtZW50IHdob3NlIGJvdW5kaW5nQ2xpZW50UmVjdCBpcyB3YW50ZWRcclxuICAgKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIGJsb2NrIG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWluZXJcclxuICAgKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSByZWxhdGl2ZSBwYXJlbnQgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaWVuclxyXG4gICAqIEBwYXJhbSAge1tCb29sZWFuXX0gdW5kb1NjYWxlICAgICAgICAgICAgICAgICAgV2hldGhlciB0aGUgY29udGFpbmVyJ3Mgc2NhbGUoKSBzaG91bGQgYmUgdW5kb25lXHJcbiAgICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgICAgICAgICBUaGUgcGFyZW50IHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYm91bmRpbmdDbGllbnRSZWN0IG9mIGVsLCB3aXRoIHNwZWNpZmllZCBhZGp1c3RtZW50c1xyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UmVjdChlbCwgcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jaywgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCwgdW5kb1NjYWxlLCBjb250YWluZXIpIHtcbiAgICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbCAhPT0gd2luZG93KSByZXR1cm47XG4gICAgdmFyIGVsUmVjdCwgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBoZWlnaHQsIHdpZHRoO1xuXG4gICAgaWYgKGVsICE9PSB3aW5kb3cgJiYgZWwgIT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgICAgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0b3AgPSBlbFJlY3QudG9wO1xuICAgICAgbGVmdCA9IGVsUmVjdC5sZWZ0O1xuICAgICAgYm90dG9tID0gZWxSZWN0LmJvdHRvbTtcbiAgICAgIHJpZ2h0ID0gZWxSZWN0LnJpZ2h0O1xuICAgICAgaGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcbiAgICAgIHdpZHRoID0gZWxSZWN0LndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAwO1xuICAgICAgbGVmdCA9IDA7XG4gICAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoKHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCkgJiYgZWwgIT09IHdpbmRvdykge1xuICAgICAgLy8gQWRqdXN0IGZvciB0cmFuc2xhdGUoKVxuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsLnBhcmVudE5vZGU7IC8vIHNvbHZlcyAjMTEyMyAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc5NTM4MDYvNjA4ODMxMilcbiAgICAgIC8vIE5vdCBuZWVkZWQgb24gPD0gSUUxMVxuXG4gICAgICBpZiAoIUlFMTFPckxlc3MpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoY3NzKGNvbnRhaW5lciwgJ3RyYW5zZm9ybScpICE9PSAnbm9uZScgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAmJiBjc3MoY29udGFpbmVyLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gU2V0IHJlbGF0aXZlIHRvIGVkZ2VzIG9mIHBhZGRpbmcgYm94IG9mIGNvbnRhaW5lclxuXG4gICAgICAgICAgICB0b3AgLT0gY29udGFpbmVyUmVjdC50b3AgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLXRvcC13aWR0aCcpKTtcbiAgICAgICAgICAgIGxlZnQgLT0gY29udGFpbmVyUmVjdC5sZWZ0ICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci1sZWZ0LXdpZHRoJykpO1xuICAgICAgICAgICAgYm90dG9tID0gdG9wICsgZWxSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIGVsUmVjdC53aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICAgICAgfSB3aGlsZSAoY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1bmRvU2NhbGUgJiYgZWwgIT09IHdpbmRvdykge1xuICAgICAgLy8gQWRqdXN0IGZvciBzY2FsZSgpXG4gICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcbiAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQ7XG5cbiAgICAgIGlmIChlbE1hdHJpeCkge1xuICAgICAgICB0b3AgLz0gc2NhbGVZO1xuICAgICAgICBsZWZ0IC89IHNjYWxlWDtcbiAgICAgICAgd2lkdGggLz0gc2NhbGVYO1xuICAgICAgICBoZWlnaHQgLz0gc2NhbGVZO1xuICAgICAgICBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHRvcCxcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYSBzaWRlIG9mIGFuIGVsZW1lbnQgaXMgc2Nyb2xsZWQgcGFzdCBhIHNpZGUgb2YgaXRzIHBhcmVudHNcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gIGVsICAgICAgICAgICBUaGUgZWxlbWVudCB3aG8ncyBzaWRlIGJlaW5nIHNjcm9sbGVkIG91dCBvZiB2aWV3IGlzIGluIHF1ZXN0aW9uXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBlbFNpZGUgICAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBwYXJlbnRTaWRlICAgU2lkZSBvZiB0aGUgcGFyZW50IGluIHF1ZXN0aW9uICgndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnYm90dG9tJylcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICAgICAgICAgICAgICBUaGUgcGFyZW50IHNjcm9sbCBlbGVtZW50IHRoYXQgdGhlIGVsJ3Mgc2lkZSBpcyBzY3JvbGxlZCBwYXN0LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vIHN1Y2ggZWxlbWVudFxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTY3JvbGxlZFBhc3QoZWwsIGVsU2lkZSwgcGFyZW50U2lkZSkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgdHJ1ZSksXG4gICAgICAgIGVsU2lkZVZhbCA9IGdldFJlY3QoZWwpW2VsU2lkZV07XG4gICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudFNpZGVWYWwgPSBnZXRSZWN0KHBhcmVudClbcGFyZW50U2lkZV0sXG4gICAgICAgICAgdmlzaWJsZSA9IHZvaWQgMDtcblxuICAgICAgaWYgKHBhcmVudFNpZGUgPT09ICd0b3AnIHx8IHBhcmVudFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICB2aXNpYmxlID0gZWxTaWRlVmFsID49IHBhcmVudFNpZGVWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpYmxlID0gZWxTaWRlVmFsIDw9IHBhcmVudFNpZGVWYWw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaWJsZSkgcmV0dXJuIHBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgPT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkgYnJlYWs7XG4gICAgICBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChwYXJlbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0cyBudGggY2hpbGQgb2YgZWwsIGlnbm9yaW5nIGhpZGRlbiBjaGlsZHJlbiwgc29ydGFibGUncyBlbGVtZW50cyAoZG9lcyBub3QgaWdub3JlIGNsb25lIGlmIGl0J3MgdmlzaWJsZSlcclxuICAgKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xyXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBUaGUgcGFyZW50IGVsZW1lbnRcclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGNoaWxkTnVtICAgICAgVGhlIGluZGV4IG9mIHRoZSBjaGlsZFxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBjaGlsZCBhdCBpbmRleCBjaGlsZE51bSwgb3IgbnVsbCBpZiBub3QgZm91bmRcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldENoaWxkKGVsLCBjaGlsZE51bSwgb3B0aW9ucykge1xuICAgIHZhciBjdXJyZW50Q2hpbGQgPSAwLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblxuICAgIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5naG9zdCAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZHJhZ2dlZCAmJiBjbG9zZXN0KGNoaWxkcmVuW2ldLCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgICBpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRDaGlsZCsrO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgZWwsIGlnbm9yaW5nIGdob3N0RWwgb3IgaW52aXNpYmxlIGVsZW1lbnRzIChjbG9uZXMpXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFBhcmVudCBlbGVtZW50XHJcbiAgICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yICAgIEFueSBvdGhlciBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBpZ25vcmVkXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBsYXN0IGNoaWxkLCBpZ25vcmluZyBnaG9zdEVsXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBsYXN0Q2hpbGQoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIGxhc3QgPSBlbC5sYXN0RWxlbWVudENoaWxkO1xuXG4gICAgd2hpbGUgKGxhc3QgJiYgKGxhc3QgPT09IFNvcnRhYmxlLmdob3N0IHx8IGNzcyhsYXN0LCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2VsZWN0b3IgJiYgIW1hdGNoZXMobGFzdCwgc2VsZWN0b3IpKSkge1xuICAgICAgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdCB8fCBudWxsO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnQgZm9yIGEgc2VsZWN0ZWQgc2V0IG9mXHJcbiAgICogZWxlbWVudHNcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcclxuICAgKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3JcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbmRleChlbCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgaWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cblxuICAgIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgIGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnICYmIGVsICE9PSBTb3J0YWJsZS5jbG9uZSAmJiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc2Nyb2xsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgYWRkZWQgd2l0aCBhbGwgdGhlIHNjcm9sbCBvZmZzZXRzIG9mIHBhcmVudCBlbGVtZW50cy5cclxuICAgKiBUaGUgdmFsdWUgaXMgcmV0dXJuZWQgaW4gcmVhbCBwaXhlbHMuXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIE9mZnNldHMgaW4gdGhlIGZvcm1hdCBvZiBbbGVmdCwgdG9wXVxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZWwpIHtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IDAsXG4gICAgICAgIG9mZnNldFRvcCA9IDAsXG4gICAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChlbCksXG4gICAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeC5hLFxuICAgICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXguZDtcbiAgICAgICAgb2Zmc2V0TGVmdCArPSBlbC5zY3JvbGxMZWZ0ICogc2NhbGVYO1xuICAgICAgICBvZmZzZXRUb3AgKz0gZWwuc2Nyb2xsVG9wICogc2NhbGVZO1xuICAgICAgfSB3aGlsZSAoZWwgIT09IHdpblNjcm9sbGVyICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW29mZnNldExlZnQsIG9mZnNldFRvcF07XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG9iamVjdCB3aXRoaW4gdGhlIGdpdmVuIGFycmF5XHJcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyciAgIEFycmF5IHRoYXQgbWF5IG9yIG1heSBub3QgaG9sZCB0aGUgb2JqZWN0XHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmogIEFuIG9iamVjdCB0aGF0IGhhcyBhIGtleS12YWx1ZSBwYWlyIHVuaXF1ZSB0byBhbmQgaWRlbnRpY2FsIHRvIGEga2V5LXZhbHVlIHBhaXIgaW4gdGhlIG9iamVjdCB5b3Ugd2FudCB0byBmaW5kXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgIFRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSwgb3IgLTFcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyLCBvYmopIHtcbiAgICBmb3IgKHZhciBpIGluIGFycikge1xuICAgICAgaWYgKCFhcnIuaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSA9PT0gYXJyW2ldW2tleV0pIHJldHVybiBOdW1iZXIoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIGluY2x1ZGVTZWxmKSB7XG4gICAgLy8gc2tpcCB0byB3aW5kb3dcbiAgICBpZiAoIWVsIHx8ICFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgdmFyIGVsZW0gPSBlbDtcbiAgICB2YXIgZ290U2VsZiA9IGZhbHNlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBnZXQgZWxlbSBjc3MgaWYgaXQgaXNuJ3QgZXZlbiBvdmVyZmxvd2luZyBpbiB0aGUgZmlyc3QgcGxhY2UgKHBlcmZvcm1hbmNlKVxuICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGVsZW1DU1MgPSBjc3MoZWxlbSk7XG5cbiAgICAgICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoICYmIChlbGVtQ1NTLm92ZXJmbG93WCA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ3Njcm9sbCcpIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQgJiYgKGVsZW1DU1Mub3ZlcmZsb3dZID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WSA9PSAnc2Nyb2xsJykpIHtcbiAgICAgICAgICBpZiAoIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHx8IGVsZW0gPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgaWYgKGdvdFNlbGYgfHwgaW5jbHVkZVNlbGYpIHJldHVybiBlbGVtO1xuICAgICAgICAgIGdvdFNlbGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICB9IHdoaWxlIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKTtcblxuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQoZHN0LCBzcmMpIHtcbiAgICBpZiAoZHN0ICYmIHNyYykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVjdEVxdWFsKHJlY3QxLCByZWN0Mikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHJlY3QxLnRvcCkgPT09IE1hdGgucm91bmQocmVjdDIudG9wKSAmJiBNYXRoLnJvdW5kKHJlY3QxLmxlZnQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmxlZnQpICYmIE1hdGgucm91bmQocmVjdDEuaGVpZ2h0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5oZWlnaHQpICYmIE1hdGgucm91bmQocmVjdDEud2lkdGgpID09PSBNYXRoLnJvdW5kKHJlY3QyLndpZHRoKTtcbiAgfVxuXG4gIHZhciBfdGhyb3R0bGVUaW1lb3V0O1xuXG4gIGZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aHJvdHRsZVRpbWVvdXQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChfdGhpcywgYXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2suYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgIH0sIG1zKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsVGhyb3R0bGUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KF90aHJvdHRsZVRpbWVvdXQpO1xuICAgIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxCeShlbCwgeCwgeSkge1xuICAgIGVsLnNjcm9sbExlZnQgKz0geDtcbiAgICBlbC5zY3JvbGxUb3AgKz0geTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lKGVsKSB7XG4gICAgdmFyIFBvbHltZXIgPSB3aW5kb3cuUG9seW1lcjtcbiAgICB2YXIgJCA9IHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvO1xuXG4gICAgaWYgKFBvbHltZXIgJiYgUG9seW1lci5kb20pIHtcbiAgICAgIHJldHVybiBQb2x5bWVyLmRvbShlbCkuY2xvbmVOb2RlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAoJCkge1xuICAgICAgcmV0dXJuICQoZWwpLmNsb25lKHRydWUpWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFJlY3QoZWwsIHJlY3QpIHtcbiAgICBjc3MoZWwsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgIGNzcyhlbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgICBjc3MoZWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgICBjc3MoZWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgIGNzcyhlbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2V0UmVjdChlbCkge1xuICAgIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJycpO1xuICAgIGNzcyhlbCwgJ3RvcCcsICcnKTtcbiAgICBjc3MoZWwsICdsZWZ0JywgJycpO1xuICAgIGNzcyhlbCwgJ3dpZHRoJywgJycpO1xuICAgIGNzcyhlbCwgJ2hlaWdodCcsICcnKTtcbiAgfVxuXG4gIHZhciBleHBhbmRvID0gJ1NvcnRhYmxlJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpIHtcbiAgICB2YXIgYW5pbWF0aW9uU3RhdGVzID0gW10sXG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHR1cmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gY2FwdHVyZUFuaW1hdGlvblN0YXRlKCkge1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSByZXR1cm47XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5jaGlsZHJlbik7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgaWYgKGNzcyhjaGlsZCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IGNoaWxkID09PSBTb3J0YWJsZS5naG9zdCkgcmV0dXJuO1xuICAgICAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldDogY2hpbGQsXG4gICAgICAgICAgICByZWN0OiBnZXRSZWN0KGNoaWxkKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZyb21SZWN0ID0gX29iamVjdFNwcmVhZCh7fSwgYW5pbWF0aW9uU3RhdGVzW2FuaW1hdGlvblN0YXRlcy5sZW5ndGggLSAxXS5yZWN0KTsgLy8gSWYgYW5pbWF0aW5nOiBjb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuXG5cbiAgICAgICAgICBpZiAoY2hpbGQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRNYXRyaXggPSBtYXRyaXgoY2hpbGQsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRNYXRyaXgpIHtcbiAgICAgICAgICAgICAgZnJvbVJlY3QudG9wIC09IGNoaWxkTWF0cml4LmY7XG4gICAgICAgICAgICAgIGZyb21SZWN0LmxlZnQgLT0gY2hpbGRNYXRyaXguZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZC5mcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gYWRkQW5pbWF0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiByZW1vdmVBbmltYXRpb25TdGF0ZSh0YXJnZXQpIHtcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLnNwbGljZShpbmRleE9mT2JqZWN0KGFuaW1hdGlvblN0YXRlcywge1xuICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgIH0pLCAxKTtcbiAgICAgIH0sXG4gICAgICBhbmltYXRlQWxsOiBmdW5jdGlvbiBhbmltYXRlQWxsKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuaW1hdGluZyA9IGZhbHNlLFxuICAgICAgICAgICAgYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHZhciB0aW1lID0gMCxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LFxuICAgICAgICAgICAgICBmcm9tUmVjdCA9IHRhcmdldC5mcm9tUmVjdCxcbiAgICAgICAgICAgICAgdG9SZWN0ID0gZ2V0UmVjdCh0YXJnZXQpLFxuICAgICAgICAgICAgICBwcmV2RnJvbVJlY3QgPSB0YXJnZXQucHJldkZyb21SZWN0LFxuICAgICAgICAgICAgICBwcmV2VG9SZWN0ID0gdGFyZ2V0LnByZXZUb1JlY3QsXG4gICAgICAgICAgICAgIGFuaW1hdGluZ1JlY3QgPSBzdGF0ZS5yZWN0LFxuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXggPSBtYXRyaXgodGFyZ2V0LCB0cnVlKTtcblxuICAgICAgICAgIGlmICh0YXJnZXRNYXRyaXgpIHtcbiAgICAgICAgICAgIC8vIENvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICAgICAgICB0b1JlY3QudG9wIC09IHRhcmdldE1hdHJpeC5mO1xuICAgICAgICAgICAgdG9SZWN0LmxlZnQgLT0gdGFyZ2V0TWF0cml4LmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0LnRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICAgIGlmICh0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBDb3VsZCBhbHNvIGNoZWNrIGlmIGFuaW1hdGluZ1JlY3QgaXMgYmV0d2VlbiBmcm9tUmVjdCBhbmQgdG9SZWN0XG4gICAgICAgICAgICBpZiAoaXNSZWN0RXF1YWwocHJldkZyb21SZWN0LCB0b1JlY3QpICYmICFpc1JlY3RFcXVhbChmcm9tUmVjdCwgdG9SZWN0KSAmJiAvLyBNYWtlIHN1cmUgYW5pbWF0aW5nUmVjdCBpcyBvbiBsaW5lIGJldHdlZW4gdG9SZWN0ICYgZnJvbVJlY3RcbiAgICAgICAgICAgIChhbmltYXRpbmdSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGFuaW1hdGluZ1JlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSA9PT0gKGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgcmV0dXJuaW5nIHRvIHNhbWUgcGxhY2UgYXMgc3RhcnRlZCBmcm9tIGFuaW1hdGlvbiBhbmQgb24gc2FtZSBheGlzXG4gICAgICAgICAgICAgIHRpbWUgPSBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBwcmV2RnJvbVJlY3QsIHByZXZUb1JlY3QsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gaWYgZnJvbVJlY3QgIT0gdG9SZWN0OiBhbmltYXRlXG5cblxuICAgICAgICAgIGlmICghaXNSZWN0RXF1YWwodG9SZWN0LCBmcm9tUmVjdCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgICAgIHRhcmdldC5wcmV2VG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgdGltZSA9IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5hbmltYXRlKHRhcmdldCwgYW5pbWF0aW5nUmVjdCwgdG9SZWN0LCB0aW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChhbmltYXRpb25UaW1lLCB0aW1lKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lcik7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uUmVzZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgICB0YXJnZXQuZnJvbVJlY3QgPSBudWxsO1xuICAgICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIHRhcmdldC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG5cbiAgICAgICAgaWYgKCFhbmltYXRpbmcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSwgYW5pbWF0aW9uVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhbmltYXRpb25TdGF0ZXMgPSBbXTtcbiAgICAgIH0sXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKHRhcmdldCwgY3VycmVudFJlY3QsIHRvUmVjdCwgZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgodGhpcy5lbCksXG4gICAgICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmQsXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSAoY3VycmVudFJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSAoY3VycmVudFJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoc2NhbGVZIHx8IDEpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gISF0cmFuc2xhdGVYO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdZID0gISF0cmFuc2xhdGVZO1xuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZVggKyAncHgsJyArIHRyYW5zbGF0ZVkgKyAncHgsMCknKTtcbiAgICAgICAgICByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ3RyYW5zZm9ybSAnICsgZHVyYXRpb24gKyAnbXMnICsgKHRoaXMub3B0aW9ucy5lYXNpbmcgPyAnICcgKyB0aGlzLm9wdGlvbnMuZWFzaW5nIDogJycpKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuICAgICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9IGZhbHNlO1xuICAgICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwYWludCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gYW5pbWF0aW5nUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIGFuaW1hdGluZ1JlY3QubGVmdCwgMikpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0LCAyKSkgKiBvcHRpb25zLmFuaW1hdGlvbjtcbiAgfVxuXG4gIHZhciBwbHVnaW5zID0gW107XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gIH07XG4gIHZhciBQbHVnaW5NYW5hZ2VyID0ge1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudChwbHVnaW4pIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKHZhciBvcHRpb24gaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgIShvcHRpb24gaW4gcGx1Z2luKSkge1xuICAgICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICB9LFxuICAgIHBsdWdpbkV2ZW50OiBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlLCBldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZXZlbnRDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgICBldnQuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBldmVudE5hbWVHbG9iYWwgPSBldmVudE5hbWUgKyAnR2xvYmFsJztcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIEZpcmUgZ2xvYmFsIGV2ZW50cyBpZiBpdCBleGlzdHMgaW4gdGhpcyBzb3J0YWJsZVxuXG4gICAgICAgIGlmIChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lR2xvYmFsXSkge1xuICAgICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlXG4gICAgICAgICAgfSwgZXZ0KSk7XG4gICAgICAgIH0gLy8gT25seSBmaXJlIHBsdWdpbiBldmVudCBpZiBwbHVnaW4gaXMgZW5hYmxlZCBpbiB0aGlzIHNvcnRhYmxlLFxuICAgICAgICAvLyBhbmQgcGx1Z2luIGhhcyBldmVudCBkZWZpbmVkXG5cblxuICAgICAgICBpZiAoc29ydGFibGUub3B0aW9uc1twbHVnaW4ucGx1Z2luTmFtZV0gJiYgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXShfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICAgIH0sIGV2dCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluaXRpYWxpemVQbHVnaW5zOiBmdW5jdGlvbiBpbml0aWFsaXplUGx1Z2lucyhzb3J0YWJsZSwgZWwsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IHBsdWdpbi5wbHVnaW5OYW1lO1xuICAgICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luTmFtZV0gJiYgIXBsdWdpbi5pbml0aWFsaXplQnlEZWZhdWx0KSByZXR1cm47XG4gICAgICAgIHZhciBpbml0aWFsaXplZCA9IG5ldyBwbHVnaW4oc29ydGFibGUsIGVsLCBzb3J0YWJsZS5vcHRpb25zKTtcbiAgICAgICAgaW5pdGlhbGl6ZWQuc29ydGFibGUgPSBzb3J0YWJsZTtcbiAgICAgICAgaW5pdGlhbGl6ZWQub3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnM7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbk5hbWVdID0gaW5pdGlhbGl6ZWQ7IC8vIEFkZCBkZWZhdWx0IG9wdGlvbnMgZnJvbSBwbHVnaW5cblxuICAgICAgICBfZXh0ZW5kcyhkZWZhdWx0cywgaW5pdGlhbGl6ZWQuZGVmYXVsdHMpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIG9wdGlvbiBpbiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICAgIGlmICghc29ydGFibGUub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG1vZGlmaWVkID0gdGhpcy5tb2RpZnlPcHRpb24oc29ydGFibGUsIG9wdGlvbiwgc29ydGFibGUub3B0aW9uc1tvcHRpb25dKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNvcnRhYmxlLm9wdGlvbnNbb3B0aW9uXSA9IG1vZGlmaWVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRFdmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkge1xuICAgICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHt9O1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgICAgX2V4dGVuZHMoZXZlbnRQcm9wZXJ0aWVzLCBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCBuYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBldmVudFByb3BlcnRpZXM7XG4gICAgfSxcbiAgICBtb2RpZnlPcHRpb246IGZ1bmN0aW9uIG1vZGlmeU9wdGlvbihzb3J0YWJsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlO1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgLy8gUGx1Z2luIG11c3QgZXhpc3Qgb24gdGhlIFNvcnRhYmxlXG4gICAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIElmIHN0YXRpYyBvcHRpb24gbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIG9wdGlvbiwgY2FsbCBpbiB0aGUgY29udGV4dCBvZiB0aGUgU29ydGFibGUncyBpbnN0YW5jZSBvZiB0aGlzIHBsdWdpblxuXG4gICAgICAgIGlmIChwbHVnaW4ub3B0aW9uTGlzdGVuZXJzICYmIHR5cGVvZiBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbW9kaWZpZWRWYWx1ZSA9IHBsdWdpbi5vcHRpb25MaXN0ZW5lcnNbbmFtZV0uY2FsbChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbW9kaWZpZWRWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChfcmVmKSB7XG4gICAgdmFyIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZSxcbiAgICAgICAgcm9vdEVsID0gX3JlZi5yb290RWwsXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIHRhcmdldEVsID0gX3JlZi50YXJnZXRFbCxcbiAgICAgICAgY2xvbmVFbCA9IF9yZWYuY2xvbmVFbCxcbiAgICAgICAgdG9FbCA9IF9yZWYudG9FbCxcbiAgICAgICAgZnJvbUVsID0gX3JlZi5mcm9tRWwsXG4gICAgICAgIG9sZEluZGV4ID0gX3JlZi5vbGRJbmRleCxcbiAgICAgICAgbmV3SW5kZXggPSBfcmVmLm5ld0luZGV4LFxuICAgICAgICBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYub2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gX3JlZi5uZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgICAgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgICBleHRyYUV2ZW50UHJvcGVydGllcyA9IF9yZWYuZXh0cmFFdmVudFByb3BlcnRpZXM7XG4gICAgc29ydGFibGUgPSBzb3J0YWJsZSB8fCByb290RWwgJiYgcm9vdEVsW2V4cGFuZG9dO1xuICAgIGlmICghc29ydGFibGUpIHJldHVybjtcbiAgICB2YXIgZXZ0LFxuICAgICAgICBvcHRpb25zID0gc29ydGFibGUub3B0aW9ucyxcbiAgICAgICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXZ0LnRvID0gdG9FbCB8fCByb290RWw7XG4gICAgZXZ0LmZyb20gPSBmcm9tRWwgfHwgcm9vdEVsO1xuICAgIGV2dC5pdGVtID0gdGFyZ2V0RWwgfHwgcm9vdEVsO1xuICAgIGV2dC5jbG9uZSA9IGNsb25lRWw7XG4gICAgZXZ0Lm9sZEluZGV4ID0gb2xkSW5kZXg7XG4gICAgZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG4gICAgZXZ0Lm9sZERyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgZXZ0Lm5ld0RyYWdnYWJsZUluZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXg7XG4gICAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgIGV2dC5wdWxsTW9kZSA9IHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUubGFzdFB1dE1vZGUgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYWxsRXZlbnRQcm9wZXJ0aWVzID0gX29iamVjdFNwcmVhZCh7fSwgZXh0cmFFdmVudFByb3BlcnRpZXMsIFBsdWdpbk1hbmFnZXIuZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSk7XG5cbiAgICBmb3IgKHZhciBvcHRpb24gaW4gYWxsRXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgICBldnRbb3B0aW9uXSA9IGFsbEV2ZW50UHJvcGVydGllc1tvcHRpb25dO1xuICAgIH1cblxuICAgIGlmIChyb290RWwpIHtcbiAgICAgIHJvb3RFbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbb25OYW1lXSkge1xuICAgICAgb3B0aW9uc1tvbk5hbWVdLmNhbGwoc29ydGFibGUsIGV2dCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsdWdpbkV2ZW50ID0gZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgb3JpZ2luYWxFdmVudCA9IF9yZWYuZXZ0LFxuICAgICAgICBkYXRhID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImV2dFwiXSk7XG5cbiAgICBQbHVnaW5NYW5hZ2VyLnBsdWdpbkV2ZW50LmJpbmQoU29ydGFibGUpKGV2ZW50TmFtZSwgc29ydGFibGUsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgICBwYXJlbnRFbDogcGFyZW50RWwsXG4gICAgICBnaG9zdEVsOiBnaG9zdEVsLFxuICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICBuZXh0RWw6IG5leHRFbCxcbiAgICAgIGxhc3REb3duRWw6IGxhc3REb3duRWwsXG4gICAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgICAgY2xvbmVIaWRkZW46IGNsb25lSGlkZGVuLFxuICAgICAgZHJhZ1N0YXJ0ZWQ6IG1vdmVkLFxuICAgICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgICAgYWN0aXZlU29ydGFibGU6IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG4gICAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICBoaWRlR2hvc3RGb3JUYXJnZXQ6IF9oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICB1bmhpZGVHaG9zdEZvclRhcmdldDogX3VuaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgICAgY2xvbmVOb3dIaWRkZW46IGZ1bmN0aW9uIGNsb25lTm93SGlkZGVuKCkge1xuICAgICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgICB9LFxuICAgICAgY2xvbmVOb3dTaG93bjogZnVuY3Rpb24gY2xvbmVOb3dTaG93bigpIHtcbiAgICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoU29ydGFibGVFdmVudChuYW1lKSB7XG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIGRhdGEpKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChpbmZvKSB7XG4gICAgZGlzcGF0Y2hFdmVudChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZSxcbiAgICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgICB0YXJnZXRFbDogZHJhZ0VsLFxuICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgICB9LCBpbmZvKSk7XG4gIH1cblxuICB2YXIgZHJhZ0VsLFxuICAgICAgcGFyZW50RWwsXG4gICAgICBnaG9zdEVsLFxuICAgICAgcm9vdEVsLFxuICAgICAgbmV4dEVsLFxuICAgICAgbGFzdERvd25FbCxcbiAgICAgIGNsb25lRWwsXG4gICAgICBjbG9uZUhpZGRlbixcbiAgICAgIG9sZEluZGV4LFxuICAgICAgbmV3SW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgYWN0aXZlR3JvdXAsXG4gICAgICBwdXRTb3J0YWJsZSxcbiAgICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICAgICAgc29ydGFibGVzID0gW10sXG4gICAgICB0YXBFdnQsXG4gICAgICB0b3VjaEV2dCxcbiAgICAgIGxhc3REeCxcbiAgICAgIGxhc3REeSxcbiAgICAgIHRhcERpc3RhbmNlTGVmdCxcbiAgICAgIHRhcERpc3RhbmNlVG9wLFxuICAgICAgbW92ZWQsXG4gICAgICBsYXN0VGFyZ2V0LFxuICAgICAgbGFzdERpcmVjdGlvbixcbiAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlLFxuICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICAgICAgdGFyZ2V0TW92ZURpc3RhbmNlLFxuICAgICAgLy8gRm9yIHBvc2l0aW9uaW5nIGdob3N0IGFic29sdXRlbHlcbiAgZ2hvc3RSZWxhdGl2ZVBhcmVudCxcbiAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gW10sXG4gICAgICAvLyAobGVmdCwgdG9wKVxuICBfc2lsZW50ID0gZmFsc2UsXG4gICAgICBzYXZlZElucHV0Q2hlY2tlZCA9IFtdO1xuICAvKiogQGNvbnN0ICovXG5cbiAgdmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID0gSU9TLFxuICAgICAgQ1NTRmxvYXRQcm9wZXJ0eSA9IEVkZ2UgfHwgSUUxMU9yTGVzcyA/ICdjc3NGbG9hdCcgOiAnZmxvYXQnLFxuICAgICAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbiAgc3VwcG9ydERyYWdnYWJsZSA9IGRvY3VtZW50RXhpc3RzICYmICFDaHJvbWVGb3JBbmRyb2lkICYmICFJT1MgJiYgJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRvY3VtZW50RXhpc3RzKSByZXR1cm47IC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuXG4gICAgaWYgKElFMTFPckxlc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4Jyk7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czphdXRvJztcbiAgICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xuICB9KCksXG4gICAgICBfZGV0ZWN0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2RldGVjdERpcmVjdGlvbihlbCwgb3B0aW9ucykge1xuICAgIHZhciBlbENTUyA9IGNzcyhlbCksXG4gICAgICAgIGVsV2lkdGggPSBwYXJzZUludChlbENTUy53aWR0aCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nTGVmdCkgLSBwYXJzZUludChlbENTUy5wYWRkaW5nUmlnaHQpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyTGVmdFdpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlclJpZ2h0V2lkdGgpLFxuICAgICAgICBjaGlsZDEgPSBnZXRDaGlsZChlbCwgMCwgb3B0aW9ucyksXG4gICAgICAgIGNoaWxkMiA9IGdldENoaWxkKGVsLCAxLCBvcHRpb25zKSxcbiAgICAgICAgZmlyc3RDaGlsZENTUyA9IGNoaWxkMSAmJiBjc3MoY2hpbGQxKSxcbiAgICAgICAgc2Vjb25kQ2hpbGRDU1MgPSBjaGlsZDIgJiYgY3NzKGNoaWxkMiksXG4gICAgICAgIGZpcnN0Q2hpbGRXaWR0aCA9IGZpcnN0Q2hpbGRDU1MgJiYgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDEpLndpZHRoLFxuICAgICAgICBzZWNvbmRDaGlsZFdpZHRoID0gc2Vjb25kQ2hpbGRDU1MgJiYgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5SaWdodCkgKyBnZXRSZWN0KGNoaWxkMikud2lkdGg7XG5cbiAgICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgfVxuXG4gICAgaWYgKGVsQ1NTLmRpc3BsYXkgPT09ICdncmlkJykge1xuICAgICAgcmV0dXJuIGVsQ1NTLmdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoJyAnKS5sZW5ndGggPD0gMSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkMSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gJiYgZmlyc3RDaGlsZENTU1tcImZsb2F0XCJdICE9PSAnbm9uZScpIHtcbiAgICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICByZXR1cm4gY2hpbGQyICYmIChzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gJ2JvdGgnIHx8IHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSB0b3VjaGluZ1NpZGVDaGlsZDIpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfSxcbiAgICAgIF9kcmFnRWxJblJvd0NvbHVtbiA9IGZ1bmN0aW9uIF9kcmFnRWxJblJvd0NvbHVtbihkcmFnUmVjdCwgdGFyZ2V0UmVjdCwgdmVydGljYWwpIHtcbiAgICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICAgIGRyYWdFbFMyT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5yaWdodCA6IGRyYWdSZWN0LmJvdHRvbSxcbiAgICAgICAgZHJhZ0VsT3BwTGVuZ3RoID0gdmVydGljYWwgPyBkcmFnUmVjdC53aWR0aCA6IGRyYWdSZWN0LmhlaWdodCxcbiAgICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgICB0YXJnZXRTMk9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5yaWdodCA6IHRhcmdldFJlY3QuYm90dG9tLFxuICAgICAgICB0YXJnZXRPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3Qud2lkdGggOiB0YXJnZXRSZWN0LmhlaWdodDtcbiAgICByZXR1cm4gZHJhZ0VsUzFPcHAgPT09IHRhcmdldFMxT3BwIHx8IGRyYWdFbFMyT3BwID09PSB0YXJnZXRTMk9wcCB8fCBkcmFnRWxTMU9wcCArIGRyYWdFbE9wcExlbmd0aCAvIDIgPT09IHRhcmdldFMxT3BwICsgdGFyZ2V0T3BwTGVuZ3RoIC8gMjtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZWN0cyBmaXJzdCBuZWFyZXN0IGVtcHR5IHNvcnRhYmxlIHRvIFggYW5kIFkgcG9zaXRpb24gdXNpbmcgZW1wdHlJbnNlcnRUaHJlc2hvbGQuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgICAgIFggcG9zaXRpb25cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICAgICAgWSBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICBFbGVtZW50IG9mIHRoZSBmaXJzdCBmb3VuZCBuZWFyZXN0IFNvcnRhYmxlXG4gICAqL1xuICBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUgPSBmdW5jdGlvbiBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoeCwgeSkge1xuICAgIHZhciByZXQ7XG4gICAgc29ydGFibGVzLnNvbWUoZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgICBpZiAobGFzdENoaWxkKHNvcnRhYmxlKSkgcmV0dXJuO1xuICAgICAgdmFyIHJlY3QgPSBnZXRSZWN0KHNvcnRhYmxlKSxcbiAgICAgICAgICB0aHJlc2hvbGQgPSBzb3J0YWJsZVtleHBhbmRvXS5vcHRpb25zLmVtcHR5SW5zZXJ0VGhyZXNob2xkLFxuICAgICAgICAgIGluc2lkZUhvcml6b250YWxseSA9IHggPj0gcmVjdC5sZWZ0IC0gdGhyZXNob2xkICYmIHggPD0gcmVjdC5yaWdodCArIHRocmVzaG9sZCxcbiAgICAgICAgICBpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSByZWN0LnRvcCAtIHRocmVzaG9sZCAmJiB5IDw9IHJlY3QuYm90dG9tICsgdGhyZXNob2xkO1xuXG4gICAgICBpZiAodGhyZXNob2xkICYmIGluc2lkZUhvcml6b250YWxseSAmJiBpbnNpZGVWZXJ0aWNhbGx5KSB7XG4gICAgICAgIHJldHVybiByZXQgPSBzb3J0YWJsZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICAgICAgX3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JvdXAob3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIHRvRm4odmFsdWUsIHB1bGwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSB7XG4gICAgICAgIHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiYgZnJvbS5vcHRpb25zLmdyb3VwLm5hbWUgJiYgdG8ub3B0aW9ucy5ncm91cC5uYW1lID09PSBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZTtcblxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAocHVsbCB8fCBzYW1lR3JvdXApKSB7XG4gICAgICAgICAgLy8gRGVmYXVsdCBwdWxsIHZhbHVlXG4gICAgICAgICAgLy8gRGVmYXVsdCBwdWxsIGFuZCBwdXQgdmFsdWUgaWYgc2FtZSBncm91cFxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHB1bGwgJiYgdmFsdWUgPT09ICdjbG9uZScpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRvRm4odmFsdWUodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSwgcHVsbCkodG8sIGZyb20sIGRyYWdFbCwgZXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3RoZXJHcm91cCA9IChwdWxsID8gdG8gOiBmcm9tKS5vcHRpb25zLmdyb3VwLm5hbWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUgPT09IG90aGVyR3JvdXAgfHwgdmFsdWUuam9pbiAmJiB2YWx1ZS5pbmRleE9mKG90aGVyR3JvdXApID4gLTE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0ge307XG4gICAgdmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuXG4gICAgaWYgKCFvcmlnaW5hbEdyb3VwIHx8IF90eXBlb2Yob3JpZ2luYWxHcm91cCkgIT0gJ29iamVjdCcpIHtcbiAgICAgIG9yaWdpbmFsR3JvdXAgPSB7XG4gICAgICAgIG5hbWU6IG9yaWdpbmFsR3JvdXBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZ3JvdXAubmFtZSA9IG9yaWdpbmFsR3JvdXAubmFtZTtcbiAgICBncm91cC5jaGVja1B1bGwgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHVsbCwgdHJ1ZSk7XG4gICAgZ3JvdXAuY2hlY2tQdXQgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHV0KTtcbiAgICBncm91cC5yZXZlcnRDbG9uZSA9IG9yaWdpbmFsR3JvdXAucmV2ZXJ0Q2xvbmU7XG4gICAgb3B0aW9ucy5ncm91cCA9IGdyb3VwO1xuICB9LFxuICAgICAgX2hpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF9oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gICAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF91bmhpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICcnKTtcbiAgICB9XG4gIH07IC8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxuXG5cbiAgaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoaWdub3JlTmV4dENsaWNrKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpIHtcbiAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICBldnQgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0O1xuXG4gICAgICB2YXIgbmVhcmVzdCA9IF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZShldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgICBpZiAobmVhcmVzdCkge1xuICAgICAgICAvLyBDcmVhdGUgaW1pdGF0aW9uIGV2ZW50XG4gICAgICAgIHZhciBldmVudCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gZXZ0KSB7XG4gICAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgZXZlbnRbaV0gPSBldnRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQucm9vdEVsID0gbmVhcmVzdDtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSB2b2lkIDA7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICBuZWFyZXN0W2V4cGFuZG9dLl9vbkRyYWdPdmVyKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIF9jaGVja091dHNpZGVUYXJnZXRFbCA9IGZ1bmN0aW9uIF9jaGVja091dHNpZGVUYXJnZXRFbChldnQpIHtcbiAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBjbGFzcyAgU29ydGFibGVcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XG4gICAgICB0aHJvdyBcIlNvcnRhYmxlOiBgZWxgIG11c3QgYmUgYW4gSFRNTEVsZW1lbnQsIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChlbCkpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpOyAvLyBFeHBvcnQgaW5zdGFuY2VcblxuICAgIGVsW2V4cGFuZG9dID0gdGhpcztcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBncm91cDogbnVsbCxcbiAgICAgIHNvcnQ6IHRydWUsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBzdG9yZTogbnVsbCxcbiAgICAgIGhhbmRsZTogbnVsbCxcbiAgICAgIGRyYWdnYWJsZTogL15bdW9dbCQvaS50ZXN0KGVsLm5vZGVOYW1lKSA/ICc+bGknIDogJz4qJyxcbiAgICAgIHN3YXBUaHJlc2hvbGQ6IDEsXG4gICAgICAvLyBwZXJjZW50YWdlOyAwIDw9IHggPD0gMVxuICAgICAgaW52ZXJ0U3dhcDogZmFsc2UsXG4gICAgICAvLyBpbnZlcnQgYWx3YXlzXG4gICAgICBpbnZlcnRlZFN3YXBUaHJlc2hvbGQ6IG51bGwsXG4gICAgICAvLyB3aWxsIGJlIHNldCB0byBzYW1lIGFzIHN3YXBUaHJlc2hvbGQgaWYgZGVmYXVsdFxuICAgICAgcmVtb3ZlQ2xvbmVPbkhpZGU6IHRydWUsXG4gICAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZXRlY3REaXJlY3Rpb24oZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9LFxuICAgICAgZ2hvc3RDbGFzczogJ3NvcnRhYmxlLWdob3N0JyxcbiAgICAgIGNob3NlbkNsYXNzOiAnc29ydGFibGUtY2hvc2VuJyxcbiAgICAgIGRyYWdDbGFzczogJ3NvcnRhYmxlLWRyYWcnLFxuICAgICAgaWdub3JlOiAnYSwgaW1nJyxcbiAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgIHByZXZlbnRPbkZpbHRlcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvbjogMCxcbiAgICAgIGVhc2luZzogbnVsbCxcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkcmFnRWwudGV4dENvbnRlbnQpO1xuICAgICAgfSxcbiAgICAgIGRyb3BCdWJibGU6IGZhbHNlLFxuICAgICAgZHJhZ292ZXJCdWJibGU6IGZhbHNlLFxuICAgICAgZGF0YUlkQXR0cjogJ2RhdGEtaWQnLFxuICAgICAgZGVsYXk6IDAsXG4gICAgICBkZWxheU9uVG91Y2hPbmx5OiBmYWxzZSxcbiAgICAgIHRvdWNoU3RhcnRUaHJlc2hvbGQ6IChOdW1iZXIucGFyc2VJbnQgPyBOdW1iZXIgOiB3aW5kb3cpLnBhcnNlSW50KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxMCkgfHwgMSxcbiAgICAgIGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuICAgICAgZmFsbGJhY2tDbGFzczogJ3NvcnRhYmxlLWZhbGxiYWNrJyxcbiAgICAgIGZhbGxiYWNrT25Cb2R5OiBmYWxzZSxcbiAgICAgIGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxuICAgICAgZmFsbGJhY2tPZmZzZXQ6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIHN1cHBvcnRQb2ludGVyOiBTb3J0YWJsZS5zdXBwb3J0UG9pbnRlciAhPT0gZmFsc2UgJiYgJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93LFxuICAgICAgZW1wdHlJbnNlcnRUaHJlc2hvbGQ6IDVcbiAgICB9O1xuICAgIFBsdWdpbk1hbmFnZXIuaW5pdGlhbGl6ZVBsdWdpbnModGhpcywgZWwsIGRlZmF1bHRzKTsgLy8gU2V0IGRlZmF1bHQgb3B0aW9uc1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICAgIShuYW1lIGluIG9wdGlvbnMpICYmIChvcHRpb25zW25hbWVdID0gZGVmYXVsdHNbbmFtZV0pO1xuICAgIH1cblxuICAgIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG5cbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IC8vIFNldHVwIGRyYWcgbW9kZVxuXG5cbiAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZSA9IG9wdGlvbnMuZm9yY2VGYWxsYmFjayA/IGZhbHNlIDogc3VwcG9ydERyYWdnYWJsZTtcblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgLy8gVG91Y2ggc3RhcnQgdGhyZXNob2xkIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG5hdGl2ZSBkcmFnc3RhcnQgdGhyZXNob2xkXG4gICAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDE7XG4gICAgfSAvLyBCaW5kIGV2ZW50c1xuXG5cbiAgICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgb24oZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgICAgb24oZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvbihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgICBvbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICAgIH1cblxuICAgIHNvcnRhYmxlcy5wdXNoKHRoaXMuZWwpOyAvLyBSZXN0b3JlIHNvcnRpbmdcblxuICAgIG9wdGlvbnMuc3RvcmUgJiYgb3B0aW9ucy5zdG9yZS5nZXQgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpIHx8IFtdKTsgLy8gQWRkIGFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VyXG5cbiAgICBfZXh0ZW5kcyh0aGlzLCBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSk7XG4gIH1cblxuICBTb3J0YWJsZS5wcm90b3R5cGUgPVxuICAvKiogQGxlbmRzIFNvcnRhYmxlLnByb3RvdHlwZSAqL1xuICB7XG4gICAgY29uc3RydWN0b3I6IFNvcnRhYmxlLFxuICAgIF9pc091dHNpZGVUaGlzRWw6IGZ1bmN0aW9uIF9pc091dHNpZGVUaGlzRWwodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRoaXMuZWwuY29udGFpbnModGFyZ2V0KSAmJiB0YXJnZXQgIT09IHRoaXMuZWwpIHtcbiAgICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIGRyYWdFbCkgOiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIH0sXG4gICAgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uIF9vblRhcFN0YXJ0KFxuICAgIC8qKiBFdmVudHxUb3VjaEV2ZW50ICovXG4gICAgZXZ0KSB7XG4gICAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgcHJldmVudE9uRmlsdGVyID0gb3B0aW9ucy5wcmV2ZW50T25GaWx0ZXIsXG4gICAgICAgICAgdHlwZSA9IGV2dC50eXBlLFxuICAgICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgJiYgZXZ0LnRvdWNoZXNbMF0gfHwgZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyAmJiBldnQsXG4gICAgICAgICAgdGFyZ2V0ID0gKHRvdWNoIHx8IGV2dCkudGFyZ2V0LFxuICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0ID0gZXZ0LnRhcmdldC5zaGFkb3dSb290ICYmIChldnQucGF0aCAmJiBldnQucGF0aFswXSB8fCBldnQuY29tcG9zZWRQYXRoICYmIGV2dC5jb21wb3NlZFBhdGgoKVswXSkgfHwgdGFyZ2V0LFxuICAgICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXG4gICAgICBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTsgLy8gRG9uJ3QgdHJpZ2dlciBzdGFydCBldmVudCB3aGVuIGFuIGVsZW1lbnQgaXMgYmVlbiBkcmFnZ2VkLCBvdGhlcndpc2UgdGhlIGV2dC5vbGRpbmRleCBhbHdheXMgd3Jvbmcgd2hlbiBzZXQgb3B0aW9uLmdyb3VwLlxuXG5cbiAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoL21vdXNlZG93bnxwb2ludGVyZG93bi8udGVzdCh0eXBlKSAmJiBldnQuYnV0dG9uICE9PSAwIHx8IG9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXG4gICAgICB9IC8vIGNhbmNlbCBkbmQgaWYgb3JpZ2luYWwgdGFyZ2V0IGlzIGNvbnRlbnQgZWRpdGFibGVcblxuXG4gICAgICBpZiAob3JpZ2luYWxUYXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSk7XG5cbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3REb3duRWwgPT09IHRhcmdldCkge1xuICAgICAgICAvLyBJZ25vcmluZyBkdXBsaWNhdGUgYGRvd25gXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cblxuICAgICAgb2xkSW5kZXggPSBpbmRleCh0YXJnZXQpO1xuICAgICAgb2xkRHJhZ2dhYmxlSW5kZXggPSBpbmRleCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlKTsgLy8gQ2hlY2sgZmlsdGVyXG5cbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgICByb290RWw6IG9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgICBmcm9tRWw6IGVsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSBmaWx0ZXIuc3BsaXQoJywnKS5zb21lKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICAgIGNyaXRlcmlhID0gY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCwgZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKGNyaXRlcmlhKSB7XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgICAgcm9vdEVsOiBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgIHRvRWw6IGVsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5oYW5kbGUgJiYgIWNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMuaGFuZGxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJlcGFyZSBgZHJhZ3N0YXJ0YFxuXG5cbiAgICAgIHRoaXMuX3ByZXBhcmVEcmFnU3RhcnQoZXZ0LCB0b3VjaCwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIF9wcmVwYXJlRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfcHJlcGFyZURyYWdTdGFydChcbiAgICAvKiogRXZlbnQgKi9cbiAgICBldnQsXG4gICAgLyoqIFRvdWNoICovXG4gICAgdG91Y2gsXG4gICAgLyoqIEhUTUxFbGVtZW50ICovXG4gICAgdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGVsID0gX3RoaXMuZWwsXG4gICAgICAgICAgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgICAgb3duZXJEb2N1bWVudCA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgZHJhZ1N0YXJ0Rm47XG5cbiAgICAgIGlmICh0YXJnZXQgJiYgIWRyYWdFbCAmJiB0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcbiAgICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICByb290RWwgPSBlbDtcbiAgICAgICAgZHJhZ0VsID0gdGFyZ2V0O1xuICAgICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xuICAgICAgICBuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG4gICAgICAgIGxhc3REb3duRWwgPSB0YXJnZXQ7XG4gICAgICAgIGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcbiAgICAgICAgU29ydGFibGUuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICAgICAgdGFwRXZ0ID0ge1xuICAgICAgICAgIHRhcmdldDogZHJhZ0VsLFxuICAgICAgICAgIGNsaWVudFg6ICh0b3VjaCB8fCBldnQpLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogKHRvdWNoIHx8IGV2dCkuY2xpZW50WVxuICAgICAgICB9O1xuICAgICAgICB0YXBEaXN0YW5jZUxlZnQgPSB0YXBFdnQuY2xpZW50WCAtIGRyYWdSZWN0LmxlZnQ7XG4gICAgICAgIHRhcERpc3RhbmNlVG9wID0gdGFwRXZ0LmNsaWVudFkgLSBkcmFnUmVjdC50b3A7XG4gICAgICAgIHRoaXMuX2xhc3RYID0gKHRvdWNoIHx8IGV2dCkuY2xpZW50WDtcbiAgICAgICAgdGhpcy5fbGFzdFkgPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRZO1xuICAgICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnYWxsJztcblxuICAgICAgICBkcmFnU3RhcnRGbiA9IGZ1bmN0aW9uIGRyYWdTdGFydEZuKCkge1xuICAgICAgICAgIHBsdWdpbkV2ZW50KCdkZWxheUVuZGVkJywgX3RoaXMsIHtcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgICAgX3RoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgICAgLy8gd2UgY2FuIHJlLWVuYWJsZSB0aGUgZXZlbnRzOiB0b3VjaG1vdmUvbW91c2Vtb3ZlXG5cblxuICAgICAgICAgIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgICAgICAgIGlmICghRmlyZUZveCAmJiBfdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gQmluZCB0aGUgZXZlbnRzOiBkcmFnc3RhcnQvZHJhZ2VuZFxuXG5cbiAgICAgICAgICBfdGhpcy5fdHJpZ2dlckRyYWdTdGFydChldnQsIHRvdWNoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgICBuYW1lOiAnY2hvb3NlJyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBDaG9zZW4gaXRlbVxuXG5cbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xuICAgICAgICB9OyAvLyBEaXNhYmxlIFwiZHJhZ2dhYmxlXCJcblxuXG4gICAgICAgIG9wdGlvbnMuaWdub3JlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICBmaW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnZHJhZ292ZXInLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTsgLy8gTWFrZSBkcmFnRWwgZHJhZ2dhYmxlIChtdXN0IGJlIGJlZm9yZSBkZWxheSBmb3IgRmlyZUZveClcblxuICAgICAgICBpZiAoRmlyZUZveCAmJiB0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gNDtcbiAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsdWdpbkV2ZW50KCdkZWxheVN0YXJ0JywgdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pOyAvLyBEZWxheSBpcyBpbXBvc3NpYmxlIGZvciBuYXRpdmUgRG5EIGluIEVkZ2Ugb3IgSUVcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiAoIW9wdGlvbnMuZGVsYXlPblRvdWNoT25seSB8fCB0b3VjaCkgJiYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCAhKEVkZ2UgfHwgSUUxMU9yTGVzcykpKSB7XG4gICAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBJZiB0aGUgdXNlciBtb3ZlcyB0aGUgcG9pbnRlciBvciBsZXQgZ28gdGhlIGNsaWNrIG9yIHRvdWNoXG4gICAgICAgICAgLy8gYmVmb3JlIHRoZSBkZWxheSBoYXMgYmVlbiByZWFjaGVkOlxuICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuXG5cbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgb3B0aW9ucy5zdXBwb3J0UG9pbnRlciAmJiBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgICBfdGhpcy5fZHJhZ1N0YXJ0VGltZXIgPSBzZXRUaW1lb3V0KGRyYWdTdGFydEZuLCBvcHRpb25zLmRlbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnU3RhcnRGbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyOiBmdW5jdGlvbiBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKFxuICAgIC8qKiBUb3VjaEV2ZW50fFBvaW50ZXJFdmVudCAqKi9cbiAgICBlKSB7XG4gICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG4gICAgICBpZiAoTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPj0gTWF0aC5mbG9vcih0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCAvICh0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSkpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZGlzYWJsZURlbGF5ZWREcmFnOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnKCkge1xuICAgICAgZHJhZ0VsICYmIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuXG4gICAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcbiAgICB9LFxuICAgIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHM6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgfSxcbiAgICBfdHJpZ2dlckRyYWdTdGFydDogZnVuY3Rpb24gX3RyaWdnZXJEcmFnU3RhcnQoXG4gICAgLyoqIEV2ZW50ICovXG4gICAgZXZ0LFxuICAgIC8qKiBUb3VjaCAqL1xuICAgIHRvdWNoKSB7XG4gICAgICB0b3VjaCA9IHRvdWNoIHx8IGV2dC5wb2ludGVyVHlwZSA9PSAndG91Y2gnICYmIGV2dDtcblxuICAgICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCB0b3VjaCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3VjaCkge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICAgIG9uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAgIC8vIFRpbWVvdXQgbmVjY2Vzc2FyeSBmb3IgSUU5XG4gICAgICAgICAgX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIH0sXG4gICAgX2RyYWdTdGFydGVkOiBmdW5jdGlvbiBfZHJhZ1N0YXJ0ZWQoZmFsbGJhY2ssIGV2dCkge1xuXG4gICAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChyb290RWwgJiYgZHJhZ0VsKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnRlZCcsIHRoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ2RyYWdvdmVyJywgX2NoZWNrT3V0c2lkZVRhcmdldEVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBBcHBseSBlZmZlY3RcblxuICAgICAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgZmFsc2UpO1xuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICAgIFNvcnRhYmxlLmFjdGl2ZSA9IHRoaXM7XG4gICAgICAgIGZhbGxiYWNrICYmIHRoaXMuX2FwcGVuZEdob3N0KCk7IC8vIERyYWcgc3RhcnQgZXZlbnRcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgbmFtZTogJ3N0YXJ0JyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiBfZW11bGF0ZURyYWdPdmVyKCkge1xuICAgICAgaWYgKHRvdWNoRXZ0KSB7XG4gICAgICAgIHRoaXMuX2xhc3RYID0gdG91Y2hFdnQuY2xpZW50WDtcbiAgICAgICAgdGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xuXG4gICAgICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRhcmdldDtcblxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSBwYXJlbnQpIGJyZWFrO1xuICAgICAgICAgIHBhcmVudCA9IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwodGFyZ2V0KTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHBhcmVudFtleHBhbmRvXSkge1xuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGluc2VydGVkID0gcGFyZW50W2V4cGFuZG9dLl9vbkRyYWdPdmVyKHtcbiAgICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaEV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoRXZ0LmNsaWVudFksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGluc2VydGVkICYmICF0aGlzLm9wdGlvbnMuZHJhZ292ZXJCdWJibGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQ7IC8vIHN0b3JlIGxhc3QgZWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG4gICAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX29uVG91Y2hNb3ZlOiBmdW5jdGlvbiBfb25Ub3VjaE1vdmUoXG4gICAgLyoqVG91Y2hFdmVudCovXG4gICAgZXZ0KSB7XG4gICAgICBpZiAodGFwRXZ0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZmFsbGJhY2tUb2xlcmFuY2UgPSBvcHRpb25zLmZhbGxiYWNrVG9sZXJhbmNlLFxuICAgICAgICAgICAgZmFsbGJhY2tPZmZzZXQgPSBvcHRpb25zLmZhbGxiYWNrT2Zmc2V0LFxuICAgICAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0LFxuICAgICAgICAgICAgZ2hvc3RNYXRyaXggPSBnaG9zdEVsICYmIG1hdHJpeChnaG9zdEVsLCB0cnVlKSxcbiAgICAgICAgICAgIHNjYWxlWCA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguYSxcbiAgICAgICAgICAgIHNjYWxlWSA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguZCxcbiAgICAgICAgICAgIHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID0gUG9zaXRpb25HaG9zdEFic29sdXRlbHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAmJiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KSxcbiAgICAgICAgICAgIGR4ID0gKHRvdWNoLmNsaWVudFggLSB0YXBFdnQuY2xpZW50WCArIGZhbGxiYWNrT2Zmc2V0LngpIC8gKHNjYWxlWCB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzBdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMF0gOiAwKSAvIChzY2FsZVggfHwgMSksXG4gICAgICAgICAgICBkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkgKyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdIDogMCkgLyAoc2NhbGVZIHx8IDEpOyAvLyBvbmx5IHNldCB0aGUgc3RhdHVzIHRvIGRyYWdnaW5nLCB3aGVuIHdlIGFyZSBhY3R1YWxseSBkcmFnZ2luZ1xuXG4gICAgICAgIGlmICghU29ydGFibGUuYWN0aXZlICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgaWYgKGZhbGxiYWNrVG9sZXJhbmNlICYmIE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9vbkRyYWdTdGFydChldnQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdob3N0RWwpIHtcbiAgICAgICAgICBpZiAoZ2hvc3RNYXRyaXgpIHtcbiAgICAgICAgICAgIGdob3N0TWF0cml4LmUgKz0gZHggLSAobGFzdER4IHx8IDApO1xuICAgICAgICAgICAgZ2hvc3RNYXRyaXguZiArPSBkeSAtIChsYXN0RHkgfHwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdob3N0TWF0cml4ID0ge1xuICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgICBkOiAxLFxuICAgICAgICAgICAgICBlOiBkeCxcbiAgICAgICAgICAgICAgZjogZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNzc01hdHJpeCA9IFwibWF0cml4KFwiLmNvbmNhdChnaG9zdE1hdHJpeC5hLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmIsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYywgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5kLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmUsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZiwgXCIpXCIpO1xuICAgICAgICAgIGNzcyhnaG9zdEVsLCAnd2Via2l0VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgICBjc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgICAgY3NzKGdob3N0RWwsICdtc1RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICAgIGxhc3REeCA9IGR4O1xuICAgICAgICAgIGxhc3REeSA9IGR5O1xuICAgICAgICAgIHRvdWNoRXZ0ID0gdG91Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gX2FwcGVuZEdob3N0KCkge1xuICAgICAgLy8gQnVnIGlmIHVzaW5nIHNjYWxlKCk6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MzcwNThcbiAgICAgIC8vIE5vdCBiZWluZyBhZGp1c3RlZCBmb3JcbiAgICAgIGlmICghZ2hvc3RFbCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmZhbGxiYWNrT25Cb2R5ID8gZG9jdW1lbnQuYm9keSA6IHJvb3RFbCxcbiAgICAgICAgICAgIHJlY3QgPSBnZXRSZWN0KGRyYWdFbCwgdHJ1ZSwgUG9zaXRpb25HaG9zdEFic29sdXRlbHksIHRydWUsIGNvbnRhaW5lciksXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBQb3NpdGlvbiBhYnNvbHV0ZWx5XG5cbiAgICAgICAgaWYgKFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5KSB7XG4gICAgICAgICAgLy8gR2V0IHJlbGF0aXZlbHkgcG9zaXRpb25lZCBwYXJlbnRcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xuXG4gICAgICAgICAgd2hpbGUgKGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycgJiYgY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgPT09IGRvY3VtZW50KSBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgICAgcmVjdC50b3AgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICByZWN0LmxlZnQgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBnaG9zdEVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdib3gtc2l6aW5nJywgJ2JvcmRlci1ib3gnKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtYXJnaW4nLCAwKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnb3BhY2l0eScsICcwLjgnKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdwb3NpdGlvbicsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ID8gJ2Fic29sdXRlJyA6ICdmaXhlZCcpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcbiAgICAgICAgU29ydGFibGUuZ2hvc3QgPSBnaG9zdEVsO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2hvc3RFbCk7IC8vIFNldCB0cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0tb3JpZ2luJywgdGFwRGlzdGFuY2VMZWZ0IC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS53aWR0aCkgKiAxMDAgKyAnJSAnICsgdGFwRGlzdGFuY2VUb3AgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLmhlaWdodCkgKiAxMDAgKyAnJScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfb25EcmFnU3RhcnQoXG4gICAgLyoqRXZlbnQqL1xuICAgIGV2dCxcbiAgICAvKipib29sZWFuKi9cbiAgICBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGV2dC5kYXRhVHJhbnNmZXI7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0JywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGx1Z2luRXZlbnQoJ3NldHVwQ2xvbmUnLCB0aGlzKTtcblxuICAgICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgIGNsb25lRWwgPSBjbG9uZShkcmFnRWwpO1xuICAgICAgICBjbG9uZUVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBjbG9uZUVsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG5cbiAgICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoY2xvbmVFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICAgIFNvcnRhYmxlLmNsb25lID0gY2xvbmVFbDtcbiAgICAgIH0gLy8gIzExNDM6IElGcmFtZSBzdXBwb3J0IHdvcmthcm91bmRcblxuXG4gICAgICBfdGhpcy5jbG9uZUlkID0gX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2Nsb25lJywgX3RoaXMpO1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIG5hbWU6ICdjbG9uZSdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTsgLy8gU2V0IHByb3BlciBkcm9wIGV2ZW50c1xuXG4gICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgaWdub3JlTmV4dENsaWNrID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX2xvb3BJZCA9IHNldEludGVydmFsKF90aGlzLl9lbXVsYXRlRHJhZ092ZXIsIDUwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVuZG8gd2hhdCB3YXMgc2V0IGluIF9wcmVwYXJlRHJhZ1N0YXJ0IGJlZm9yZSBkcmFnIHN0YXJ0ZWRcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApO1xuXG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcbiAgICAgICAgICBvcHRpb25zLnNldERhdGEgJiYgb3B0aW9ucy5zZXREYXRhLmNhbGwoX3RoaXMsIGRhdGFUcmFuc2ZlciwgZHJhZ0VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJvcCcsIF90aGlzKTsgLy8gIzEyNzYgZml4OlxuXG4gICAgICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgIF90aGlzLl9kcmFnU3RhcnRJZCA9IF9uZXh0VGljayhfdGhpcy5fZHJhZ1N0YXJ0ZWQuYmluZChfdGhpcywgZmFsbGJhY2ssIGV2dCkpO1xuICAgICAgb24oZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIF90aGlzKTtcbiAgICAgIG1vdmVkID0gdHJ1ZTtcblxuICAgICAgaWYgKFNhZmFyaSkge1xuICAgICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJ25vbmUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFJldHVybnMgdHJ1ZSAtIGlmIG5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lZWRlZCAoZWl0aGVyIGluc2VydGVkIG9yIGFub3RoZXIgY29uZGl0aW9uKVxuICAgIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiBfb25EcmFnT3ZlcihcbiAgICAvKipFdmVudCovXG4gICAgZXZ0KSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgICAgZHJhZ1JlY3QsXG4gICAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgICByZXZlcnQsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBncm91cCA9IG9wdGlvbnMuZ3JvdXAsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBTb3J0YWJsZS5hY3RpdmUsXG4gICAgICAgICAgaXNPd25lciA9IGFjdGl2ZUdyb3VwID09PSBncm91cCxcbiAgICAgICAgICBjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0LFxuICAgICAgICAgIGZyb21Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgIHZlcnRpY2FsLFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBjb21wbGV0ZWRGaXJlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoX3NpbGVudCkgcmV0dXJuO1xuXG4gICAgICBmdW5jdGlvbiBkcmFnT3ZlckV2ZW50KG5hbWUsIGV4dHJhKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KG5hbWUsIF90aGlzLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICBpc093bmVyOiBpc093bmVyLFxuICAgICAgICAgIGF4aXM6IHZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICByZXZlcnQ6IHJldmVydCxcbiAgICAgICAgICBkcmFnUmVjdDogZHJhZ1JlY3QsXG4gICAgICAgICAgdGFyZ2V0UmVjdDogdGFyZ2V0UmVjdCxcbiAgICAgICAgICBjYW5Tb3J0OiBjYW5Tb3J0LFxuICAgICAgICAgIGZyb21Tb3J0YWJsZTogZnJvbVNvcnRhYmxlLFxuICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICAgIG9uTW92ZTogZnVuY3Rpb24gb25Nb3ZlKHRhcmdldCwgYWZ0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgZ2V0UmVjdCh0YXJnZXQpLCBldnQsIGFmdGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYW5nZWQ6IGNoYW5nZWRcbiAgICAgICAgfSwgZXh0cmEpKTtcbiAgICAgIH0gLy8gQ2FwdHVyZSBhbmltYXRpb24gc3RhdGVcblxuXG4gICAgICBmdW5jdGlvbiBjYXB0dXJlKCkge1xuICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUnKTtcblxuICAgICAgICBfdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICBpZiAoX3RoaXMgIT09IGZyb21Tb3J0YWJsZSkge1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXR1cm4gaW52b2NhdGlvbiB3aGVuIGRyYWdFbCBpcyBpbnNlcnRlZCAob3IgY29tcGxldGVkKVxuXG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlZChpbnNlcnRpb24pIHtcbiAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJDb21wbGV0ZWQnLCB7XG4gICAgICAgICAgaW5zZXJ0aW9uOiBpbnNlcnRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShfdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICAgIC8vIFNldCBnaG9zdCBjbGFzcyB0byBuZXcgc29ydGFibGUncyBnaG9zdCBjbGFzc1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwdXRTb3J0YWJsZSAhPT0gX3RoaXMgJiYgX3RoaXMgIT09IFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgICAgcHV0U29ydGFibGUgPSBfdGhpcztcbiAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzID09PSBTb3J0YWJsZS5hY3RpdmUgJiYgcHV0U29ydGFibGUpIHtcbiAgICAgICAgICAgIHB1dFNvcnRhYmxlID0gbnVsbDtcbiAgICAgICAgICB9IC8vIEFuaW1hdGlvblxuXG5cbiAgICAgICAgICBpZiAoZnJvbVNvcnRhYmxlID09PSBfdGhpcykge1xuICAgICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gdGFyZ2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZScpO1xuICAgICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgICBmcm9tU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgICAgZnJvbVNvcnRhYmxlLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE51bGwgbGFzdFRhcmdldCBpZiBpdCBpcyBub3QgaW5zaWRlIGEgcHJldmlvdXNseSBzd2FwcGVkIGVsZW1lbnRcblxuXG4gICAgICAgIGlmICh0YXJnZXQgPT09IGRyYWdFbCAmJiAhZHJhZ0VsLmFuaW1hdGVkIHx8IHRhcmdldCA9PT0gZWwgJiYgIXRhcmdldC5hbmltYXRlZCkge1xuICAgICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgICB9IC8vIG5vIGJ1YmJsaW5nIGFuZCBub3QgZmFsbGJhY2tcblxuXG4gICAgICAgIGlmICghb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiAhZXZ0LnJvb3RFbCAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTsgLy8gRG8gbm90IGRldGVjdCBmb3IgZW1wdHkgaW5zZXJ0IGlmIGFscmVhZHkgaW5zZXJ0ZWRcblxuXG4gICAgICAgICAgIWluc2VydGlvbiAmJiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWRGaXJlZCA9IHRydWU7XG4gICAgICB9IC8vIENhbGwgd2hlbiBkcmFnRWwgaGFzIGJlZW4gaW5zZXJ0ZWRcblxuXG4gICAgICBmdW5jdGlvbiBjaGFuZ2VkKCkge1xuICAgICAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gaW5kZXgoZHJhZ0VsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2hhbmdlJyxcbiAgICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgICBuZXdJbmRleDogbmV3SW5kZXgsXG4gICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyJyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgICBpZiAoZHJhZ0VsLmNvbnRhaW5zKGV2dC50YXJnZXQpIHx8IHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQuYW5pbWF0aW5nWCAmJiB0YXJnZXQuYW5pbWF0aW5nWSB8fCBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG5cbiAgICAgIGlmIChhY3RpdmVTb3J0YWJsZSAmJiAhb3B0aW9ucy5kaXNhYmxlZCAmJiAoaXNPd25lciA/IGNhblNvcnQgfHwgKHJldmVydCA9ICFyb290RWwuY29udGFpbnMoZHJhZ0VsKSkgLy8gUmV2ZXJ0aW5nIGl0ZW0gaW50byB0aGUgb3JpZ2luYWwgbGlzdFxuICAgICAgOiBwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fCAodGhpcy5sYXN0UHV0TW9kZSA9IGFjdGl2ZUdyb3VwLmNoZWNrUHVsbCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSAmJiBncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSkge1xuICAgICAgICB2ZXJ0aWNhbCA9IHRoaXMuX2dldERpcmVjdGlvbihldnQsIHRhcmdldCkgPT09ICd2ZXJ0aWNhbCc7XG4gICAgICAgIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwpO1xuICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlclZhbGlkJyk7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICAgICAgaWYgKHJldmVydCkge1xuICAgICAgICAgIHBhcmVudEVsID0gcm9vdEVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgICAgIGRyYWdPdmVyRXZlbnQoJ3JldmVydCcpO1xuXG4gICAgICAgICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgICBpZiAobmV4dEVsKSB7XG4gICAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0RWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbExhc3RDaGlsZCA9IGxhc3RDaGlsZChlbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICAgIGlmICghZWxMYXN0Q2hpbGQgfHwgX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHRoaXMpICYmICFlbExhc3RDaGlsZC5hbmltYXRlZCkge1xuICAgICAgICAgIC8vIElmIGFscmVhZHkgYXQgZW5kIG9mIGxpc3Q6IERvIG5vdCBpbnNlcnRcbiAgICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgICAgfSAvLyBhc3NpZ24gdGFyZ2V0IG9ubHkgaWYgY29uZGl0aW9uIGlzIHRydWVcblxuXG4gICAgICAgICAgaWYgKGVsTGFzdENoaWxkICYmIGVsID09PSBldnQudGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBlbExhc3RDaGlsZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCAhIXRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcbiAgICAgICAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCh0YXJnZXQpO1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSAwLFxuICAgICAgICAgICAgICB0YXJnZXRCZWZvcmVGaXJzdFN3YXAsXG4gICAgICAgICAgICAgIGRpZmZlcmVudExldmVsID0gZHJhZ0VsLnBhcmVudE5vZGUgIT09IGVsLFxuICAgICAgICAgICAgICBkaWZmZXJlbnRSb3dDb2wgPSAhX2RyYWdFbEluUm93Q29sdW1uKGRyYWdFbC5hbmltYXRlZCAmJiBkcmFnRWwudG9SZWN0IHx8IGRyYWdSZWN0LCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LnRvUmVjdCB8fCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCksXG4gICAgICAgICAgICAgIHNpZGUxID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgICAgc2Nyb2xsZWRQYXN0VG9wID0gaXNTY3JvbGxlZFBhc3QodGFyZ2V0LCAndG9wJywgJ3RvcCcpIHx8IGlzU2Nyb2xsZWRQYXN0KGRyYWdFbCwgJ3RvcCcsICd0b3AnKSxcbiAgICAgICAgICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsZWRQYXN0VG9wID8gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCA6IHZvaWQgMDtcblxuICAgICAgICAgIGlmIChsYXN0VGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCA9IHRhcmdldFJlY3Rbc2lkZTFdO1xuICAgICAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gIWRpZmZlcmVudFJvd0NvbCAmJiBvcHRpb25zLmludmVydFN3YXAgfHwgZGlmZmVyZW50TGV2ZWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBkaWZmZXJlbnRSb3dDb2wgPyAxIDogb3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQsIGxhc3RUYXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgICAgdmFyIHNpYmxpbmc7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYmVzaWRlIGRyYWdFbCBpbiByZXNwZWN0aXZlIGRpcmVjdGlvbiAoaWdub3JpbmcgaGlkZGVuIGVsZW1lbnRzKVxuICAgICAgICAgICAgdmFyIGRyYWdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgZHJhZ0luZGV4IC09IGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudEVsLmNoaWxkcmVuW2RyYWdJbmRleF07XG4gICAgICAgICAgICB9IHdoaWxlIChzaWJsaW5nICYmIChjc3Moc2libGluZywgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNpYmxpbmcgPT09IGdob3N0RWwpKTtcbiAgICAgICAgICB9IC8vIElmIGRyYWdFbCBpcyBhbHJlYWR5IGJlc2lkZSB0YXJnZXQ6IERvIG5vdCBpbnNlcnRcblxuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCB8fCBzaWJsaW5nID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3RUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgICBhZnRlciA9IGZhbHNlO1xuICAgICAgICAgIGFmdGVyID0gZGlyZWN0aW9uID09PSAxO1xuXG4gICAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XG5cbiAgICAgICAgICBpZiAobW92ZVZlY3RvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGFmdGVyID0gbW92ZVZlY3RvciA9PT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NpbGVudCA9IHRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KF91bnNpbGVudCwgMzApO1xuICAgICAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgICAgICBpZiAoYWZ0ZXIgJiYgIW5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBhZnRlciA/IG5leHRTaWJsaW5nIDogdGFyZ2V0KTtcbiAgICAgICAgICAgIH0gLy8gVW5kbyBjaHJvbWUncyBzY3JvbGwgYWRqdXN0bWVudCAoaGFzIG5vIGVmZmVjdCBvbiBvdGhlciBicm93c2VycylcblxuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsZWRQYXN0VG9wKSB7XG4gICAgICAgICAgICAgIHNjcm9sbEJ5KHNjcm9sbGVkUGFzdFRvcCwgMCwgc2Nyb2xsQmVmb3JlIC0gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7IC8vIGFjdHVhbGl6YXRpb25cbiAgICAgICAgICAgIC8vIG11c3QgYmUgZG9uZSBiZWZvcmUgYW5pbWF0aW9uXG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgIT09IHVuZGVmaW5lZCAmJiAhaXNDaXJjdW1zdGFudGlhbEludmVydCkge1xuICAgICAgICAgICAgICB0YXJnZXRNb3ZlRGlzdGFuY2UgPSBNYXRoLmFicyh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgLSBnZXRSZWN0KHRhcmdldClbc2lkZTFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwuY29udGFpbnMoZHJhZ0VsKSkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9pZ25vcmVXaGlsZUFuaW1hdGluZzogbnVsbCxcbiAgICBfb2ZmTW92ZUV2ZW50czogZnVuY3Rpb24gX29mZk1vdmVFdmVudHMoKSB7XG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIH0sXG4gICAgX29mZlVwRXZlbnRzOiBmdW5jdGlvbiBfb2ZmVXBFdmVudHMoKSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAnc2VsZWN0c3RhcnQnLCB0aGlzKTtcbiAgICB9LFxuICAgIF9vbkRyb3A6IGZ1bmN0aW9uIF9vbkRyb3AoXG4gICAgLyoqRXZlbnQqL1xuICAgIGV2dCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICAgIHBsdWdpbkV2ZW50KCdkcm9wJywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7XG4gICAgICBwYXJlbnRFbCA9IGRyYWdFbCAmJiBkcmFnRWwucGFyZW50Tm9kZTsgLy8gR2V0IGFnYWluIGFmdGVyIHBsdWdpbiBldmVudFxuXG4gICAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9udWxsaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2U7XG4gICAgICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLmNsb25lSWQpO1xuXG4gICAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5fZHJhZ1N0YXJ0SWQpOyAvLyBVbmJpbmQgZXZlbnRzXG5cblxuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2Ryb3AnLCB0aGlzKTtcbiAgICAgICAgb2ZmKGVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vZmZNb3ZlRXZlbnRzKCk7XG5cbiAgICAgIHRoaXMuX29mZlVwRXZlbnRzKCk7XG5cbiAgICAgIGlmIChTYWZhcmkpIHtcbiAgICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICcnKTtcbiAgICAgIH1cblxuICAgICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICcnKTtcblxuICAgICAgaWYgKGV2dCkge1xuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAhb3B0aW9ucy5kcm9wQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcblxuICAgICAgICBpZiAocm9vdEVsID09PSBwYXJlbnRFbCB8fCBwdXRTb3J0YWJsZSAmJiBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBjbG9uZShzKVxuICAgICAgICAgIGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIG9mZihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcblxuICAgICAgICAgIGRyYWdFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnOyAvLyBSZW1vdmUgY2xhc3Nlc1xuICAgICAgICAgIC8vIGdob3N0Q2xhc3MgaXMgYWRkZWQgaW4gZHJhZ1N0YXJ0ZWRcblxuICAgICAgICAgIGlmIChtb3ZlZCAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IHRoaXMub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTsgLy8gRHJhZyBzdG9wIGV2ZW50XG5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgIG5hbWU6ICd1bmNob29zZScsXG4gICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgIG5ld0luZGV4OiBudWxsLFxuICAgICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChyb290RWwgIT09IHBhcmVudEVsKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAvLyBBZGQgZXZlbnRcbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FkZCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgZnJvbUVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pOyAvLyBSZW1vdmUgZXZlbnRcblxuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7IC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcblxuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ICE9PSBvbGRJbmRleCkge1xuICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGRyYWcgJiBkcm9wIHdpdGhpbiB0aGUgc2FtZSBsaXN0XG4gICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgICBuYW1lOiAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoU29ydGFibGUuYWN0aXZlKSB7XG4gICAgICAgICAgICAvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PSBudWxsIHx8IG5ld0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICBuZXdJbmRleCA9IG9sZEluZGV4O1xuICAgICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAnZW5kJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIFNhdmUgc29ydGluZ1xuXG5cbiAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgfSxcbiAgICBfbnVsbGluZzogZnVuY3Rpb24gX251bGxpbmcoKSB7XG4gICAgICBwbHVnaW5FdmVudCgnbnVsbGluZycsIHRoaXMpO1xuICAgICAgcm9vdEVsID0gZHJhZ0VsID0gcGFyZW50RWwgPSBnaG9zdEVsID0gbmV4dEVsID0gY2xvbmVFbCA9IGxhc3REb3duRWwgPSBjbG9uZUhpZGRlbiA9IHRhcEV2dCA9IHRvdWNoRXZ0ID0gbW92ZWQgPSBuZXdJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleCA9IGxhc3RUYXJnZXQgPSBsYXN0RGlyZWN0aW9uID0gcHV0U29ydGFibGUgPSBhY3RpdmVHcm91cCA9IFNvcnRhYmxlLmRyYWdnZWQgPSBTb3J0YWJsZS5naG9zdCA9IFNvcnRhYmxlLmNsb25lID0gU29ydGFibGUuYWN0aXZlID0gbnVsbDtcbiAgICAgIHNhdmVkSW5wdXRDaGVja2VkLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSBsYXN0RHggPSBsYXN0RHkgPSAwO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KFxuICAgIC8qKkV2ZW50Ki9cbiAgICBldnQpIHtcbiAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZHJvcCc6XG4gICAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICAgIHRoaXMuX29uRHJvcChldnQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZHJhZ2VudGVyJzpcbiAgICAgICAgY2FzZSAnZHJhZ292ZXInOlxuICAgICAgICAgIGlmIChkcmFnRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcblxuICAgICAgICAgICAgX2dsb2JhbERyYWdPdmVyKGV2dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0c3RhcnQnOlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIG9yZGVyID0gW10sXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmVsLmNoaWxkcmVuLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZWwgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAoY2xvc2VzdChlbCwgb3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKSkge1xuICAgICAgICAgIG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGFycmF5LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ1tdfSAgb3JkZXIgIG9yZGVyIG9mIHRoZSBpdGVtc1xuICAgICAqL1xuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQob3JkZXIpIHtcbiAgICAgIHZhciBpdGVtcyA9IHt9LFxuICAgICAgICAgIHJvb3RFbCA9IHRoaXMuZWw7XG4gICAgICB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgICB2YXIgZWwgPSByb290RWwuY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgICAgaXRlbXNbaWRdID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGl0ZW1zW2lkXSkge1xuICAgICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXG4gICAgICovXG4gICAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgIHZhciBzdG9yZSA9IHRoaXMub3B0aW9ucy5zdG9yZTtcbiAgICAgIHN0b3JlICYmIHN0b3JlLnNldCAmJiBzdG9yZS5zZXQodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgZ2V0IHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IgYnkgdGVzdGluZyB0aGUgZWxlbWVudCBpdHNlbGYgYW5kIHRyYXZlcnNpbmcgdXAgdGhyb3VnaCBpdHMgYW5jZXN0b3JzIGluIHRoZSBET00gdHJlZS5cbiAgICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbFxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgIFtzZWxlY3Rvcl0gIGRlZmF1bHQ6IGBvcHRpb25zLmRyYWdnYWJsZWBcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICAgKi9cbiAgICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0JDEoZWwsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gY2xvc2VzdChlbCwgc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQvZ2V0IG9wdGlvblxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgb3B0aW9uOiBmdW5jdGlvbiBvcHRpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1tuYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gUGx1Z2luTWFuYWdlci5tb2RpZnlPcHRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZWRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvcHRpb25zW25hbWVdID0gbW9kaWZpZWRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBwbHVnaW5FdmVudCgnZGVzdHJveScsIHRoaXMpO1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICAgIG9mZihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgICAgb2ZmKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgICAgb2ZmKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgICAgIG9mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICAgICAgfSAvLyBSZW1vdmUgZHJhZ2dhYmxlIGF0dHJpYnV0ZXNcblxuXG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkcmFnZ2FibGVdJyksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgICAgc29ydGFibGVzLnNwbGljZShzb3J0YWJsZXMuaW5kZXhPZih0aGlzLmVsKSwgMSk7XG4gICAgICB0aGlzLmVsID0gZWwgPSBudWxsO1xuICAgIH0sXG4gICAgX2hpZGVDbG9uZTogZnVuY3Rpb24gX2hpZGVDbG9uZSgpIHtcbiAgICAgIGlmICghY2xvbmVIaWRkZW4pIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2hpZGVDbG9uZScsIHRoaXMpO1xuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICBjc3MoY2xvbmVFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3Nob3dDbG9uZTogZnVuY3Rpb24gX3Nob3dDbG9uZShwdXRTb3J0YWJsZSkge1xuICAgICAgaWYgKHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsb25lSGlkZGVuKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdzaG93Q2xvbmUnLCB0aGlzKTtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjsgLy8gc2hvdyBjbG9uZSBhdCBkcmFnRWwgb3Igb3JpZ2luYWwgcG9zaXRpb25cblxuICAgICAgICBpZiAocm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkgJiYgIXRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIG5leHRFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZShkcmFnRWwsIGNsb25lRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgICBjbG9uZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBfZ2xvYmFsRHJhZ092ZXIoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgaWYgKGV2dC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgICB9XG5cbiAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vbk1vdmUoZnJvbUVsLCB0b0VsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXRFbCwgdGFyZ2V0UmVjdCwgb3JpZ2luYWxFdmVudCwgd2lsbEluc2VydEFmdGVyKSB7XG4gICAgdmFyIGV2dCxcbiAgICAgICAgc29ydGFibGUgPSBmcm9tRWxbZXhwYW5kb10sXG4gICAgICAgIG9uTW92ZUZuID0gc29ydGFibGUub3B0aW9ucy5vbk1vdmUsXG4gICAgICAgIHJldFZhbDsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudCgnbW92ZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudCgnbW92ZScsIHRydWUsIHRydWUpO1xuICAgIH1cblxuICAgIGV2dC50byA9IHRvRWw7XG4gICAgZXZ0LmZyb20gPSBmcm9tRWw7XG4gICAgZXZ0LmRyYWdnZWQgPSBkcmFnRWw7XG4gICAgZXZ0LmRyYWdnZWRSZWN0ID0gZHJhZ1JlY3Q7XG4gICAgZXZ0LnJlbGF0ZWQgPSB0YXJnZXRFbCB8fCB0b0VsO1xuICAgIGV2dC5yZWxhdGVkUmVjdCA9IHRhcmdldFJlY3QgfHwgZ2V0UmVjdCh0b0VsKTtcbiAgICBldnQud2lsbEluc2VydEFmdGVyID0gd2lsbEluc2VydEFmdGVyO1xuICAgIGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICBmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgaWYgKG9uTW92ZUZuKSB7XG4gICAgICByZXRWYWwgPSBvbk1vdmVGbi5jYWxsKHNvcnRhYmxlLCBldnQsIG9yaWdpbmFsRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xuICAgIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xuICAgIF9zaWxlbnQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICAgIHZhciByZWN0ID0gZ2V0UmVjdChsYXN0Q2hpbGQoc29ydGFibGUuZWwsIHNvcnRhYmxlLm9wdGlvbnMuZHJhZ2dhYmxlKSk7XG4gICAgdmFyIHNwYWNlciA9IDEwO1xuICAgIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCArIHNwYWNlciB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPj0gcmVjdC5sZWZ0IDogZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC50b3AgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICsgc3BhY2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBzd2FwVGhyZXNob2xkLCBpbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGludmVydFN3YXAsIGlzTGFzdFRhcmdldCkge1xuICAgIHZhciBtb3VzZU9uQXhpcyA9IHZlcnRpY2FsID8gZXZ0LmNsaWVudFkgOiBldnQuY2xpZW50WCxcbiAgICAgICAgdGFyZ2V0TGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmhlaWdodCA6IHRhcmdldFJlY3Qud2lkdGgsXG4gICAgICAgIHRhcmdldFMxID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LnRvcCA6IHRhcmdldFJlY3QubGVmdCxcbiAgICAgICAgdGFyZ2V0UzIgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuYm90dG9tIDogdGFyZ2V0UmVjdC5yaWdodCxcbiAgICAgICAgaW52ZXJ0ID0gZmFsc2U7XG5cbiAgICBpZiAoIWludmVydFN3YXApIHtcbiAgICAgIC8vIE5ldmVyIGludmVydCBvciBjcmVhdGUgZHJhZ0VsIHNoYWRvdyB3aGVuIHRhcmdldCBtb3ZlbWVuZXQgY2F1c2VzIG1vdXNlIHRvIG1vdmUgcGFzdCB0aGUgZW5kIG9mIHJlZ3VsYXIgc3dhcFRocmVzaG9sZFxuICAgICAgaWYgKGlzTGFzdFRhcmdldCAmJiB0YXJnZXRNb3ZlRGlzdGFuY2UgPCB0YXJnZXRMZW5ndGggKiBzd2FwVGhyZXNob2xkKSB7XG4gICAgICAgIC8vIG11bHRpcGxpZWQgb25seSBieSBzd2FwVGhyZXNob2xkIGJlY2F1c2UgbW91c2Ugd2lsbCBhbHJlYWR5IGJlIGluc2lkZSB0YXJnZXQgYnkgKDEgLSB0aHJlc2hvbGQpICogdGFyZ2V0TGVuZ3RoIC8gMlxuICAgICAgICAvLyBjaGVjayBpZiBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQgb24gc2lkZSBvcHBvc2l0ZSBvZiBsYXN0RGlyZWN0aW9uXG4gICAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoICYmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgOiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikpIHtcbiAgICAgICAgICAvLyBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQsIGRvIG5vdCByZXN0cmljdCBpbnZlcnRlZCB0aHJlc2hvbGQgdG8gZHJhZ0VsIHNoYWRvd1xuICAgICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCkge1xuICAgICAgICAgIC8vIGRyYWdFbCBzaGFkb3cgKHRhcmdldCBtb3ZlIGRpc3RhbmNlIHNoYWRvdylcbiAgICAgICAgICBpZiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRNb3ZlRGlzdGFuY2UgLy8gb3ZlciBkcmFnRWwgc2hhZG93XG4gICAgICAgICAgOiBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TW92ZURpc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gLWxhc3REaXJlY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludmVydCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlZ3VsYXJcbiAgICAgICAgaWYgKG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMiAmJiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIpIHtcbiAgICAgICAgICByZXR1cm4gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52ZXJ0ID0gaW52ZXJ0IHx8IGludmVydFN3YXA7XG5cbiAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAvLyBJbnZlcnQgb2YgcmVndWxhclxuICAgICAgaWYgKG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIHx8IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSB7XG4gICAgICAgIHJldHVybiBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoIC8gMiA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcbiAgICogc2VlbSB0aGF0IGRyYWdFbCBoYXMgYmVlbiBcImluc2VydGVkXCIgaW50byB0aGF0IGVsZW1lbnQncyBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgICAgIFRoZSB0YXJnZXQgd2hvc2UgcG9zaXRpb24gZHJhZ0VsIGlzIGJlaW5nIGluc2VydGVkIGF0XG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcbiAgICovXG5cblxuICBmdW5jdGlvbiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCkge1xuICAgIGlmIChpbmRleChkcmFnRWwpIDwgaW5kZXgodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGlkXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICAgIHZhciBzdHIgPSBlbC50YWdOYW1lICsgZWwuY2xhc3NOYW1lICsgZWwuc3JjICsgZWwuaHJlZiArIGVsLnRleHRDb250ZW50LFxuICAgICAgICBpID0gc3RyLmxlbmd0aCxcbiAgICAgICAgc3VtID0gMDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHN1bSArPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtLnRvU3RyaW5nKDM2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IDA7XG4gICAgdmFyIGlucHV0cyA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG4gICAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaWR4LS0pIHtcbiAgICAgIHZhciBlbCA9IGlucHV0c1tpZHhdO1xuICAgICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfbmV4dFRpY2soZm4pIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbiAgfSAvLyBGaXhlZCAjOTczOlxuXG5cbiAgaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAoKFNvcnRhYmxlLmFjdGl2ZSB8fCBhd2FpdGluZ0RyYWdTdGFydGVkKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBFeHBvcnQgdXRpbHNcblxuXG4gIFNvcnRhYmxlLnV0aWxzID0ge1xuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgICBjc3M6IGNzcyxcbiAgICBmaW5kOiBmaW5kLFxuICAgIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAhIWNsb3Nlc3QoZWwsIHNlbGVjdG9yLCBlbCwgZmFsc2UpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICAgIGNsb25lOiBjbG9uZSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgICBjYW5jZWxOZXh0VGljazogX2NhbmNlbE5leHRUaWNrLFxuICAgIGRldGVjdERpcmVjdGlvbjogX2RldGVjdERpcmVjdGlvbixcbiAgICBnZXRDaGlsZDogZ2V0Q2hpbGRcbiAgfTtcbiAgLyoqXG4gICAqIEdldCB0aGUgU29ydGFibGUgaW5zdGFuY2Ugb2YgYW4gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtTb3J0YWJsZXx1bmRlZmluZWR9ICAgICAgICAgVGhlIGluc3RhbmNlIG9mIFNvcnRhYmxlXG4gICAqL1xuXG4gIFNvcnRhYmxlLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnRbZXhwYW5kb107XG4gIH07XG4gIC8qKlxuICAgKiBNb3VudCBhIHBsdWdpbiB0byBTb3J0YWJsZVxuICAgKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxuICAgKi9cblxuXG4gIFNvcnRhYmxlLm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luc1swXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXBsdWdpbi5wcm90b3R5cGUgfHwgIXBsdWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgXCJTb3J0YWJsZTogTW91bnRlZCBwbHVnaW4gbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwocGx1Z2luKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwbHVnaW4udXRpbHMpIFNvcnRhYmxlLnV0aWxzID0gX29iamVjdFNwcmVhZCh7fSwgU29ydGFibGUudXRpbHMsIHBsdWdpbi51dGlscyk7XG4gICAgICBQbHVnaW5NYW5hZ2VyLm1vdW50KHBsdWdpbik7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGUgc29ydGFibGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gIGVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRpb25zXVxuICAgKi9cblxuXG4gIFNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xuICB9OyAvLyBFeHBvcnRcblxuXG4gIFNvcnRhYmxlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gIHZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgICAgc2Nyb2xsRWwsXG4gICAgICBzY3JvbGxSb290RWwsXG4gICAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICAgIGxhc3RBdXRvU2Nyb2xsWCxcbiAgICAgIGxhc3RBdXRvU2Nyb2xsWSxcbiAgICAgIHRvdWNoRXZ0JDEsXG4gICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbDtcblxuICBmdW5jdGlvbiBBdXRvU2Nyb2xsUGx1Z2luKCkge1xuICAgIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgICBzY3JvbGw6IHRydWUsXG4gICAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgICAgc2Nyb2xsU3BlZWQ6IDEwLFxuICAgICAgICBidWJibGVTY3JvbGw6IHRydWVcbiAgICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBBdXRvU2Nyb2xsLnByb3RvdHlwZSA9IHtcbiAgICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgIGlmICh0aGlzLnNvcnRhYmxlLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJhZ092ZXJDb21wbGV0ZWQ6IGZ1bmN0aW9uIGRyYWdPdmVyQ29tcGxldGVkKF9yZWYyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZjIub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kcmFnT3ZlckJ1YmJsZSAmJiAhb3JpZ2luYWxFdmVudC5yb290RWwpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpO1xuICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgICB9LFxuICAgICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgICBhdXRvU2Nyb2xscy5sZW5ndGggPSAwO1xuICAgICAgfSxcbiAgICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgdG91Y2hFdnQkMSA9IGV2dDsgLy8gSUUgZG9lcyBub3Qgc2VlbSB0byBoYXZlIG5hdGl2ZSBhdXRvc2Nyb2xsLFxuICAgICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAgIC8vIE1BQ09TIFNhZmFyaSBkb2VzIG5vdCBoYXZlIGF1dG9zY3JvbGwsXG4gICAgICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBhcmUgZ29vZFxuXG4gICAgICAgIGlmIChmYWxsYmFjayB8fCBFZGdlIHx8IElFMTFPckxlc3MgfHwgU2FmYXJpKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZWxlbSwgZmFsbGJhY2spOyAvLyBMaXN0ZW5lciBmb3IgcG9pbnRlciBlbGVtZW50IGNoYW5nZVxuXG4gICAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsaW5nICYmICghcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgfHwgeCAhPT0gbGFzdEF1dG9TY3JvbGxYIHx8IHkgIT09IGxhc3RBdXRvU2Nyb2xsWSkpIHtcbiAgICAgICAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsICYmIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTsgLy8gRGV0ZWN0IGZvciBwb2ludGVyIGVsZW0gY2hhbmdlLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcblxuICAgICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdFbGVtID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKG5ld0VsZW0gIT09IG9nRWxlbVNjcm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICBsYXN0QXV0b1Njcm9sbFggPSB4O1xuICAgICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYnViYmxlU2Nyb2xsIHx8IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCBmYWxzZSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzKEF1dG9TY3JvbGwsIHtcbiAgICAgIHBsdWdpbk5hbWU6ICdzY3JvbGwnLFxuICAgICAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJBdXRvU2Nyb2xscygpIHtcbiAgICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGwucGlkKTtcbiAgICB9KTtcbiAgICBhdXRvU2Nyb2xscyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpIHtcbiAgICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbiAgfVxuXG4gIHZhciBhdXRvU2Nyb2xsID0gdGhyb3R0bGUoZnVuY3Rpb24gKGV2dCwgb3B0aW9ucywgcm9vdEVsLCBpc0ZhbGxiYWNrKSB7XG4gICAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgICBpZiAoIW9wdGlvbnMuc2Nyb2xsKSByZXR1cm47XG4gICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgICBzZW5zID0gb3B0aW9ucy5zY3JvbGxTZW5zaXRpdml0eSxcbiAgICAgICAgc3BlZWQgPSBvcHRpb25zLnNjcm9sbFNwZWVkLFxuICAgICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICB2YXIgc2Nyb2xsVGhpc0luc3RhbmNlID0gZmFsc2UsXG4gICAgICAgIHNjcm9sbEN1c3RvbUZuOyAvLyBOZXcgc2Nyb2xsIHJvb3QsIHNldCBzY3JvbGxFbFxuXG4gICAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgICBzY3JvbGxSb290RWwgPSByb290RWw7XG4gICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgICAgc2Nyb2xsQ3VzdG9tRm4gPSBvcHRpb25zLnNjcm9sbEZuO1xuXG4gICAgICBpZiAoc2Nyb2xsRWwgPT09IHRydWUpIHtcbiAgICAgICAgc2Nyb2xsRWwgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChyb290RWwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYXllcnNPdXQgPSAwO1xuICAgIHZhciBjdXJyZW50UGFyZW50ID0gc2Nyb2xsRWw7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgICAgIHJlY3QgPSBnZXRSZWN0KGVsKSxcbiAgICAgICAgICB0b3AgPSByZWN0LnRvcCxcbiAgICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICAgIHJpZ2h0ID0gcmVjdC5yaWdodCxcbiAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICAgICAgY2FuU2Nyb2xsWCA9IHZvaWQgMCxcbiAgICAgICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgICAgIHNjcm9sbFdpZHRoID0gZWwuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gZWwuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgICBzY3JvbGxQb3NYID0gZWwuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBzY3JvbGxQb3NZID0gZWwuc2Nyb2xsVG9wO1xuXG4gICAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Zpc2libGUnKTtcbiAgICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyk7XG4gICAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdnggPSBjYW5TY3JvbGxYICYmIChNYXRoLmFicyhyaWdodCAtIHgpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWCArIHdpZHRoIDwgc2Nyb2xsV2lkdGgpIC0gKE1hdGguYWJzKGxlZnQgLSB4KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWCk7XG4gICAgICB2YXIgdnkgPSBjYW5TY3JvbGxZICYmIChNYXRoLmFicyhib3R0b20gLSB5KSA8PSBzZW5zICYmIHNjcm9sbFBvc1kgKyBoZWlnaHQgPCBzY3JvbGxIZWlnaHQpIC0gKE1hdGguYWJzKHRvcCAtIHkpIDw9IHNlbnMgJiYgISFzY3JvbGxQb3NZKTtcblxuICAgICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxheWVyc091dDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFhdXRvU2Nyb2xsc1tpXSkge1xuICAgICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggIT0gdnggfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSAhPSB2eSB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsICE9PSBlbCkge1xuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsID0gZWw7XG4gICAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSA9IHZ5O1xuICAgICAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGxzW2xheWVyc091dF0ucGlkKTtcblxuICAgICAgICBpZiAodnggIT0gMCB8fCB2eSAhPSAwKSB7XG4gICAgICAgICAgc2Nyb2xsVGhpc0luc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuXG4gICAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBlbXVsYXRlIGRyYWcgb3ZlciBkdXJpbmcgYXV0b3Njcm9sbCAoZmFsbGJhY2spLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcbiAgICAgICAgICAgIGlmIChpc0ZhbGxiYWNrICYmIHRoaXMubGF5ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WSA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgKiBzcGVlZCA6IDA7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsQ3VzdG9tRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgaWYgKHNjcm9sbEN1c3RvbUZuLmNhbGwoU29ydGFibGUuZHJhZ2dlZC5wYXJlbnROb2RlW2V4cGFuZG9dLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZLCBldnQsIHRvdWNoRXZ0JDEsIGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsKSAhPT0gJ2NvbnRpbnVlJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgICAgfS5iaW5kKHtcbiAgICAgICAgICAgIGxheWVyOiBsYXllcnNPdXRcbiAgICAgICAgICB9KSwgMjQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxheWVyc091dCsrO1xuICAgIH0gd2hpbGUgKG9wdGlvbnMuYnViYmxlU2Nyb2xsICYmIGN1cnJlbnRQYXJlbnQgIT09IHdpblNjcm9sbGVyICYmIChjdXJyZW50UGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoY3VycmVudFBhcmVudCwgZmFsc2UpKSk7XG5cbiAgICBzY3JvbGxpbmcgPSBzY3JvbGxUaGlzSW5zdGFuY2U7IC8vIGluIGNhc2UgYW5vdGhlciBmdW5jdGlvbiBjYXRjaGVzIHNjcm9sbGluZyBhcyBmYWxzZSBpbiBiZXR3ZWVuIHdoZW4gaXQgaXMgbm90XG4gIH0sIDMwKTtcblxuICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoX3JlZikge1xuICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICAgIGRyYWdFbCA9IF9yZWYuZHJhZ0VsLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYuYWN0aXZlU29ydGFibGUsXG4gICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICBoaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICAgICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLnVuaGlkZUdob3N0Rm9yVGFyZ2V0O1xuICAgIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGU7XG4gICAgaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3NwaWxsJyk7XG4gICAgICB0aGlzLm9uU3BpbGwoe1xuICAgICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmV2ZXJ0KCkge31cblxuICBSZXZlcnQucHJvdG90eXBlID0ge1xuICAgIHN0YXJ0SW5kZXg6IG51bGwsXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiBkcmFnU3RhcnQoX3JlZjIpIHtcbiAgICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgdGhpcy5zdGFydEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgfSxcbiAgICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgICB2YXIgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsLFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjMucHV0U29ydGFibGU7XG4gICAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgICAgcHV0U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0U2libGluZyA9IGdldENoaWxkKHRoaXMuc29ydGFibGUuZWwsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb3J0YWJsZS5lbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcblxuICAgICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGRyb3BcbiAgfTtcblxuICBfZXh0ZW5kcyhSZXZlcnQsIHtcbiAgICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbiAgfSk7XG5cbiAgZnVuY3Rpb24gUmVtb3ZlKCkge31cblxuICBSZW1vdmUucHJvdG90eXBlID0ge1xuICAgIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjQpIHtcbiAgICAgIHZhciBkcmFnRWwgPSBfcmVmNC5kcmFnRWwsXG4gICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICAgIHZhciBwYXJlbnRTb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICBwYXJlbnRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgICBwYXJlbnRTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gICAgfSxcbiAgICBkcm9wOiBkcm9wXG4gIH07XG5cbiAgX2V4dGVuZHMoUmVtb3ZlLCB7XG4gICAgcGx1Z2luTmFtZTogJ3JlbW92ZU9uU3BpbGwnXG4gIH0pO1xuXG4gIHZhciBsYXN0U3dhcEVsO1xuXG4gIGZ1bmN0aW9uIFN3YXBQbHVnaW4oKSB7XG4gICAgZnVuY3Rpb24gU3dhcCgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICAgIHN3YXBDbGFzczogJ3NvcnRhYmxlLXN3YXAtaGlnaGxpZ2h0J1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBTd2FwLnByb3RvdHlwZSA9IHtcbiAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYpIHtcbiAgICAgICAgdmFyIGRyYWdFbCA9IF9yZWYuZHJhZ0VsO1xuICAgICAgICBsYXN0U3dhcEVsID0gZHJhZ0VsO1xuICAgICAgfSxcbiAgICAgIGRyYWdPdmVyVmFsaWQ6IGZ1bmN0aW9uIGRyYWdPdmVyVmFsaWQoX3JlZjIpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IF9yZWYyLmNvbXBsZXRlZCxcbiAgICAgICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgICAgIG9uTW92ZSA9IF9yZWYyLm9uTW92ZSxcbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjIuYWN0aXZlU29ydGFibGUsXG4gICAgICAgICAgICBjaGFuZ2VkID0gX3JlZjIuY2hhbmdlZCxcbiAgICAgICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgICAgaWYgKCFhY3RpdmVTb3J0YWJsZS5vcHRpb25zLnN3YXApIHJldHVybjtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgdmFyIHByZXZTd2FwRWwgPSBsYXN0U3dhcEVsO1xuXG4gICAgICAgICAgaWYgKG9uTW92ZSh0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBvcHRpb25zLnN3YXBDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICBsYXN0U3dhcEVsID0gdGFyZ2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0U3dhcEVsID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJldlN3YXBFbCAmJiBwcmV2U3dhcEVsICE9PSBsYXN0U3dhcEVsKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhwcmV2U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZWQoKTtcbiAgICAgICAgY29tcGxldGVkKHRydWUpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYzKSB7XG4gICAgICAgIHZhciBhY3RpdmVTb3J0YWJsZSA9IF9yZWYzLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZSxcbiAgICAgICAgICAgIGRyYWdFbCA9IF9yZWYzLmRyYWdFbDtcbiAgICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgbGFzdFN3YXBFbCAmJiB0b2dnbGVDbGFzcyhsYXN0U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuXG4gICAgICAgIGlmIChsYXN0U3dhcEVsICYmIChvcHRpb25zLnN3YXAgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUub3B0aW9ucy5zd2FwKSkge1xuICAgICAgICAgIGlmIChkcmFnRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgICAgc3dhcE5vZGVzKGRyYWdFbCwgbGFzdFN3YXBFbCk7XG4gICAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzKFN3YXAsIHtcbiAgICAgIHBsdWdpbk5hbWU6ICdzd2FwJyxcbiAgICAgIGV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZXZlbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN3YXBJdGVtOiBsYXN0U3dhcEVsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzd2FwTm9kZXMobjEsIG4yKSB7XG4gICAgdmFyIHAxID0gbjEucGFyZW50Tm9kZSxcbiAgICAgICAgcDIgPSBuMi5wYXJlbnROb2RlLFxuICAgICAgICBpMSxcbiAgICAgICAgaTI7XG4gICAgaWYgKCFwMSB8fCAhcDIgfHwgcDEuaXNFcXVhbE5vZGUobjIpIHx8IHAyLmlzRXF1YWxOb2RlKG4xKSkgcmV0dXJuO1xuICAgIGkxID0gaW5kZXgobjEpO1xuICAgIGkyID0gaW5kZXgobjIpO1xuXG4gICAgaWYgKHAxLmlzRXF1YWxOb2RlKHAyKSAmJiBpMSA8IGkyKSB7XG4gICAgICBpMisrO1xuICAgIH1cblxuICAgIHAxLmluc2VydEJlZm9yZShuMiwgcDEuY2hpbGRyZW5baTFdKTtcbiAgICBwMi5pbnNlcnRCZWZvcmUobjEsIHAyLmNoaWxkcmVuW2kyXSk7XG4gIH1cblxuICB2YXIgbXVsdGlEcmFnRWxlbWVudHMgPSBbXSxcbiAgICAgIG11bHRpRHJhZ0Nsb25lcyA9IFtdLFxuICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCxcbiAgICAgIC8vIGZvciBzZWxlY3Rpb24gd2l0aCBtb2RpZmllciBrZXkgZG93biAoU0hJRlQpXG4gIG11bHRpRHJhZ1NvcnRhYmxlLFxuICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZSxcbiAgICAgIC8vIEluaXRpYWwgbXVsdGktZHJhZyBmb2xkIHdoZW4gZHJhZyBzdGFydGVkXG4gIGZvbGRpbmcgPSBmYWxzZSxcbiAgICAgIC8vIEZvbGRpbmcgYW55IG90aGVyIHRpbWVcbiAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgIGRyYWdFbCQxLFxuICAgICAgY2xvbmVzRnJvbVJlY3QsXG4gICAgICBjbG9uZXNIaWRkZW47XG5cbiAgZnVuY3Rpb24gTXVsdGlEcmFnUGx1Z2luKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpRHJhZyhzb3J0YWJsZSkge1xuICAgICAgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG4gICAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICB9XG5cbiAgICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgICBvbihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgICBzZWxlY3RlZENsYXNzOiAnc29ydGFibGUtc2VsZWN0ZWQnLFxuICAgICAgICBtdWx0aURyYWdLZXk6IG51bGwsXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9ICcnO1xuXG4gICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQsIGkpIHtcbiAgICAgICAgICAgICAgZGF0YSArPSAoIWkgPyAnJyA6ICcsICcpICsgbXVsdGlEcmFnRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZHJhZ0VsLnRleHRDb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgTXVsdGlEcmFnLnByb3RvdHlwZSA9IHtcbiAgICAgIG11bHRpRHJhZ0tleURvd246IGZhbHNlLFxuICAgICAgaXNNdWx0aURyYWc6IGZhbHNlLFxuICAgICAgZGVsYXlTdGFydEdsb2JhbDogZnVuY3Rpb24gZGVsYXlTdGFydEdsb2JhbChfcmVmKSB7XG4gICAgICAgIHZhciBkcmFnZ2VkID0gX3JlZi5kcmFnRWw7XG4gICAgICAgIGRyYWdFbCQxID0gZHJhZ2dlZDtcbiAgICAgIH0sXG4gICAgICBkZWxheUVuZGVkOiBmdW5jdGlvbiBkZWxheUVuZGVkKCkge1xuICAgICAgICB0aGlzLmlzTXVsdGlEcmFnID0gfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpO1xuICAgICAgfSxcbiAgICAgIHNldHVwQ2xvbmU6IGZ1bmN0aW9uIHNldHVwQ2xvbmUoX3JlZjIpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjIuc29ydGFibGUsXG4gICAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtdWx0aURyYWdDbG9uZXMucHVzaChjbG9uZShtdWx0aURyYWdFbGVtZW50c1tpXSkpO1xuICAgICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zb3J0YWJsZUluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHNbaV0uc29ydGFibGVJbmRleDtcbiAgICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzW2ldID09PSBkcmFnRWwkMSAmJiB0b2dnbGVDbGFzcyhtdWx0aURyYWdDbG9uZXNbaV0sIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc29ydGFibGUuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfSxcbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShfcmVmMykge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBfcmVmMy5zb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbCA9IF9yZWYzLnJvb3RFbCxcbiAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYzLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICAgIGNhbmNlbCA9IF9yZWYzLmNhbmNlbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoICYmIG11bHRpRHJhZ1NvcnRhYmxlID09PSBzb3J0YWJsZSkge1xuICAgICAgICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKHRydWUsIHJvb3RFbCk7XG4gICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ2Nsb25lJyk7XG4gICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaG93Q2xvbmU6IGZ1bmN0aW9uIHNob3dDbG9uZShfcmVmNCkge1xuICAgICAgICB2YXIgY2xvbmVOb3dTaG93biA9IF9yZWY0LmNsb25lTm93U2hvd24sXG4gICAgICAgICAgICByb290RWwgPSBfcmVmNC5yb290RWwsXG4gICAgICAgICAgICBjYW5jZWwgPSBfcmVmNC5jYW5jZWw7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgICBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZmFsc2UsIHJvb3RFbCk7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjbG9uZU5vd1Nob3duKCk7XG4gICAgICAgIGNsb25lc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBoaWRlQ2xvbmU6IGZ1bmN0aW9uIGhpZGVDbG9uZShfcmVmNSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY1LnNvcnRhYmxlLFxuICAgICAgICAgICAgY2xvbmVOb3dIaWRkZW4gPSBfcmVmNS5jbG9uZU5vd0hpZGRlbixcbiAgICAgICAgICAgIGNhbmNlbCA9IF9yZWY1LmNhbmNlbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2xvbmVOb3dIaWRkZW4oKTtcbiAgICAgICAgY2xvbmVzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgZHJhZ1N0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkcmFnU3RhcnRHbG9iYWwoX3JlZjYpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjYuc29ydGFibGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnICYmIG11bHRpRHJhZ1NvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICB9KTsgLy8gU29ydCBtdWx0aS1kcmFnIGVsZW1lbnRzXG5cbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMgPSBtdWx0aURyYWdFbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuc29ydGFibGVJbmRleCAtIGIuc29ydGFibGVJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZjcpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjcuc29ydGFibGU7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAgIC8vIENhcHR1cmUgcmVjdHMsXG4gICAgICAgICAgLy8gaGlkZSBtdWx0aSBkcmFnIGVsZW1lbnRzIChieSBwb3NpdGlvbmluZyB0aGVtIGFic29sdXRlKSxcbiAgICAgICAgICAvLyBzZXQgbXVsdGkgZHJhZyBlbGVtZW50cyByZWN0cyB0byBkcmFnUmVjdCxcbiAgICAgICAgICAvLyBzaG93IG11bHRpIGRyYWcgZWxlbWVudHMsXG4gICAgICAgICAgLy8gYW5pbWF0ZSB0byByZWN0cyxcbiAgICAgICAgICAvLyB1bnNldCByZWN0cyAmIHJlbW92ZSBmcm9tIERPTVxuICAgICAgICAgIHNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICAgIGNzcyhtdWx0aURyYWdFbGVtZW50LCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNvcnRhYmxlLmFuaW1hdGVBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIFJlbW92ZSBhbGwgYXV4aWxpYXJ5IG11bHRpZHJhZyBpdGVtcyBmcm9tIGVsLCBpZiBzb3J0aW5nIGVuYWJsZWRcblxuXG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkcmFnT3ZlcjogZnVuY3Rpb24gZHJhZ092ZXIoX3JlZjgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IF9yZWY4LnRhcmdldCxcbiAgICAgICAgICAgIGNvbXBsZXRlZCA9IF9yZWY4LmNvbXBsZXRlZCxcbiAgICAgICAgICAgIGNhbmNlbCA9IF9yZWY4LmNhbmNlbDtcblxuICAgICAgICBpZiAoZm9sZGluZyAmJiB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpKSB7XG4gICAgICAgICAgY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJldmVydDogZnVuY3Rpb24gcmV2ZXJ0KF9yZWY5KSB7XG4gICAgICAgIHZhciBmcm9tU29ydGFibGUgPSBfcmVmOS5mcm9tU29ydGFibGUsXG4gICAgICAgICAgICByb290RWwgPSBfcmVmOS5yb290RWwsXG4gICAgICAgICAgICBzb3J0YWJsZSA9IF9yZWY5LnNvcnRhYmxlLFxuICAgICAgICAgICAgZHJhZ1JlY3QgPSBfcmVmOS5kcmFnUmVjdDtcblxuICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIFNldHVwIHVuZm9sZCBhbmltYXRpb25cbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBzb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgcmVjdDogZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgICBmcm9tU29ydGFibGUucmVtb3ZlQW5pbWF0aW9uU3RhdGUobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGluc2VydE11bHRpRHJhZ0VsZW1lbnRzKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUsIHJvb3RFbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkcmFnT3ZlckNvbXBsZXRlZDogZnVuY3Rpb24gZHJhZ092ZXJDb21wbGV0ZWQoX3JlZjEwKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYxMC5zb3J0YWJsZSxcbiAgICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTAuaXNPd25lcixcbiAgICAgICAgICAgIGluc2VydGlvbiA9IF9yZWYxMC5pbnNlcnRpb24sXG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMC5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICAgIHBhcmVudEVsID0gX3JlZjEwLnBhcmVudEVsLFxuICAgICAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMTAucHV0U29ydGFibGU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTsgLy8gSWYgbGVhdmluZyBzb3J0OmZhbHNlIHJvb3QsIG9yIGFscmVhZHkgZm9sZGluZyAtIEZvbGQgdG8gbmV3IGxvY2F0aW9uXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSAmJiAoZm9sZGluZyB8fCAhaXNPd25lciAmJiAhYWN0aXZlU29ydGFibGUub3B0aW9ucy5zb3J0ICYmICFwdXRTb3J0YWJsZSkpIHtcbiAgICAgICAgICAgIC8vIEZvbGQ6IFNldCBhbGwgbXVsdGkgZHJhZyBlbGVtZW50cydzIHJlY3RzIHRvIGRyYWdFbCdzIHJlY3Qgd2hlbiBtdWx0aS1kcmFnIGVsZW1lbnRzIGFyZSBpbnZpc2libGVcbiAgICAgICAgICAgIHZhciBkcmFnUmVjdEFic29sdXRlID0gZ2V0UmVjdChkcmFnRWwkMSwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgICAgc2V0UmVjdChtdWx0aURyYWdFbGVtZW50LCBkcmFnUmVjdEFic29sdXRlKTsgLy8gTW92ZSBlbGVtZW50KHMpIHRvIGVuZCBvZiBwYXJlbnRFbCBzbyB0aGF0IGl0IGRvZXMgbm90IGludGVyZmVyZSB3aXRoIG11bHRpLWRyYWcgY2xvbmVzIGluc2VydGlvbiBpZiB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAvLyB3aGlsZSBmb2xkaW5nLCBhbmQgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSB0aGVtIGFnYWluIGJlY2F1c2Ugb2xkIHNvcnRhYmxlIHdpbGwgbm8gbG9uZ2VyIGJlIGZyb21Tb3J0YWJsZVxuXG4gICAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIENsb25lcyBtdXN0IGJlIHNob3duIChhbmQgY2hlY2sgdG8gcmVtb3ZlIG11bHRpIGRyYWdzKSBhZnRlciBmb2xkaW5nIHdoZW4gaW50ZXJmZXJpbmcgbXVsdGlEcmFnRWxlbWVudHMgYXJlIG1vdmVkIG91dFxuXG5cbiAgICAgICAgICBpZiAoIWlzT3duZXIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmVtb3ZlIGlmIG5vdCBmb2xkaW5nIChmb2xkaW5nIHdpbGwgcmVtb3ZlIHRoZW0gYW55d2F5cylcbiAgICAgICAgICAgIGlmICghZm9sZGluZykge1xuICAgICAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB2YXIgY2xvbmVzSGlkZGVuQmVmb3JlID0gY2xvbmVzSGlkZGVuO1xuXG4gICAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoc29ydGFibGUpOyAvLyBVbmZvbGQgYW5pbWF0aW9uIGZvciBjbG9uZXMgaWYgc2hvd2luZyBmcm9tIGhpZGRlblxuXG5cbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuYW5pbWF0aW9uICYmICFjbG9uZXNIaWRkZW4gJiYgY2xvbmVzSGlkZGVuQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogY2xvbmUsXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IGNsb25lc0Zyb21SZWN0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNsb25lLmZyb21SZWN0ID0gY2xvbmVzRnJvbVJlY3Q7XG4gICAgICAgICAgICAgICAgICBjbG9uZS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmU6IGZ1bmN0aW9uIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZShfcmVmMTEpIHtcbiAgICAgICAgdmFyIGRyYWdSZWN0ID0gX3JlZjExLmRyYWdSZWN0LFxuICAgICAgICAgICAgaXNPd25lciA9IF9yZWYxMS5pc093bmVyLFxuICAgICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMTEuYWN0aXZlU29ydGFibGU7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhaXNPd25lciAmJiBhY3RpdmVTb3J0YWJsZS5tdWx0aURyYWcuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgICBjbG9uZXNGcm9tUmVjdCA9IF9leHRlbmRzKHt9LCBkcmFnUmVjdCk7XG4gICAgICAgICAgdmFyIGRyYWdNYXRyaXggPSBtYXRyaXgoZHJhZ0VsJDEsIHRydWUpO1xuICAgICAgICAgIGNsb25lc0Zyb21SZWN0LnRvcCAtPSBkcmFnTWF0cml4LmY7XG4gICAgICAgICAgY2xvbmVzRnJvbVJlY3QubGVmdCAtPSBkcmFnTWF0cml4LmU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbiBkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlKCkge1xuICAgICAgICBpZiAoZm9sZGluZykge1xuICAgICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcChfcmVmMTIpIHtcbiAgICAgICAgdmFyIGV2dCA9IF9yZWYxMi5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgcm9vdEVsID0gX3JlZjEyLnJvb3RFbCxcbiAgICAgICAgICAgIHBhcmVudEVsID0gX3JlZjEyLnBhcmVudEVsLFxuICAgICAgICAgICAgc29ydGFibGUgPSBfcmVmMTIuc29ydGFibGUsXG4gICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMTIuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICAgICAgb2xkSW5kZXggPSBfcmVmMTIub2xkSW5kZXgsXG4gICAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYxMi5wdXRTb3J0YWJsZTtcbiAgICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgICBpZiAoIWV2dCkgcmV0dXJuO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gcGFyZW50RWwuY2hpbGRyZW47IC8vIE11bHRpLWRyYWcgc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm11bHRpRHJhZ0tleSAmJiAhdGhpcy5tdWx0aURyYWdLZXlEb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCQxLCBvcHRpb25zLnNlbGVjdGVkQ2xhc3MsICF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpO1xuXG4gICAgICAgICAgaWYgKCF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpIHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZHJhZ0VsJDEpO1xuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICB0YXJnZXRFbDogZHJhZ0VsJDEsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZ0OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBNb2RpZmllciBhY3RpdmF0ZWQsIHNlbGVjdCBmcm9tIGxhc3QgdG8gZHJhZ0VsXG5cbiAgICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgJiYgbGFzdE11bHRpRHJhZ1NlbGVjdCAmJiBzb3J0YWJsZS5lbC5jb250YWlucyhsYXN0TXVsdGlEcmFnU2VsZWN0KSkge1xuICAgICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gaW5kZXgobGFzdE11bHRpRHJhZ1NlbGVjdCksXG4gICAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbmRleChkcmFnRWwkMSk7XG5cbiAgICAgICAgICAgICAgaWYgKH5sYXN0SW5kZXggJiYgfmN1cnJlbnRJbmRleCAmJiBsYXN0SW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIE11c3QgaW5jbHVkZSBsYXN0TXVsdGlEcmFnU2VsZWN0IChzZWxlY3QgaXQpLCBpbiBjYXNlIG1vZGlmaWVkIHNlbGVjdGlvbiBmcm9tIG5vIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIChidXQgcHJldmlvdXMgc2VsZWN0aW9uIGV4aXN0ZWQpXG4gICAgICAgICAgICAgICAgdmFyIG4sIGk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBpID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgIG4gPSBsYXN0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAofm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoY2hpbGRyZW5baV0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGNoaWxkcmVuW2ldLCBvcHRpb25zLnNlbGVjdGVkQ2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsOiBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gZHJhZ0VsJDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuc3BsaWNlKG11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpLCAxKTtcbiAgICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBudWxsO1xuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdkZXNlbGVjdCcsXG4gICAgICAgICAgICAgIHRhcmdldEVsOiBkcmFnRWwkMSxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE11bHRpLWRyYWcgZHJvcFxuXG5cbiAgICAgICAgaWYgKGRyYWdTdGFydGVkICYmIHRoaXMuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgICAvLyBEbyBub3QgXCJ1bmZvbGRcIiBhZnRlciBhcm91bmQgZHJhZ0VsIGlmIHJldmVydGVkXG4gICAgICAgICAgaWYgKChwYXJlbnRFbFtleHBhbmRvXS5vcHRpb25zLnNvcnQgfHwgcGFyZW50RWwgIT09IHJvb3RFbCkgJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGRyYWdSZWN0ID0gZ2V0UmVjdChkcmFnRWwkMSksXG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXggPSBpbmRleChkcmFnRWwkMSwgJzpub3QoLicgKyB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nICYmIG9wdGlvbnMuYW5pbWF0aW9uKSBkcmFnRWwkMS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZykge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkcmFnRWwkMS5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgIT09IGRyYWdFbCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IHJlY3Q7IC8vIFByZXBhcmUgdW5mb2xkIGFuaW1hdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIHRvU29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IC8vIE11bHRpIGRyYWcgZWxlbWVudHMgYXJlIG5vdCBuZWNlc3NhcmlseSByZW1vdmVkIGZyb20gdGhlIERPTSBvbiBkcm9wLCBzbyB0byByZWluc2VydFxuICAgICAgICAgICAgICAvLyBwcm9wZXJseSB0aGV5IG11c3QgYWxsIGJlIHJlbW92ZWRcblxuXG4gICAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXgrKztcbiAgICAgICAgICAgICAgfSk7IC8vIElmIGluaXRpYWwgZm9sZGluZyBpcyBkb25lLCB0aGUgZWxlbWVudHMgbWF5IGhhdmUgY2hhbmdlZCBwb3NpdGlvbiBiZWNhdXNlIHRoZXkgYXJlIG5vd1xuICAgICAgICAgICAgICAvLyB1bmZvbGRpbmcgYXJvdW5kIGRyYWdFbCwgZXZlbiB0aG91Z2ggZHJhZ0VsIG1heSBub3QgaGF2ZSBoaXMgaW5kZXggY2hhbmdlZCwgc28gdXBkYXRlIGV2ZW50XG4gICAgICAgICAgICAgIC8vIG11c3QgYmUgZmlyZWQgaGVyZSBhcyBTb3J0YWJsZSB3aWxsIG5vdC5cblxuICAgICAgICAgICAgICBpZiAob2xkSW5kZXggPT09IGluZGV4KGRyYWdFbCQxKSkge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4ICE9PSBpbmRleChtdWx0aURyYWdFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBNdXN0IGJlIGRvbmUgYWZ0ZXIgY2FwdHVyaW5nIGluZGl2aWR1YWwgcmVjdHMgKHNjcm9sbCBiYXIpXG5cblxuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgfSAvLyBSZW1vdmUgY2xvbmVzIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUgJiYgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBudWxsaW5nR2xvYmFsOiBmdW5jdGlvbiBudWxsaW5nR2xvYmFsKCkge1xuICAgICAgICB0aGlzLmlzTXVsdGlEcmFnID0gZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgICAgZGVzdHJveUdsb2JhbDogZnVuY3Rpb24gZGVzdHJveUdsb2JhbCgpIHtcbiAgICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLl9jaGVja0tleVVwKTtcbiAgICAgIH0sXG4gICAgICBfZGVzZWxlY3RNdWx0aURyYWc6IGZ1bmN0aW9uIF9kZXNlbGVjdE11bHRpRHJhZyhldnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkcmFnU3RhcnRlZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkcmFnU3RhcnRlZCkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIHNlbGVjdGlvbiBpcyBpbiB0aGlzIHNvcnRhYmxlXG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICE9PSB0aGlzLnNvcnRhYmxlKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgdGFyZ2V0IGlzIG5vdCBpdGVtIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgICBpZiAoZXZ0ICYmIGNsb3Nlc3QoZXZ0LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5zb3J0YWJsZS5lbCwgZmFsc2UpKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgbGVmdCBjbGlja1xuXG4gICAgICAgIGlmIChldnQgJiYgZXZ0LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHdoaWxlIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZWwgPSBtdWx0aURyYWdFbGVtZW50c1swXTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHRoaXMuc29ydGFibGUsXG4gICAgICAgICAgICByb290RWw6IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGVsLFxuICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2NoZWNrS2V5RG93bjogZnVuY3Rpb24gX2NoZWNrS2V5RG93bihldnQpIHtcbiAgICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2NoZWNrS2V5VXA6IGZ1bmN0aW9uIF9jaGVja0tleVVwKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMoTXVsdGlEcmFnLCB7XG4gICAgICAvLyBTdGF0aWMgbWV0aG9kcyAmIHByb3BlcnRpZXNcbiAgICAgIHBsdWdpbk5hbWU6ICdtdWx0aURyYWcnLFxuICAgICAgdXRpbHM6IHtcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIHNlbGVjdGVkXHJcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVsKSB7XG4gICAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXTtcbiAgICAgICAgICBpZiAoIXNvcnRhYmxlIHx8ICFzb3J0YWJsZS5vcHRpb25zLm11bHRpRHJhZyB8fCB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCkpIHJldHVybjtcblxuICAgICAgICAgIGlmIChtdWx0aURyYWdTb3J0YWJsZSAmJiBtdWx0aURyYWdTb3J0YWJsZSAhPT0gc29ydGFibGUpIHtcbiAgICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSBzb3J0YWJsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc29ydGFibGUub3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxyXG4gICAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBkZXNlbGVjdGVkXHJcbiAgICAgICAgICovXG4gICAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlbCkge1xuICAgICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb10sXG4gICAgICAgICAgICAgIGluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCk7XG4gICAgICAgICAgaWYgKCFzb3J0YWJsZSB8fCAhc29ydGFibGUub3B0aW9ucy5tdWx0aURyYWcgfHwgIX5pbmRleCkgcmV0dXJuO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCBzb3J0YWJsZS5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvbGRJbmRpY2llcyA9IFtdLFxuICAgICAgICAgICAgbmV3SW5kaWNpZXMgPSBbXTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIG9sZEluZGljaWVzLnB1c2goe1xuICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgIGluZGV4OiBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXhcbiAgICAgICAgICB9KTsgLy8gbXVsdGlEcmFnRWxlbWVudHMgd2lsbCBhbHJlYWR5IGJlIHNvcnRlZCBpZiBmb2xkaW5nXG5cbiAgICAgICAgICB2YXIgbmV3SW5kZXg7XG5cbiAgICAgICAgICBpZiAoZm9sZGluZyAmJiBtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZvbGRpbmcpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCwgJzpub3QoLicgKyBfdGhpczMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXRlbXM6IF90b0NvbnN1bWFibGVBcnJheShtdWx0aURyYWdFbGVtZW50cyksXG4gICAgICAgICAgY2xvbmVzOiBbXS5jb25jYXQobXVsdGlEcmFnQ2xvbmVzKSxcbiAgICAgICAgICBvbGRJbmRpY2llczogb2xkSW5kaWNpZXMsXG4gICAgICAgICAgbmV3SW5kaWNpZXM6IG5ld0luZGljaWVzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgb3B0aW9uTGlzdGVuZXJzOiB7XG4gICAgICAgIG11bHRpRHJhZ0tleTogZnVuY3Rpb24gbXVsdGlEcmFnS2V5KGtleSkge1xuICAgICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gJ2N0cmwnKSB7XG4gICAgICAgICAgICBrZXkgPSAnQ29udHJvbCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAga2V5ID0ga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cigxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyhjbG9uZXNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCwgaSkge1xuICAgICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlblttdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggKyAoY2xvbmVzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCB0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEluc2VydCBtdWx0aS1kcmFnIGNsb25lc1xyXG4gICAqIEBwYXJhbSAge1tCb29sZWFuXX0gZWxlbWVudHNJbnNlcnRlZCAgV2hldGhlciB0aGUgbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW5zZXJ0ZWRcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gcm9vdEVsXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZWxlbWVudHNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lLCBpKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW2Nsb25lLnNvcnRhYmxlSW5kZXggKyAoZWxlbWVudHNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lLCB0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCkge1xuICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlICYmIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIFNvcnRhYmxlLm1vdW50KG5ldyBBdXRvU2Nyb2xsUGx1Z2luKCkpO1xuICBTb3J0YWJsZS5tb3VudChSZW1vdmUsIFJldmVydCk7XG5cbiAgU29ydGFibGUubW91bnQobmV3IFN3YXBQbHVnaW4oKSk7XG4gIFNvcnRhYmxlLm1vdW50KG5ldyBNdWx0aURyYWdQbHVnaW4oKSk7XG5cbiAgcmV0dXJuIFNvcnRhYmxlO1xuXG59KSk7XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL21vZHVsZXMvdXRpbHMubWpzJ1xuaW1wb3J0ICogYXMgc2VhcmNoIGZyb20gJy4vbW9kdWxlcy9zZWFyY2gubWpzJ1xuaW1wb3J0IHNldERhc2hib2FyZFByZWZlcmVuY2VzIGZyb20gJy4vbW9kdWxlcy9wcmVmZXJlbmNlcy9kYXNoYm9hcmQubWpzJ1xuaW1wb3J0IHsgY2xvbmVBbmRVcGRhdGVNZW51IH0gZnJvbSAnLi9tb2R1bGVzL3V0aWxzLm1qcydcbmltcG9ydCBzZXRNZW51UHJlZmVyZW5jZXMgZnJvbSAnLi9tb2R1bGVzL3ByZWZlcmVuY2VzL21lbnUubWpzJ1xuaW1wb3J0IHVyZ2VudEFubm91bmNlbWVudCBmcm9tICcuL3dlYi1jb21wb25lbnRzL3VyZ2VudC1hbm5vdW5jZW1lbnQubWpzJ1xuaW1wb3J0IHsgV0NfYW5ub3VuY2VtZW50c1dpZGdldCB9IGZyb20gJy4vd2ViLWNvbXBvbmVudHMvYW5ub3VuY2VtZW50cy5tanMnXG5pbXBvcnQgKiBhcyB1bnJlYWRBbm5vdW5jZW1lbnRzIGZyb20gJy4vbW9kdWxlcy91bnJlYWRBbm5vdW5jZW1lbnRzLm1qcydcbmltcG9ydCAqIGFzIG5vdGlmeSBmcm9tICcuL21vZHVsZXMvbm90aWZ5Lm1qcydcblxuY29uc3QgcGFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4nKS5pZC50b0xvd2VyQ2FzZSgpXG5cbmlmIChwYWdlICE9PSAnYWNjb3VudCcpIHtcbiAgICBjbG9uZUFuZFVwZGF0ZU1lbnUoKVxufVxuXG4vL2luaXQgd2ViIGNvbXBvbmVudHNcbmlmIChwYWdlID09PSAnZGFzaGJvYXJkJykge1xuICAgIHV0aWxzLmFwcGVuZFdpZGdldHModXRpbHMuZ2V0UHJlZmVyZW5jZXMoKSlcbn1cblxuaWYgKHBhZ2UgPT09ICdhY2NvdW50Jykge1xuICAgIHNldERhc2hib2FyZFByZWZlcmVuY2VzKClcbiAgICBzZXRNZW51UHJlZmVyZW5jZXMoKVxufVxuXG5pZiAocGFnZSA9PT0gJ2Fubm91bmNlbWVudHMtb3ZlcnZpZXcnKSB7XG4gICAgY29uc3QgYW5ub3VuY2VtZW50TGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbm5vdW5jZW1lbnRzJylcbiAgICBhbm5vdW5jZW1lbnRMaXN0LnJlbW92ZSgpXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbiBzZWN0aW9uJykuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Fubm91bmNlbWVudHMtd2lkZ2V0JykpXG4gICAgV0NfYW5ub3VuY2VtZW50c1dpZGdldChwYWdlKVxufVxuXG5cbi8vY2hlY2sgaWYgYnJvd3NlciBpcyBvbmxpbmVcbmlmIChuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgLy91cmdlbnQgYW5ub3VuY2VtZW50c1xuICAgIGNvbnN0IHNvY2tldCA9IGlvKClcblxuICAgIC8vc3Vic2NyaWJlIHRvIHVyZ2VudC1hbm5vdW5jZW1lbnRzXG4gICAgc29ja2V0LmVtaXQoJ2pvaW4nLCBwYWdlKVxuXG4gICAgLy9vbiB1cmdlbnQtYW5ub3VuY2VtZW50IGhvb2sgdXBkYXRlIGludGVyZmFjZSAoc2VlIFdDX3VyZ2VudEFubm91bmNlbWVudClcbiAgICBzb2NrZXQub24oJ3VyZ2VudC1hbm5vdW5jZW1lbnQnLCBhbm5vdW5jZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCB1cmdlbnRBbm5vdW5jZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd1cmdlbnQtYW5ub3VuY2VtZW50JylcblxuICAgICAgICBpZiAodXRpbHMuZXhpc3RzKFt1cmdlbnRBbm5vdW5jZW1lbnRdKSkge1xuICAgICAgICAgICAgdXJnZW50QW5ub3VuY2VtZW50LnNldEF0dHJpYnV0ZSgnbWVzc2FnZScsIGFubm91bmNlbWVudC5jb250ZW50KVxuICAgICAgICAgICAgdXJnZW50QW5ub3VuY2VtZW50LnNldEF0dHJpYnV0ZSgndWlkJywgYW5ub3VuY2VtZW50Lm5ld3NJdGVtSWQpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWFkeSAvL3dhaXQgZm9yIHN3IHRvIGJlIHJlYWR5XG4gICAgICAgICAgICAgICAgLnRoZW4ocmVnaXN0cmF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZnkuZGlzcGxheU5vdGlmaWNhdGlvbihhbm5vdW5jZW1lbnQudGl0bGUsIGFubm91bmNlbWVudC5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5cblxuXG4vL21lbnUgXG5jb25zdCBtZW51SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51LWljb24nKVxuY29uc3QgbWVudSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51JylcblxuaWYgKHV0aWxzLmV4aXN0cyhbbWVudUljb24sIG1lbnVdKSkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmYWxsYmFjaycpLnJlbW92ZSgpXG5cbiAgICAvL3RvZ2dsZSBtZW51IChvbiBtb2JpbGUpXG4gICAgbWVudUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICBtZW51LmNsYXNzTGlzdC50b2dnbGUoJ2hpZGUnKVxuICAgIH0pXG59XG5cblxuXG5cbi8vc2VhcmNoIFxuY29uc3Qgc2VhcmNoQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlYXJjaC1iYXInKVxuY29uc3Qgc2VhcmNoUmVzZXRJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlYXJjaC1yZXNldCcpXG5jb25zdCBzZWFyY2hJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlYXJjaC1jb250YWluZXIgaW5wdXRbdHlwZT1zdWJtaXRdJylcblxuaWYgKHV0aWxzLmV4aXN0cyhbc2VhcmNoQmFyLCBzZWFyY2hSZXNldEljb24sIHNlYXJjaEljb25dKSkge1xuXG4gICAgLy9jb250cm9sIHNlYXJjaC1yZXNldCBpY29uIFxuICAgIHNlYXJjaEJhci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHNlYXJjaC5zaG93UmVzZXQoKSlcbiAgICBzZWFyY2hCYXIuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHNlYXJjaC5oaWRlUmVzZXQoKSlcblxuXG4gICAgLy9yZXNldCBzZWFyY2ggaW5wdXRcbiAgICBzZWFyY2hSZXNldEljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHNlYXJjaC5yZXNldChlKSlcblxuXG4gICAgLy9kZXBlbmRpbmcgb24gc2VhcmNoLXF1ZXJ5IGVpdGhlciBnaXZlIGZvY3VzIHRvIHNlYXJjaGJhciBvciBzdWJtaXQgc2VhcmNoLXF1ZXJ5XG4gICAgc2VhcmNoSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoQmFyLnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICBzZWFyY2guZm9jdXMoZSlcbiAgICAgICAgfVxuICAgIH0pXG5cblxuICAgIC8vbGlzdGVuIHRvIGtleWJvYXJkIGlucHV0XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBlID0+IHtcbiAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICBzZWFyY2guZm9jdXMoZSkgLy9naXZlIHNlYXJjaGJhciBmb2N1cyBhbmQgaGlkZSBzZWFyY2gtcmVzZXQgaWNvblxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5cbi8vdW5yZWFkIGFubm91bmNlbWVudCBpbmRpY2F0b3IgaW4gbWVudVxuY29uc3QgYW5ub3VuY2VtZW50TWVudUl0ZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbWVudS1wcmltYXJ5LWxpbmtzIGE6bGFzdC1vZi10eXBlJylcblxuaWYgKHV0aWxzLmV4aXN0cyhbYW5ub3VuY2VtZW50TWVudUl0ZW1dKSAmJiB1dGlscy5zdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgIHVucmVhZEFubm91bmNlbWVudHMuaW5kaWNhdGUoYW5ub3VuY2VtZW50TWVudUl0ZW0pXG59IiwiZXhwb3J0IGZ1bmN0aW9uIGRpc3BsYXlOb3RpZmljYXRpb24odGl0bGUsIGJvZHkpIHtcbiAgICBpZiAoTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdncmFudGVkJykge1xuICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5nZXRSZWdpc3RyYXRpb24oKS50aGVuKHJlZyA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgaWNvbjogJy4vbWVkaWEvaWNvbnMvaHZhLWxvZ28tcHVycGxlLnN2ZycsXG4gICAgICAgICAgICAgICAgdmlicmF0ZTogWzEwMCwgNTAsIDEwMF0sXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdnb3RvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnR28gdG8gSHZBIFBvcnRhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnLi9tZWRpYS9pY29ucy9odmEtbG9nby1wdXJwbGUuc3ZnJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdjbG9zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0Nsb3NlIG5vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAnLi9tZWRpYS9pY29ucy9odmEtbG9nby1wdXJwbGUuc3ZnJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZy5zaG93Tm90aWZpY2F0aW9uKHRpdGxlLCBvcHRpb25zKVxuICAgICAgICB9KVxuICAgIH1cbn0iLCJpbXBvcnQgeyBzZXRMb2NhbFN0b3JhZ2UsIGdldExvY2FsU3RvcmFnZSB9IGZyb20gJy4uLy4uL21vZHVsZXMvdXRpbHMubWpzJ1xuaW1wb3J0IFNvcnRhYmxlIGZyb20gJ3NvcnRhYmxlanMnXG5cbmNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcmVmZXJlbmNlcycpXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXREYXNoYm9hcmRQcmVmZXJlbmNlcygpIHtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuXG4gICAgZ2V0UHJlZmVyZW5jZXMoKVxuICAgIHN0YXRlSGFuZGxlcigpXG4gICAgZHJhZ0hhbmRsZXIoKVxufVxuXG5mdW5jdGlvbiBnZXRQcmVmZXJlbmNlcygpIHtcbiAgICBjb25zdCBwcmVmZXJlbmNlcyA9IGdldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnKVxuICAgIGlmIChwcmVmZXJlbmNlcykge1xuICAgICAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSAnJ1xuICAgICAgICBwcmVmZXJlbmNlcy5mb3JFYWNoKHByZWZlcmVuY2UgPT4gY29udGFpbmVyLmFwcGVuZChjcmVhdGVMYWJlbHMocHJlZmVyZW5jZSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFByZWZlcmVuY2VzT2JqZWN0KClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWdIYW5kbGVyKCkge1xuICAgIGNvbnN0IHByZWZlcmVuY2VzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3ByZWZlcmVuY2VzJylcblxuICAgIG5ldyBTb3J0YWJsZShwcmVmZXJlbmNlc0NvbnRhaW5lciwge1xuICAgICAgICBkcmFnZ2FibGU6IFwiLm9uXCIsXG4gICAgICAgIGFuaW1hdGlvbjogMTUwLFxuICAgICAgICBvblN0YXJ0OiAoZXZlbnQpID0+IGFkZFN0eWxpbmdUb0Ryb3Bab25lcyhldmVudCksXG4gICAgICAgIG9uRW5kOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZVN0eWxpbmdGcm9tRHJvcFpvbmVzKGV2ZW50KVxuICAgICAgICAgICAgc2V0UHJlZmVyZW5jZXNPYmplY3QoKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGluZ1RvRHJvcFpvbmVzKGV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ0xvY2F0aW9ucyA9IFsuLi5ldmVudC50YXJnZXQucXVlcnlTZWxlY3RvckFsbCgnbGFiZWw6bm90KC5zb3J0YWJsZS1jaG9zZW4pJyldXG4gICAgZHJhZ0xvY2F0aW9ucy5mb3JFYWNoKGxvY2F0aW9uID0+IGxvY2F0aW9uLmNsYXNzTGlzdC5hZGQoJ29wdGlvbmFsLWxvY2F0aW9uJykpXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxpbmdGcm9tRHJvcFpvbmVzKGV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ0xvY2F0aW9ucyA9IFsuLi5ldmVudC50YXJnZXQucXVlcnlTZWxlY3RvckFsbCgnbGFiZWw6bm90KC5zb3J0YWJsZS1jaG9zZW4pJyldXG4gICAgZHJhZ0xvY2F0aW9ucy5mb3JFYWNoKGxvY2F0aW9uID0+IGxvY2F0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ29wdGlvbmFsLWxvY2F0aW9uJykpXG59XG5cbi8vIFNhdmluZyBhbmQgY2hhbmdpbmcgcHJlZmVyZW5jZXMgXG5mdW5jdGlvbiBzZXRQcmVmZXJlbmNlc09iamVjdCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3ByZWZlcmVuY2VzIGxhYmVsJyldXG4gICAgbGV0IHByZWZlcmVuY2VzID0gW11cblxuICAgIGlucHV0cy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgLy8gRGF0YVxuICAgICAgICBjb25zdCBpZCA9IGxhYmVsLmlkXG4gICAgICAgIGNvbnN0IHRleHQgPSBsYWJlbC50ZXh0Q29udGVudFxuICAgICAgICBjb25zdCBzdGF0ZSA9IGxhYmVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuY2hlY2tlZFxuXG4gICAgICAgIC8vIFNldCBMb2NhbFN0b3JhZ2VcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0geyBpZDogaWQsIG5hbWU6IHRleHQsIHN0YXRlOiBzdGF0ZSB9XG4gICAgICAgIHByZWZlcmVuY2VzLnB1c2gob2JqZWN0KVxuICAgICAgICBzZXRMb2NhbFN0b3JhZ2UoJ3ByZWZlcmVuY2VzJywgcHJlZmVyZW5jZXMpXG4gICAgfSlcblxuICAgIHJldHVybiBwcmVmZXJlbmNlc1xufVxuXG5mdW5jdGlvbiBzdGF0ZUhhbmRsZXIoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwcmVmZXJlbmNlcyBsYWJlbCcpXVxuICAgIGNvbnN0IGRhdGEgPSBnZXRMb2NhbFN0b3JhZ2UoJ3ByZWZlcmVuY2VzJylcblxuICAgIGlucHV0cy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgdXBkYXRlU3RhdGUoZGF0YSwgbGFiZWwpXG5cbiAgICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgLy8gRGF0YVxuICAgICAgICAgICAgY29uc3QgaWQgPSBsYWJlbC5pZFxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBldmVudC50YXJnZXQuY2hlY2tlZFxuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgTG9jYWxTdG9yYWdlXG4gICAgICAgICAgICBjb25zdCBwcmVmZXJlbmNlID0gZGF0YS5maW5kKHByZWZlcmVuY2UgPT4gcHJlZmVyZW5jZS5pZCA9PT0gaWQpXG4gICAgICAgICAgICBwcmVmZXJlbmNlLnN0YXRlID0gc3RhdGVcbiAgICAgICAgICAgIHNldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnLCBkYXRhKVxuXG4gICAgICAgICAgICAvLyBDaGFuZ2Ugc3RhdGUgdmlzdWFseVxuICAgICAgICAgICAgaWYgKHByZWZlcmVuY2Uuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdvbicpXG4gICAgICAgICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnb2ZmJylcbiAgICAgICAgICAgICAgICBsYWJlbC5jbGFzc0xpc3QucmVtb3ZlKCdvbicpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKVxuICAgICAgICAgICAgICAgIHNldFByZWZlcmVuY2VzT2JqZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShkYXRhLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcHJlZmVyZW5jZSA9IGRhdGEuZmluZChwcmVmZXJlbmNlID0+IHByZWZlcmVuY2UuaWQgPT09IGVsZW1lbnQuaWQpXG4gICAgcHJlZmVyZW5jZS5zdGF0ZSA/IGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmJykgOiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ29uJylcbn1cblxuLy8gUmVhcmFuZ2luZyBvcmRlclxuZnVuY3Rpb24gY3JlYXRlTGFiZWxzKHByZWZlcmVuY2UpIHtcbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICBsYWJlbC5pZCA9IHByZWZlcmVuY2UuaWRcbiAgICBwcmVmZXJlbmNlLnN0YXRlID8gbGFiZWwuY2xhc3NOYW1lID0gJ29uJyA6IGxhYmVsLmNsYXNzTmFtZSA9ICdvZmYnXG5cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3JlcHJlc2VudHMnLCBwcmVmZXJlbmNlLmlkKVxuXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgaW5wdXQudHlwZSA9ICdjaGVja2JveCdcbiAgICBpbnB1dC5jaGVja2VkID0gcHJlZmVyZW5jZS5zdGF0ZVxuXG4gICAgbGFiZWwuYXBwZW5kKGlucHV0KVxuICAgIGxhYmVsLmFwcGVuZChwcmVmZXJlbmNlLm5hbWUpXG5cbiAgICByZXR1cm4gbGFiZWxcbn0iLCJpbXBvcnQgeyBzZXRMb2NhbFN0b3JhZ2UsIGdldExvY2FsU3RvcmFnZSwgc3RvcmFnZUF2YWlsYWJsZSB9IGZyb20gJy4uLy4uL21vZHVsZXMvdXRpbHMubWpzJ1xuaW1wb3J0IFNvcnRhYmxlIGZyb20gJ3NvcnRhYmxlanMnXG5cbmNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZW51LXByZWZlcmVuY2VzJylcbmNvbnN0IHNlY29uZGFyeUxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21lbnUtc2Vjb25kYXJ5LWxpbmtzJylcbmNvbnN0IGNsb25lZExpbmtzID0gWy4uLnNlY29uZGFyeUxpbmtzLmNsb25lTm9kZSh0cnVlKS5jaGlsZHJlbl1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0TWVudVByZWZlcmVuY2VzKCkge1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpXG5cbiAgICBjaGVja2VyKCkgPyByZW5kZXJQcmVmZXJlbmNlcygpIDogc2V0UHJlZmVyZW5jZXMoKVxuICAgIHN0YXRlSGFuZGxlcigpXG4gICAgZHJhZ0hhbmRsZXIoKVxuICAgIGNsb25lQW5kVXBkYXRlTWVudSgpXG59XG5cbmZ1bmN0aW9uIGNsb25lQW5kVXBkYXRlTWVudSgpIHtcbiAgICBsZXQgc2VsZWN0ZWRNZW51SXRlbXMgPSBbXVxuXG4gICAgLy8gTG9jYWxTdG9yYWdlXG4gICAgY29uc3QgcHJlZmVyZW5jZXMgPSBnZXRMb2NhbFN0b3JhZ2UoJ21lbnUtcHJlZmVyZW5jZXMnKVxuICAgIHByZWZlcmVuY2VzLmZvckVhY2gocHJlZmVyZW5jZSA9PiB7XG4gICAgICAgIGNsb25lZExpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbGluay5xdWVyeVNlbGVjdG9yKCdwOmZpcnN0LW9mLXR5cGUnKS50ZXh0Q29udGVudFxuXG4gICAgICAgICAgICBpZiAocHJlZmVyZW5jZS5uYW1lID09PSBuYW1lICYmIHByZWZlcmVuY2Uuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE1lbnVJdGVtcy5wdXNoKGxpbmspXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHNlY29uZGFyeUxpbmtzLnRleHRDb250ZW50ID0gJydcbiAgICBzZWxlY3RlZE1lbnVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4gc2Vjb25kYXJ5TGlua3MuYXBwZW5kKGl0ZW0pKVxufVxuXG5mdW5jdGlvbiBzdGF0ZUhhbmRsZXIoKSB7XG4gICAgY29uc3QgbGFiZWxzID0gWy4uLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbCcpXVxuXG4gICAgbGFiZWxzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRQcmVmZXJlbmNlcygpXG5cbiAgICAgICAgICAgIGlmIChsYWJlbC5jbGFzc05hbWUgPT09ICdvZmYnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZChsYWJlbClcbiAgICAgICAgICAgICAgICBzZXRQcmVmZXJlbmNlcygpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYWJlbC5jbGFzc05hbWUgPT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdE9mZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZW51LXByZWZlcmVuY2VzIC5vZmYnKVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUobGFiZWwsIGZpcnN0T2ZmKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmRlclByZWZlcmVuY2VzKCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gY3JlYXRlRWxlbWVudHMoKVxuICAgIGFwcGVuZEVsZW1lbnRzKGVsZW1lbnRzKVxufVxuXG5mdW5jdGlvbiBhcHBlbmRFbGVtZW50cyhlbGVtZW50cykge1xuICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9ICcnXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IGNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCkpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHByZWZlcmVuY2VzID0gZ2V0TG9jYWxTdG9yYWdlKCdtZW51LXByZWZlcmVuY2VzJylcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdXG5cbiAgICBwcmVmZXJlbmNlcy5mb3JFYWNoKHByZWZlcmVuY2UgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICAgICAgcHJlZmVyZW5jZS5zdGF0ZSA/IGxhYmVsLmNsYXNzTmFtZSA9ICdvbicgOiBsYWJlbC5jbGFzc05hbWUgPSAnb2ZmJ1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBoYW5kbGUuY2xhc3NMaXN0LmFkZCgnaGFuZGxlJylcblxuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgaW5wdXQudHlwZSA9ICdjaGVja2JveCdcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHByZWZlcmVuY2Uuc3RhdGVcblxuICAgICAgICBsYWJlbC5hcHBlbmQoaGFuZGxlKVxuICAgICAgICBsYWJlbC5hcHBlbmQoaW5wdXQpXG4gICAgICAgIGxhYmVsLmFwcGVuZChwcmVmZXJlbmNlLm5hbWUpXG5cbiAgICAgICAgZWxlbWVudHMucHVzaChsYWJlbClcbiAgICB9KVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzXG59XG5cbmZ1bmN0aW9uIGNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIHN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpICYmIGdldExvY2FsU3RvcmFnZSgnbWVudS1wcmVmZXJlbmNlcycpID9cbiAgICAgICAgdHJ1ZSA6IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGRyYWdIYW5kbGVyKCkge1xuICAgIG5ldyBTb3J0YWJsZShjb250YWluZXIsIHtcbiAgICAgICAgYW5pbWF0aW9uOiAxNTAsXG4gICAgICAgIG9uU3RhcnQ6IChldmVudCkgPT4gYWRkU3R5bGluZ1RvRHJvcFpvbmVzKGV2ZW50KSxcbiAgICAgICAgb25FbmQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZVN0eWxpbmdGcm9tRHJvcFpvbmVzKGV2ZW50KVxuICAgICAgICAgICAgc2V0UHJlZmVyZW5jZXMoKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGluZ1RvRHJvcFpvbmVzKGV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ0xvY2F0aW9ucyA9IFsuLi5ldmVudC50YXJnZXQucXVlcnlTZWxlY3RvckFsbCgnbGFiZWw6bm90KC5zb3J0YWJsZS1jaG9zZW4pJyldXG4gICAgZHJhZ0xvY2F0aW9ucy5mb3JFYWNoKGxvY2F0aW9uID0+IGxvY2F0aW9uLmNsYXNzTGlzdC5hZGQoJ29wdGlvbmFsLWxvY2F0aW9uJykpXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxpbmdGcm9tRHJvcFpvbmVzKGV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ0xvY2F0aW9ucyA9IFsuLi5ldmVudC50YXJnZXQucXVlcnlTZWxlY3RvckFsbCgnbGFiZWw6bm90KC5zb3J0YWJsZS1jaG9zZW4pJyldXG4gICAgZHJhZ0xvY2F0aW9ucy5mb3JFYWNoKGxvY2F0aW9uID0+IGxvY2F0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ29wdGlvbmFsLWxvY2F0aW9uJykpXG59XG5cbmZ1bmN0aW9uIHNldFByZWZlcmVuY2VzKCkge1xuICAgIGNvbnN0IGxhYmVscyA9IFsuLi5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnbGFiZWwnKV1cbiAgICBsZXQgcHJlZmVyZW5jZXMgPSBbXVxuXG4gICAgbGFiZWxzLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbGFiZWwudGV4dENvbnRlbnRcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBsYWJlbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmNoZWNrZWRcbiAgICAgICAgc3RhdGUgPyBsYWJlbC5jbGFzc05hbWUgPSAnb24nIDogbGFiZWwuY2xhc3NOYW1lID0gJ29mZidcblxuICAgICAgICBjb25zdCBvYmplY3QgPSB7IG5hbWU6IHRleHQsIHN0YXRlOiBzdGF0ZSB9XG4gICAgICAgIHByZWZlcmVuY2VzLnB1c2gob2JqZWN0KVxuICAgIH0pXG5cbiAgICBzZXRMb2NhbFN0b3JhZ2UoJ21lbnUtcHJlZmVyZW5jZXMnLCBwcmVmZXJlbmNlcylcbiAgICBjbG9uZUFuZFVwZGF0ZU1lbnUoKVxufSIsImNvbnN0IHNlYXJjaEJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gtYmFyJylcbmNvbnN0IHNlYXJjaFJlc2V0SWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gtcmVzZXQnKVxuXG5leHBvcnQgZnVuY3Rpb24gZm9jdXMoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIHNlYXJjaEJhci5mb2N1cygpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93UmVzZXQoKSB7XG4gICAgc2VhcmNoUmVzZXRJY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZVJlc2V0KCkge1xuICAgIGlmIChzZWFyY2hCYXIudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgc2VhcmNoUmVzZXRJY29uLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KGUpIHtcbiAgICBzZWFyY2hCYXIudmFsdWUgPSBcIlwiXG4gICAgZm9jdXMoZSlcbn0iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLm1qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGluZGljYXRlKGl0ZW0pIHtcbiAgICBnZXRVbnJlYWQoKVxuICAgICAgICAudGhlbihudW1iZXJVbnJlYWQgPT4ge1xuICAgICAgICAgICAgaWYgKG51bWJlclVucmVhZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3VucmVhZC1pbmRpY2F0b3InKVxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdudW1iZXItdW5yZWFkJywgbnVtYmVyVW5yZWFkKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxufVxuXG5cbmZ1bmN0aW9uIGdldEFubm91bmNlbWVudHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmV0Y2goJy9hbm5vdW5jZW1lbnRzbGlzdCcsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG59XG5cbmZ1bmN0aW9uIGdldFVucmVhZCgpIHtcbiAgICBjb25zdCBzdG9yZWRIaXN0b3J5ID0gdXRpbHMuZ2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknKVxuICAgIGNvbnN0IG51bWJlclVucmVhZCA9IGdldEFubm91bmNlbWVudHMoKVxuICAgICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFthbm5vdW5jZW1lbnRzLCBjYXRlZ29yaWVzXSA9IGpzb25cbiAgICAgICAgICAgIHJldHVybiBhbm5vdW5jZW1lbnRzXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGFubm91bmNlbWVudHMgPT4ge1xuICAgICAgICAgICAgbGV0IG51bWJlck9mVW5yZWFkID0gMFxuICAgICAgICAgICAgaWYgKHN0b3JlZEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhbm5vdW5jZW1lbnRzLmZvckVhY2goYW5ub3VuY2VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZWRIaXN0b3J5LmluY2x1ZGVzKGFubm91bmNlbWVudC5uZXdzSXRlbUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZVbnJlYWQrK1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21lbnUtcHJpbWFyeS1saW5rcyBhOmxhc3Qtb2YtdHlwZScpLmNsYXNzTGlzdC5hZGQoJ3VucmVhZC1pbmRpY2F0b3InKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZW51LXByaW1hcnktbGlua3MgYTpsYXN0LW9mLXR5cGUnKS5zZXRBdHRyaWJ1dGUoJ251bWJlci11bnJlYWQnLCBhbm5vdW5jZW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1iZXJPZlVucmVhZFxuICAgICAgICB9KVxuICAgIHJldHVybiBudW1iZXJVbnJlYWRcbn0iLCJpbXBvcnQgeyBXQ19zdHVkeXByb2dyZXNzIH0gZnJvbSAnLi4vd2ViLWNvbXBvbmVudHMvc3R1ZHktcHJvZ3Jlc3MubWpzJ1xuaW1wb3J0IHsgV0Nfc2NoZWR1bGVXaWRnZXQgfSBmcm9tICcuLi93ZWItY29tcG9uZW50cy9zY2hlZHVsZS5tanMnXG5pbXBvcnQgeyBXQ19jb3Vyc2VvdmVydmlldyB9IGZyb20gJy4uL3dlYi1jb21wb25lbnRzL2NvdXJzZS1vdmVydmlldy5tanMnXG5pbXBvcnQgeyBXQ19hbm5vdW5jZW1lbnRzV2lkZ2V0IH0gZnJvbSAnLi4vd2ViLWNvbXBvbmVudHMvYW5ub3VuY2VtZW50cy5tanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoWy4uLnZhcmlhYmxlc10pIHtcbiAgICBjb25zdCBleGlzdHMgPSB2YXJpYWJsZXMuZXZlcnkodmFyaWFibGUgPT4gdmFyaWFibGUgIT0gbnVsbClcbiAgICByZXR1cm4gZXhpc3RzXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExvY2FsU3RvcmFnZShuYW1lLCBpdGVtKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkoaXRlbSkpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZShpdGVtKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oaXRlbSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHsgLy9zb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkvVXNpbmdfdGhlX1dlYl9TdG9yYWdlX0FQSVxuICAgIGxldCBzdG9yYWdlXG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXVxuICAgICAgICBsZXQgeCA9ICdfX3N0b3JhZ2VfdGVzdF9fJ1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeClcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiAoXG4gICAgICAgICAgICAgICAgZS5jb2RlID09PSAyMiB8fFxuICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gMTAxNCB8fFxuICAgICAgICAgICAgICAgIGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHxcbiAgICAgICAgICAgICAgICBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpICYmXG4gICAgICAgICAgICAoc3RvcmFnZSAmJiBzdG9yYWdlLmxlbmd0aCAhPT0gMClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcmVmZXJlbmNlcygpIHtcbiAgICBsZXQgd2lkZ2V0RWxlbWVudHNcblxuICAgIGlmIChzdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICBjb25zdCBwcmVmZXJlbmNlcyA9IGdldExvY2FsU3RvcmFnZSgncHJlZmVyZW5jZXMnKVxuICAgICAgICBpZiAocHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzID0gY2hlY2tlcihwcmVmZXJlbmNlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzID0gWydhbm5vdW5jZW1lbnRzLXdpZGdldCcsICdzdHVkeS1wcm9ncmVzcycsICdjb3Vyc2Utb3ZlcnZpZXcnLCAnc2NoZWR1bGUtd2lkZ2V0J11cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZGdldEVsZW1lbnRzID0gWydhbm5vdW5jZW1lbnRzLXdpZGdldCcsICdzdHVkeS1wcm9ncmVzcycsICdjb3Vyc2Utb3ZlcnZpZXcnLCAnc2NoZWR1bGUtd2lkZ2V0J11cbiAgICB9XG5cbiAgICByZXR1cm4gd2lkZ2V0RWxlbWVudHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFdpZGdldHMod2lkZ2V0KSB7XG4gICAgLy8gUmVtb3ZlIEVKUyB0ZW1wbGF0ZXNcbiAgICBjb25zdCBkb21FbGVtZW50cyA9IFsnYW5ub3VuY2VtZW50cycsICdzdHVkeS1wcm9ncmVzcycsICdjb3Vyc2Utb3ZlcnZpZXcnLCAnc2NoZWR1bGUnXVxuICAgIGRvbUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KS5yZW1vdmUoKSlcblxuICAgIC8vIEFkZGluZyB3aWRnZXRzXG4gICAgd2lkZ2V0LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3aWRnZXQtY29udGFpbmVyJykuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXRlbSkpXG5cbiAgICAgICAgaWYgKGl0ZW0gPT09ICdzdHVkeS1wcm9ncmVzcycpIHtcbiAgICAgICAgICAgIFdDX3N0dWR5cHJvZ3Jlc3MoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnY291cnNlLW92ZXJ2aWV3Jykge1xuICAgICAgICAgICAgV0NfY291cnNlb3ZlcnZpZXcoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnc2NoZWR1bGUtd2lkZ2V0Jykge1xuICAgICAgICAgICAgV0Nfc2NoZWR1bGVXaWRnZXQoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09PSAnYW5ub3VuY2VtZW50cy13aWRnZXQnKSB7XG4gICAgICAgICAgICBXQ19hbm5vdW5jZW1lbnRzV2lkZ2V0KCdkYXNoYm9hcmQnKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrZXIocHJlZmVyZW5jZXMpIHtcbiAgICBjb25zdCB3aWRnZXRFbGVtZW50cyA9IFtdXG5cbiAgICAvLyBBbm5vdW5jZW1lbnRzXG4gICAgcHJlZmVyZW5jZXMuZm9yRWFjaChwcmVmZXJlbmNlID0+IHtcbiAgICAgICAgcHJlZmVyZW5jZS5pZCA9IHBhcnNlSW50KHByZWZlcmVuY2UuaWQpXG5cbiAgICAgICAgaWYgKHByZWZlcmVuY2Uuc3RhdGUgJiYgcHJlZmVyZW5jZS5pZCA9PT0gMCkge1xuICAgICAgICAgICAgd2lkZ2V0RWxlbWVudHMucHVzaCgnYW5ub3VuY2VtZW50cy13aWRnZXQnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJlbmNlLnN0YXRlICYmIHByZWZlcmVuY2UuaWQgPT09IDEpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzLnB1c2goJ3N0dWR5LXByb2dyZXNzJylcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZmVyZW5jZS5zdGF0ZSAmJiBwcmVmZXJlbmNlLmlkID09PSAyKSB7XG4gICAgICAgICAgICB3aWRnZXRFbGVtZW50cy5wdXNoKCdjb3Vyc2Utb3ZlcnZpZXcnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJlbmNlLnN0YXRlICYmIHByZWZlcmVuY2UuaWQgPT09IDMpIHtcbiAgICAgICAgICAgIHdpZGdldEVsZW1lbnRzLnB1c2goJ3NjaGVkdWxlLXdpZGdldCcpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHdpZGdldEVsZW1lbnRzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFuZFVwZGF0ZU1lbnUoKSB7XG4gICAgY29uc3Qgc2Vjb25kYXJ5TGlua3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbWVudS1zZWNvbmRhcnktbGlua3MnKVxuICAgIGNvbnN0IGNsb25lZExpbmtzID0gWy4uLnNlY29uZGFyeUxpbmtzLmNsb25lTm9kZSh0cnVlKS5jaGlsZHJlbl1cbiAgICBsZXQgc2VsZWN0ZWRNZW51SXRlbXMgPSBbXVxuXG4gICAgLy8gTG9jYWxTdG9yYWdlXG4gICAgY29uc3QgcHJlZmVyZW5jZXMgPSBnZXRMb2NhbFN0b3JhZ2UoJ21lbnUtcHJlZmVyZW5jZXMnKVxuICAgIGlmIChwcmVmZXJlbmNlcykge1xuICAgICAgICBwcmVmZXJlbmNlcy5mb3JFYWNoKHByZWZlcmVuY2UgPT4ge1xuICAgICAgICAgICAgY2xvbmVkTGlua3MuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gbGluay5xdWVyeVNlbGVjdG9yKCdwOmZpcnN0LW9mLXR5cGUnKS50ZXh0Q29udGVudFxuXG4gICAgICAgICAgICAgICAgaWYgKHByZWZlcmVuY2UubmFtZSA9PT0gbmFtZSAmJiBwcmVmZXJlbmNlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTWVudUl0ZW1zLnB1c2gobGluaylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIHNlY29uZGFyeUxpbmtzLnRleHRDb250ZW50ID0gJydcbiAgICAgICAgc2VsZWN0ZWRNZW51SXRlbXMuZm9yRWFjaChpdGVtID0+IHNlY29uZGFyeUxpbmtzLmFwcGVuZChpdGVtKSlcbiAgICB9XG59IiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vbW9kdWxlcy91dGlscy5tanMnXG5cbmV4cG9ydCB7IGluaXQgYXMgV0NfYW5ub3VuY2VtZW50c1dpZGdldCB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuKjpmb2N1cyB7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cbmgyIHtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcblx0Zm9udC1mYW1pbHk6IFwiT3BlblNhbnMtUmVndWxhclwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXHRmb250LXdlaWdodDogbGlnaHRlcjtcblx0bGluZS1oZWlnaHQ6IDEuMTtcbn1cbnAge1xuXHRtYXJnaW46IDA7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQge1xuXHRtYXJnaW4tYm90dG9tOiAyMHB4O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyICNhbm5vdW5jZW1lbnQtbGVnZW5kIHAge1xuXHRjb2xvcjogYmxhY2s7XG5cdGZvbnQtc2l6ZTogMTRweDtcblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIG1hcmdpbi1yaWdodDogMjBweDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcDpsYXN0LW9mLXR5cGUge1xuXHRtYXJnaW4tcmlnaHQ6IDA7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcDo6YmVmb3JlIHtcblx0Y29udGVudDogXCJcIjtcblx0aGVpZ2h0OiAxNXB4O1xuXHRtYXJnaW4tYm90dG9tOiAtMnB4O1xuXHR3aWR0aDogMTVweDtcblx0bWFyZ2luLXJpZ2h0OiAxMHB4O1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5PcGxlaWRpbmc6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNEQzE0M0M7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5GYWN1bHRlaXQ6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNEQ0I2MTQ7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5IdkE6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICMxNDlFREM7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC5NZWRlemVnZ2Vuc2NoYXA6OmJlZm9yZSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICMxNERDNjk7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC51bmFjdGl2ZSB7XG4gICAgY29sb3I6ICM2NjY2NjY7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgI2Fubm91bmNlbWVudC1sZWdlbmQgcC51bmFjdGl2ZTo6YmVmb3JlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjREREREREO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGEge1xuXHRtYXJnaW46IDAgMCAxNXB4IDA7XG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRjb2xvcjogYmxhY2s7XG5cdHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbn1cbi5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lciBhLmhpZGUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAtOTk5OXB4O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6aG92ZXIge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGMkYyO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6Zm9jdXMge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNEREREREQ7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgYTpmb2N1cyAucmVhZC1pbmRpY2F0b3Ige1xuICAgIGxlZnQ6IHVuc2V0O1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIGE6Zm9jdXMgLnJlYWQtaW5kaWNhdG9yOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGMkYyO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNGMkYyRjI7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLmFubm91bmNlbWVudCB7XG5cdG1hcmdpbjogMDtcblx0cGFkZGluZzogNXB4IDAgNXB4IDEwcHg7XG4gICAgYm9yZGVyLWxlZnQ6IDVweCBzb2xpZDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLmFubm91bmNlbWVudC5PcGxlaWRpbmcge1xuXHRib3JkZXItY29sb3I6ICNEQzE0M0M7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLmFubm91bmNlbWVudC5GYWN1bHRlaXQge1xuXHRib3JkZXItY29sb3I6ICNEQ0I2MTQ7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLmFubm91bmNlbWVudC5IdkEge1xuXHRib3JkZXItY29sb3I6ICMxNDlFREM7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLmFubm91bmNlbWVudC5NZWRlemVnZ2Vuc2NoYXAge1xuXHRib3JkZXItY29sb3I6ICMxNERDNjk7XG59XG4uYW5ub3VuY2VtZW50cy1jb250YWluZXIgLmFubm91bmNlbWVudCBwOmZpcnN0LW9mLXR5cGUge1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLUJvbGRcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbn1cbi5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lciAucmVhZCAuYW5ub3VuY2VtZW50IHA6Zmlyc3Qtb2YtdHlwZSB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtUmVndWxhclwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xufVxuLmFubm91bmNlbWVudHMtY29udGFpbmVyIC5hbm5vdW5jZW1lbnQgcDpsYXN0LW9mLXR5cGUge1xuXHRjb2xvcjogIzY2NjY2Njtcblx0Zm9udC1zaXplOiAxNHB4O1xufSAgICBcbi5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lciAuYW5ub3VuY2VtZW50OmhvdmVyIC5yZWFkLWluZGljYXRvciB7XG4gICAgbGVmdDogdW5zZXQ7XG59XG4uYWxsQW5ub3VuY2VtZW50cyB7XG4gICAgbWFyZ2luLXRvcDogMzBweDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZGlzcGxheTogZmxleDtcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5hbGxBbm5vdW5jZW1lbnRzOmhvdmVyLFxuLmFsbEFubm91bmNlbWVudHM6Zm9jdXMge1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cbi5hbGxBbm5vdW5jZW1lbnRzLmhpZGUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAtOTk5OXB4O1xufVxuLmFsbEFubm91bmNlbWVudHMgaW1nIHtcbiAgICAgICAgaGVpZ2h0OiAxMnB4O1xuICAgICAgICBtYXJnaW4tbGVmdDogMjBweDtcbn1cblxuI2Fubm91bmNlbWVudC1sZWdlbmQ6ZW1wdHkge1xuICAgIGhlaWdodDogMTUwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogdXJsKG1lZGlhL2ljb25zL2xvYWRlci5naWYpO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDIwMHB4IDIwMHB4O1xufVxuLnJlYWQtaW5kaWNhdG9yIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA1MCU7XG4gICAgcmlnaHQ6IDE1cHg7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIHBhZGRpbmc6IDEzcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5cHg7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKC4uL21lZGlhL2ljb25zL21hcmstYXMtcmVhZC5zdmcpO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgYmFja2dyb3VuZC1zaXplOiAyMHB4O1xuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogLTk5OTlweDtcbn1cbi5yZWFkLWluZGljYXRvcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjREREREREO1xufVxuLnJlYWQtaW5kaWNhdG9yOmZvY3VzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGMkYyO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNGMkYyRjI7XG59XG4ucmVhZC1pbmRpY2F0b3IubWFya2VkIHtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoLi4vbWVkaWEvaWNvbnMvbWFyay1hcy11bnJlYWQuc3ZnKTtcbn1cbjwvc3R5bGU+XG48ZGl2IGlkPVwiYW5ub3VuY2VtZW50c1wiPjwvZGl2PlxuPGgyPk1lZGVkZWxpbmdlbjwvaDI+XG48ZGl2IGNsYXNzPVwiYW5ub3VuY2VtZW50cy1jb250YWluZXJcIj5cblx0PGRpdiBpZD1cImFubm91bmNlbWVudC1sZWdlbmRcIj48L2Rpdj5cbjwvZGl2PlxuPGEgY2xhc3M9XCJhbGxBbm5vdW5jZW1lbnRzXCIgaHJlZj1cIi9hbm5vdW5jZW1lbnRzL1wiIHRhcmdldD1cIl9zZWxmXCI+QWxsZSBtZWRlZGVsaW5nZW5cblx0PGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvYT5gXG5cbmZ1bmN0aW9uIGluaXQocGFnZU5hbWUpIHtcbiAgICBjbGFzcyBhbm5vdW5jZW1lbnRMaXN0IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKClcblxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSlcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jb250ZW50LmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgICAgICAgdGhpcy5nZXREYXRhKClcbiAgICAgICAgICAgICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2Fubm91bmNlbWVudHMsIGNhdGVnb3JpZXNdID0ganNvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUxlZ2VuZGEoY2F0ZWdvcmllcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VOYW1lID09PSAnZGFzaGJvYXJkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3VuY2VtZW50cy5zcGxpY2UoNSwgYW5ub3VuY2VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRBbm5vdW5jZW1lbnRzKGFubm91bmNlbWVudHMpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRDYXRzICYmIHRoaXMuZmlsdGVyZWRDYXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDYXRzLmZvckVhY2goY2F0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChgLmFubm91bmNlbWVudHMtY29udGFpbmVyID4gYWApLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNsYXNzTGlzdC5jb250YWlucyhjYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0RmlsdGVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoYC4ke2NhdH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdEZpbHRlci5jbGFzc0xpc3QuYWRkKCd1bmFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy5hbm5vdW5jZW1lbnRDb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLmFubm91bmNlbWVudHMtY29udGFpbmVyJylcbiAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VtZW50TGVnZW5kID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNhbm5vdW5jZW1lbnQtbGVnZW5kJylcblxuICAgICAgICAgICAgaWYgKHV0aWxzLnN0b3JhZ2VBdmFpbGFibGUoJ2xvY2FsU3RvcmFnZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkRmlsdGVycyA9IHV0aWxzLmdldExvY2FsU3RvcmFnZSgnZmlsdGVycycpXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZENhdHMgPSBzdG9yZWRGaWx0ZXJzID8gc3RvcmVkRmlsdGVycyA6IFtdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYWdlTmFtZSA9PT0gJ2Fubm91bmNlbWVudHMtb3ZlcnZpZXcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5hbGxBbm5vdW5jZW1lbnRzJykuY2xhc3NMaXN0LmFkZCgnaGlkZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCgnL2Fubm91bmNlbWVudHNsaXN0Jywgb3B0aW9ucykudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNyZWF0ZUxlZ2VuZGEoY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGNhdCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZW1lbnRMZWdlbmQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBgPHAgY2xhc3M9XCIke2NhdH1cIj4ke2NhdH08L3A+YClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihgLiR7Y2F0fWApXG4gICAgICAgICAgICAgICAgbGVnZW5kSXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4gdGhpcy5maWx0ZXIoZS50YXJnZXQpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEFubm91bmNlbWVudHMoYW5ub3VuY2VtZW50cykge1xuICAgICAgICAgICAgYW5ub3VuY2VtZW50cy5mb3JFYWNoKGFubm91bmNlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdW5jZW1lbnRDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBgXG5cdFx0XHRcdDxhIGhyZWY9XCIvYW5ub3VuY2VtZW50cy8ke2Fubm91bmNlbWVudC5uZXdzSXRlbUlkfVwiIHRhcmdldD1cIl9zZWxmXCIgdWlkPVwiJHthbm5vdW5jZW1lbnQubmV3c0l0ZW1JZH1cIiBjbGFzcz1cIiR7YW5ub3VuY2VtZW50LnRhZ3NbMF19XCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImFubm91bmNlbWVudCAke2Fubm91bmNlbWVudC50YWdzWzBdfVwiIGlkPVwiJHthbm5vdW5jZW1lbnQubmV3c0l0ZW1JZH1cIj5cbiAgICAgICAgICAgICAgICBcdFx0PHA+JHthbm5vdW5jZW1lbnQudGl0bGV9PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+JHthbm5vdW5jZW1lbnQucHVibGlzaERhdGV9IC0gJHthbm5vdW5jZW1lbnQudGFnc1swXX08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlYWQtaW5kaWNhdG9yXCI+PC9zcGFuPlxuICAgICAgICAgICBcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9hPmApXG5cbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkSGlzdG9yeSA9IHV0aWxzLmdldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkSGlzdG9yeSA9IHN0b3JlZEhpc3RvcnkgPyBzdG9yZWRIaXN0b3J5IDogW11cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5hbm5vdW5jZW1lbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignYTpsYXN0LW9mLXR5cGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRIaXN0b3J5LmluY2x1ZGVzKGxpbmsuZ2V0QXR0cmlidXRlKCd1aWQnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZCgncmVhZCcpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuc3RvcmUobGluaykpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3JlKGFubm91bmNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkSGlzdG9yeS5wdXNoKGFubm91bmNlbWVudC5nZXRBdHRyaWJ1dGUoJ3VpZCcpKVxuICAgICAgICAgICAgdXRpbHMuc2V0TG9jYWxTdG9yYWdlKCdyZWFkLWhpc3RvcnknLCB0aGlzLnJlYWRIaXN0b3J5KVxuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyKGVsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRDYXRzLmluY2x1ZGVzKGVsLnRleHRDb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDYXRzLnB1c2goZWwudGV4dENvbnRlbnQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5maWx0ZXJlZENhdHMuaW5kZXhPZihlbC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkQ2F0cy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC50b2dnbGUoJ3VuYWN0aXZlJylcblxuICAgICAgICAgICAgdXRpbHMuc2V0TG9jYWxTdG9yYWdlKCdmaWx0ZXJzJywgdGhpcy5maWx0ZXJlZENhdHMpXG5cbiAgICAgICAgICAgIGNvbnN0IGFubm91bmNlbWVudHNJbkZpbHRlcmVkQ2F0ID0gW11cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRDYXRzLmZvckVhY2goY2F0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbm5vdW5jZW1lbnRzSW5DYXQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChgLmFubm91bmNlbWVudHMtY29udGFpbmVyID4gYS4ke2NhdH1gKVxuICAgICAgICAgICAgICAgIGFubm91bmNlbWVudHNJbkZpbHRlcmVkQ2F0LnB1c2goLi4uYW5ub3VuY2VtZW50c0luQ2F0KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoYC5hbm5vdW5jZW1lbnRzLWNvbnRhaW5lciA+IGFgKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdW5jZW1lbnRzSW5GaWx0ZXJlZENhdC5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2Fubm91bmNlbWVudHMtd2lkZ2V0JywgYW5ub3VuY2VtZW50TGlzdClcbn0iLCJleHBvcnQgeyBpbml0IGFzIFdDX2NvdXJzZW92ZXJ2aWV3IH1cblxuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpXG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG5oMiB7XG4gICAgZm9udC1zaXplOiAyNHB4O1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0RERERERDtcbiAgICBtYXJnaW46IDAgMCAxNXB4IDA7XG5cdGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLVJlZ3VsYXJcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcblx0Zm9udC13ZWlnaHQ6IGxpZ2h0ZXI7XG5cdGxpbmUtaGVpZ2h0OiAxLjE7XG59XG5cbnAge1xuXHRtYXJnaW46IDA7XG59XG5cbi5uYXZpZ2F0b3Ige1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNEREREREQ7XG4gICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICBmb250LXNpemU6IDE2cHg7XG59XG5cbi5uYXZpZ2F0b3Igc3BhbiAge1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbn1cblxuLm5hdmlnYXRvciBpbWcge1xuICAgIHBhZGRpbmc6IDEwcHg7XG59XG5cbi5uYXZpZ2F0b3IgaW1nOm5vdCguZGlzYWJsZWQpIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi5uYXZpZ2F0b3IgaW1nLmRpc2FibGVkIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBvcGFjaXR5OiAuNTtcbn1cblxuLmNvdXJzZSB7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XG4gICAgZ3JpZC1jb2x1bW4tZ2FwOiAyMHB4O1xuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0RERERERDtcbn1cblxuLmNvdXJzZSBwOmZpcnN0LW9mLXR5cGUge1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLUJvbGRcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG59XG5cbi5jb3Vyc2UgdWwge1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgYWxpZ24tc2VsZjogY2VudGVyO1xufVxuXG4uY291cnNlIHVsIGxpIHtcbiAgICBkaXNwbGF5OiBpbmxpbmU7XG59XG5cbi5jb3Vyc2UgdWwgbGk6bm90KDpsYXN0LW9mLXR5cGUpOmFmdGVyIHtcbiAgICBjb250ZW50OiBcIiwgXCI7XG4gICAgd2hpdGUtc3BhY2U6IHByZTtcbn1cblxuYSB7XG4gICAgbWFyZ2luLXRvcDogMzBweDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG5hOmhvdmVyLFxuYTpmb2N1cyB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cblxuYSBpbWcge1xuICAgIGhlaWdodDogMTJweDtcbiAgICBtYXJnaW4tbGVmdDogMjBweDtcbn1cblxuI2NvdXJzZS1vdmVydmlldzplbXB0eSB7XG4gICAgaGVpZ2h0OiAxNTBweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kOiB1cmwobWVkaWEvaWNvbnMvbG9hZGVyLmdpZik7XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyO1xuICAgIGJhY2tncm91bmQtc2l6ZTogMjAwcHggMjAwcHg7XG59XG48L3N0eWxlPlxuXG48aDI+VmFra2Vub3ZlcnppY2h0PC9oMj5cblxuPGRpdiBjbGFzcz1cIm5hdmlnYXRvclwiPlxuICAgIDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LWxlZnQuc3ZnXCIgYWx0PVwiYXJyb3ctbGVmdFwiPjwvaW1nPlxuICAgIDxzcGFuPjwvc3Bhbj5cbiAgICA8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1yaWdodC5zdmdcIiBhbHQ9XCJhcnJvdy1yaWdodFwiPjwvaW1nPlxuPC9kaXY+XG5cbjxkaXYgaWQ9XCJjb3Vyc2Utb3ZlcnZpZXdcIj48L2Rpdj5cblxuPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vc2lzLmh2YS5ubC9cIj5Wb2xsZWRpZyBvdmVyemljaHRcbiAgICA8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1yaWdodC5zdmdcIiBhbHQ9XCJhcnJvdy1yaWdodFwiPjwvaW1nPlxuPC9hPlxuYFxuXG5mdW5jdGlvbiBpbml0KCkge1xuICAgIGNsYXNzIENvdXJzZU92ZXJ2aWV3IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIFNldHVwXG4gICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgICAgICAvLyBWYXJpYWJsZXNcbiAgICAgICAgICAgIHRoaXMuY291cnNlQ29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJyNjb3Vyc2Utb3ZlcnZpZXcnKVxuICAgICAgICAgICAgdGhpcy5jb3Vyc2VNb21lbnQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLm5hdmlnYXRvciBzcGFuJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dQcmV2aW91cyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdG9yIGltZzpmaXJzdC1vZi10eXBlJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0ID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy5uYXZpZ2F0b3IgaW1nOmxhc3Qtb2YtdHlwZScpXG4gICAgICAgICAgICB0aGlzLnllYXJJbmRleCA9IDJcbiAgICAgICAgICAgIHRoaXMucXVhcnRlckluZGV4ID0gM1xuXG4gICAgICAgICAgICAvLyBEYXRhXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmdldERhdGEoKS50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVIYW5kbGVyKClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBqc29uW3RoaXMueWVhckluZGV4XS5xdWFydGVyc1t0aGlzLnF1YXJ0ZXJJbmRleF0uY291cnNlc1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ291cnNlT3ZlcnZpZXcoZGF0YSlcblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGpzb25cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIEV2ZW50TGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmFycm93UHJldmlvdXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm5hdmlnYXRlKCdwcmV2aW91cycpKVxuICAgICAgICAgICAgdGhpcy5hcnJvd05leHQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm5hdmlnYXRlKCduZXh0JykpXG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVOYXZpZ2F0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmNvdXJzZU1vbWVudC50ZXh0Q29udGVudCA9IGBKYWFyICR7dGhpcy55ZWFySW5kZXggKyAxfSAtIEJsb2sgJHt0aGlzLnF1YXJ0ZXJJbmRleCArIDF9YFxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlQ291cnNlT3ZlcnZpZXcoY291cnNlcykge1xuICAgICAgICAgICAgdGhpcy5jb3Vyc2VDb250YWluZXIudGV4dENvbnRlbnQgPSBcIlwiXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5hdmlnYXRvcigpXG5cbiAgICAgICAgICAgIGNvdXJzZXMuZm9yRWFjaChjb3Vyc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ2NvdXJzZScpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb3Vyc2VOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgY291cnNlTmFtZS50ZXh0Q29udGVudCA9IGNvdXJzZS5jb3Vyc2VcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kKGNvdXJzZU5hbWUpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKVxuICAgICAgICAgICAgICAgIGNvdXJzZS5sZWN0dXJlcnMuZm9yRWFjaChsZWN0dXJlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlYWNoZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpXG4gICAgICAgICAgICAgICAgICAgIGxlY3R1cmVyID09PSBcIlwiID8gdGVhY2hlci50ZXh0Q29udGVudCA9ICdHZWVuIHNwZWNpZmlla2UgZG9jZW50JyA6IHRlYWNoZXIudGV4dENvbnRlbnQgPSBsZWN0dXJlclxuICAgICAgICAgICAgICAgICAgICBsaXN0LmFwcGVuZCh0ZWFjaGVyKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZChsaXN0KVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb3Vyc2VDb250YWluZXIuYXBwZW5kKGRpdilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBuYXZpZ2F0ZShkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2aW91cycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWFydGVySW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhcnRlckluZGV4LS1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucXVhcnRlckluZGV4ID09PSAwICYmIHRoaXMueWVhckluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YXJ0ZXJJbmRleCA9IDNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFySW5kZXgtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVhcnRlckluZGV4IDwgMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YXJ0ZXJJbmRleCsrXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnF1YXJ0ZXJJbmRleCA9PT0gMyAmJiB0aGlzLnllYXJJbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFydGVySW5kZXggPSAwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhckluZGV4KytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGVIYW5kbGVyKClcblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVt0aGlzLnllYXJJbmRleF0ucXVhcnRlcnNbdGhpcy5xdWFydGVySW5kZXhdLmNvdXJzZXNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ291cnNlT3ZlcnZpZXcoZGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIG5hdmlnYXRlSGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMueWVhckluZGV4ID09PSAwICYmIHRoaXMucXVhcnRlckluZGV4ID09PSAwID9cbiAgICAgICAgICAgICAgICB0aGlzLmFycm93UHJldmlvdXMuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKSA6IHRoaXMuYXJyb3dQcmV2aW91cy5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpXG5cbiAgICAgICAgICAgIHRoaXMueWVhckluZGV4ID09PSAzICYmIHRoaXMucXVhcnRlckluZGV4ID09PSAzID9cbiAgICAgICAgICAgICAgICB0aGlzLmFycm93TmV4dC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpIDogdGhpcy5hcnJvd05leHQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyc1xuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCgnL2NvdXJzZW92ZXJ2aWV3Jywgb3B0aW9ucykudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY291cnNlLW92ZXJ2aWV3JywgQ291cnNlT3ZlcnZpZXcpXG59IiwiZXhwb3J0IHsgaW5pdCBhcyBXQ19zY2hlZHVsZVdpZGdldCB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuaDIge1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNEREREREQ7XG4gICAgbWFyZ2luOiAwIDAgMTVweCAwO1xuXHRmb250LWZhbWlseTogXCJPcGVuU2Fucy1SZWd1bGFyXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG5cdGZvbnQtd2VpZ2h0OiBsaWdodGVyO1xuXHRsaW5lLWhlaWdodDogMS4xO1xufVxuXG5wIHtcblx0bWFyZ2luOiAwO1xufVxuXG4ubmF2aWdhdG9yIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjREREREREO1xuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgY29sb3I6ICMyNTE2N0E7XG4gICAgZm9udC1zaXplOiAxNnB4O1xufVxuXG4ubmF2aWdhdG9yIHNwYW4gIHtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG59XG5cbi5uYXZpZ2F0b3IgaW1nIHtcbiAgICBwYWRkaW5nOiAxMHB4O1xufVxuXG4ubmF2aWdhdG9yIGltZzpub3QoLmRpc2FibGVkKSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ubmF2aWdhdG9yIGltZy5kaXNhYmxlZCB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgb3BhY2l0eTogLjU7XG59XG5cbi5zY2hlZHVsZS1jb3Vyc2Uge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIDFmcjtcbiAgICBncmlkLWNvbHVtbi1nYXA6IDIwcHg7XG4gICAgZ3JpZC1yb3ctZ2FwOiA1cHg7XG4gICAgcGFkZGluZzogMTVweCAyMHB4O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjREREREREO1xufVxuXG4uc2NoZWR1bGUtY291cnNlIHA6Zmlyc3Qtb2YtdHlwZSxcbi5zY2hlZHVsZS1jb3Vyc2UgcDpudGgtb2YtdHlwZSgzKSB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtQm9sZFwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xufVxuXG5hIHtcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbmE6aG92ZXIsXG5hOmZvY3VzIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBvdXRsaW5lOiBub25lO1xufVxuXG5hIGltZyB7XG4gICAgaGVpZ2h0OiAxMnB4O1xuICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xufVxuXG4jc2NoZWR1bGUtY29udGFpbmVyOmVtcHR5IHtcbiAgICBoZWlnaHQ6IDE1MHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJhY2tncm91bmQ6IHVybChtZWRpYS9pY29ucy9sb2FkZXIuZ2lmKTtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7XG4gICAgYmFja2dyb3VuZC1zaXplOiAyMDBweCAyMDBweDtcbn1cbjwvc3R5bGU+XG48aDI+RGFncm9vc3RlcjwvaDI+XG48ZGl2IGNsYXNzPVwibmF2aWdhdG9yXCI+XG5cdDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LWxlZnQuc3ZnXCIgYWx0PVwiYXJyb3ctbGVmdFwiIGNsYXNzPVwiZGlzYWJsZWRcIj48L2ltZz5cblx0PHNwYW4+PC9zcGFuPlxuXHQ8aW1nIHNyYz1cIi9tZWRpYS9pY29ucy9hcnJvdy1yaWdodC5zdmdcIiBhbHQ9XCJhcnJvdy1yaWdodFwiPjwvaW1nPlxuPC9kaXY+XG48ZGl2IGlkPVwic2NoZWR1bGVzLWNvbnRhaW5lclwiPjwvZGl2PlxuPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vcm9vc3Rlci5odmEubmwvc2NoZWR1bGVcIj5Wb2xsZWRpZyByb29zdGVyXG5cdDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2E+XG5gXG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gICAgY2xhc3Mgc2NoZWR1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKVxuXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmdldERhdGEoKVxuICAgICAgICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKGpzb25bMF0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGpzb25cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRvciA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcubmF2aWdhdG9yJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dQcmV2aW91cyA9IHRoaXMubmF2aWdhdG9yLnF1ZXJ5U2VsZWN0b3IoJ2ltZzpmaXJzdC1vZi10eXBlJylcbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0ID0gdGhpcy5uYXZpZ2F0b3IucXVlcnlTZWxlY3RvcignaW1nOmxhc3Qtb2YtdHlwZScpXG5cbiAgICAgICAgICAgIHRoaXMuYXJyb3dOZXh0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5uYXZpZ2F0ZSgnbmV4dCcpKVxuICAgICAgICAgICAgdGhpcy5hcnJvd1ByZXZpb3VzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5uYXZpZ2F0ZSgncHJldmlvdXMnKSlcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwXG4gICAgICAgIH1cblxuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCgnL3NjaGVkdWxlJywgb3B0aW9ucykudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVNjaGVkdWxlKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlc0NvbnRhaW5lciA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnc2NoZWR1bGVzLWNvbnRhaW5lcicpXG4gICAgICAgICAgICBzY2hlZHVsZXNDb250YWluZXIudGV4dENvbnRlbnQgPSBcIlwiXG5cbiAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKS50ZXh0Q29udGVudCA9IGAke2RhdGEuZGF5fSAtICR7ZGF0YS5tb250aH0gLSAke2RhdGEueWVhcn1gXG5cbiAgICAgICAgICAgIGRhdGEuc2NoZWR1bGVzLmZvckVhY2goc2NoZWR1bGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzUm9vbSA9IHNjaGVkdWxlLl9lbWJlZGRlZCA/IHNjaGVkdWxlLl9lbWJlZGRlZC5yb29tc1swXS5hYmJyZXZpYXRpb24gOiBcIkdlZW4gbG9rYWFsXCJcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3NjaGVkdWxlLWNvdXJzZScpXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGRpdilcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgICAgICAgICB0aW1lLnRleHRDb250ZW50ID0gYCR7c2NoZWR1bGUuc3RhcnREYXRlVGltZS50aW1lfSAtICR7c2NoZWR1bGUuZW5kRGF0ZVRpbWUudGltZX1gXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRpbWUpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgbmFtZS50ZXh0Q29udGVudCA9IHNjaGVkdWxlLl9saW5rcy5jb3Vyc2VzWzBdLnRpdGxlXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5hbWUpXG5cbiAgICAgICAgICAgICAgICBjb25zdCByb29tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICAgICAgcm9vbS50ZXh0Q29udGVudCA9IGNsYXNzUm9vbVxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChyb29tKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGVhY2hlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICAgICAgICAgIHRlYWNoZXIudGV4dENvbnRlbnQgPSBzY2hlZHVsZS5fbGlua3MubGVjdHVyZXJzWzBdLnRpdGxlXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRlYWNoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmF2aWdhdGUoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdwcmV2aW91cycgPyB0aGlzLmluZGV4LS0gOiB0aGlzLmluZGV4KytcblxuICAgICAgICAgICAgdGhpcy5pbmRleCA9PT0gMCA/IHRoaXMuYXJyb3dQcmV2aW91cy5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpIDogdGhpcy5hcnJvd1ByZXZpb3VzLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPT09IDQgPyB0aGlzLmFycm93TmV4dC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpIDogdGhpcy5hcnJvd05leHQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKHRoaXMuZGF0YVt0aGlzLmluZGV4XSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NjaGVkdWxlLXdpZGdldCcsIHNjaGVkdWxlKVxufSIsImV4cG9ydCB7IGluaXQgYXMgV0Nfc3R1ZHlwcm9ncmVzcyB9XG5cbmNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKVxudGVtcGxhdGUuaW5uZXJIVE1MID0gYFxuPHN0eWxlPlxuaDIge1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBjb2xvcjogIzI1MTY3QTtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNEREREREQ7XG4gICAgbWFyZ2luOiAwIDAgMTVweCAwO1xuICAgIGZvbnQtZmFtaWx5OiBcIk9wZW5TYW5zLVJlZ3VsYXJcIiwgc2Fucy1zZXJpZiwgQXJpYWwsIEhlbHZldGljYTtcbiAgICBmb250LXdlaWdodDogbGlnaHRlcjtcbiAgICBsaW5lLWhlaWdodDogMS4xO1xufVxuXG5wIHtcbiAgICBtYXJnaW46IDA7XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBkaXYge1xuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIDFmciBhdXRvO1xuICAgIGdyaWQtdGVtcGxhdGUtcm93czogMWZyIGF1dG87XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBkaXY6bm90KDpsYXN0LW9mLXR5cGUpIHtcbiAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xufVxuXG4jcmVjZW50LXJlc3VsdHMgc3BhbiB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgZ3JpZC1jb2x1bW46IDEgLyAyO1xuICAgIGdyaWQtcm93OiAxIC8gMztcbiAgICB3aWR0aDogNXB4O1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuc3Bhbi5zdWNjZXNzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjUxNjdBO1xufVxuXG5zcGFuLmZhaWxlZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbn1cblxuI3JlY2VudC1yZXN1bHRzIHA6bnRoLW9mLXR5cGUoMSkge1xuICAgIGdyaWQtY29sdW1uOiAyIC8gMztcbiAgICBwYWRkaW5nOiA0cHggMHB4IDBweCAxMHB4O1xufVxuXG4jcmVjZW50LXJlc3VsdHMgcDpudGgtb2YtdHlwZSgyKSB7XG4gICAgZ3JpZC1yb3c6IDEgLyAzO1xuICAgIGdyaWQtY29sdW1uOiAzIC8gNDtcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG59XG5cbiNyZWNlbnQtcmVzdWx0cyBwOm50aC1vZi10eXBlKDMpIHtcbiAgICBwYWRkaW5nOiAwcHggMHB4IDRweCAxMHB4O1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBjb2xvcjogIzY2NjY2Njtcbn1cblxuI3JlY2VudC1yZXN1bHRzIHA6bnRoLW9mLXR5cGUoMSksXG4jcmVjZW50LXJlc3VsdHMgcDpudGgtb2YtdHlwZSgyKSB7XG4gICAgZm9udC1mYW1pbHk6IFwiT3BlblNhbnMtQm9sZFwiLCBzYW5zLXNlcmlmLCBBcmlhbCwgSGVsdmV0aWNhO1xuXG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3Mge1xuICAgIG1hcmdpbi10b3A6IDMwcHg7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgZGl2IHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnIgYXV0bztcbn1cblxuI3JlY2VudC1wcm9ncmVzcyBkaXYgc3BhbiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB3aWR0aDogNXB4O1xufVxuXG4jcmVjZW50LXByb2dyZXNzIHAge1xuICAgIHBhZGRpbmc6IDVweCAwcHg7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgcDpmaXJzdC1vZi10eXBlIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0RERERERDtcbn1cblxuI3JlY2VudC1wcm9ncmVzcyAuY3VycmVudC15ZWFyIHNwYW4ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMyNTE2N0E7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciBwIHtcbiAgICBmb250LWZhbWlseTogXCJPcGVuU2Fucy1Cb2xkXCIsIHNhbnMtc2VyaWYsIEFyaWFsLCBIZWx2ZXRpY2E7XG59XG5cbiNyZWNlbnQtcHJvZ3Jlc3MgLmN1cnJlbnQteWVhciBwOmxhc3Qtb2YtdHlwZSB7XG4gICAgcGFkZGluZy1yaWdodDogMTBweDtcbn1cblxuI2xpbmstY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cblxuI2xpbmstY29udGFpbmVyIGEge1xuICAgIG1hcmdpbi10b3A6IDMwcHg7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGNvbG9yOiAjMjUxNjdBO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuI2xpbmstY29udGFpbmVyIGE6aG92ZXIsXG4jbGluay1jb250YWluZXIgYTpmb2N1cyB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbn1cblxuI2xpbmstY29udGFpbmVyIGEgaW1nIHtcbiAgICBoZWlnaHQ6IDEycHg7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG59XG5cbkBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDUwcHgpIHtcbiAgICAjbGluay1jb250YWluZXIge1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cblxuICAgICNsaW5rLWNvbnRhaW5lciBhOmxhc3Qtb2YtdHlwZSB7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgfVxufVxuXG4jcmVjZW50LXJlc3VsdHM6ZW1wdHkge1xuICAgIGhlaWdodDogMTUwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogdXJsKG1lZGlhL2ljb25zL2xvYWRlci5naWYpO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDIwMHB4IDIwMHB4O1xufVxuPC9zdHlsZT5cblxuPGgyPlN0dWRpZXJlc3VsdGF0ZW4gZW4gLXZvb3J0Z2FuZzwvaDI+XG5cbjxkaXYgaWQ9XCJyZWNlbnQtcmVzdWx0c1wiPjwvZGl2PlxuPGRpdiBpZD1cInJlY2VudC1wcm9ncmVzc1wiPjwvZGl2PlxuXG48ZGl2IGlkPVwibGluay1jb250YWluZXJcIj5cbjxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL3Npcy5odmEubmw6ODAxMS9wc2MvUzJQUkQvRU1QTE9ZRUUvU0EvYy9TTlNfTUVOVV9GTEQuU05TX1NTX1NURF9SRVNfRkwuR0JMXCI+Sm91dyByZXN1bHRhdGVuXG4gICAgPGltZyBzcmM9XCIvbWVkaWEvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnXCIgYWx0PVwiYXJyb3ctcmlnaHRcIj48L2ltZz5cbjwvYT5cblxuPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vc2lzLmh2YS5ubDo4MDExL3BzYy9TMlBSRC9FTVBMT1lFRS9TQS9jL1NOU19NRU5VX0ZMRC5TTlNfU1NfRkxEX0FEQi5HQkxcIj5Kb3V3IHN0dWRpZXZvb3J0Z2FuZ1xuICAgIDxpbWcgc3JjPVwiL21lZGlhL2ljb25zL2Fycm93LXJpZ2h0LnN2Z1wiIGFsdD1cImFycm93LXJpZ2h0XCI+PC9pbWc+XG48L2E+XG48L2Rpdj5cbmBcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjbGFzcyBTdHVkeVByb2dyZXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIFNldHVwXG4gICAgICAgICAgICBzdXBlcigpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgICAgICB0aGlzLmdldERhdGEoKS50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZXN1bHRzLCBwcm9ncmVzc10gPSBqc29uXG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdENvbXBvbmVudChyZXN1bHRzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDb21wb25lbnQocHJvZ3Jlc3MpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNDb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI3JlY2VudC1yZXN1bHRzJylcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDb250YWluZXIgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignI3JlY2VudC1wcm9ncmVzcycpXG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmVzc0NvbXBvbmVudChyZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY3VycmVudFllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ2N1cnJlbnQteWVhcicpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBgXG4gICAgICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxwPkxlZXJqYWFyICR7cmVzdWx0LnN0dWR5WWVhcn08L3A+XG4gICAgICAgICAgICAgICAgPHA+JHtyZXN1bHQuc3R1ZHlwb2ludHMuYWNoaWV2ZWR9LyR7cmVzdWx0LnN0dWR5cG9pbnRzLmF2YWlsYWJsZX0gc3R1ZGllcHVudGVuPC9wPmBcblxuICAgICAgICAgICAgICAgIC8vIEluc2VydEFkamFjZW50SHRtbFxuICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlIGVuZ2luZSB1aXR6b2VrZW4gdm9vciBXZWJjb21wb25lbnRzXG5cbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzQ29udGFpbmVyLmFwcGVuZChkaXYpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cblxuICAgICAgICByZXN1bHRDb21wb25lbnQocmVzdWx0cykge1xuICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgICAgICAgICBsZXQgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZ3JhZGUgPT09ICdudW1iZXInICYmIHJlc3VsdC5ncmFkZSA+PSA1LjUgfHwgcmVzdWx0LmdyYWRlID09PSAnVicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yID0gYDxzcGFuIGNsYXNzPVwic3VjY2Vzc1wiPjwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0LmdyYWRlID09PSAnbnVtYmVyJyAmJiByZXN1bHQuZ3JhZGUgPCA1LjUgfHwgcmVzdWx0LmdyYWRlID09PSAnLScgfHwgcmVzdWx0LmdyYWRlID09PSAnR1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciA9IGA8c3BhbiBjbGFzcz1cImZhaWxlZFwiPjwvc3Bhbj5gXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBgXG4gICAgICAgICAgICAgICAgJHtpbmRpY2F0b3J9XG4gICAgICAgICAgICAgICAgPHA+JHtyZXN1bHQuX2xpbmtzLmNvdXJzZS50aXRsZX08L3A+XG4gICAgICAgICAgICAgICAgPHA+JHtyZXN1bHQuZ3JhZGV9PC9wPlxuICAgICAgICAgICAgICAgIDxwPiR7cmVzdWx0LmZ1bGxEYXRlfTwvcD5cbiAgICAgICAgICAgICAgICBgXG5cbiAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHNDb250YWluZXIuYXBwZW5kKGRpdilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZWxwZXJzXG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKCcvc3R1ZHlwcm9ncmVzcycsIG9wdGlvbnMpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N0dWR5LXByb2dyZXNzJywgU3R1ZHlQcm9ncmVzcylcbn0iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi9tb2R1bGVzL3V0aWxzLm1qcydcblxuZXhwb3J0IHsgdGVtcGxhdGUgYXMgV0NfdXJnZW50QW5ub3VuY2VtZW50IH1cblxuY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpXG50ZW1wbGF0ZS5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG4gICAgZGl2IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBwYWRkaW5nOiAxNnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUNFN0ZBO1xuICAgICAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgICAgICB0b3A6IDA7XG4gICAgfVxuXG4gICAgZGl2LmhpZGUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6IC05OTk5cHg7XG4gICAgfVxuXG4gICAgcCB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTBweDtcbiAgICB9XG5cbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2OHB4KSB7XG4gICAgICAgIGRpdiB7XG4gICAgICAgICAgICB0b3A6IDYwcHg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbWcge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJoaWRlXCI+XG4gICAgPHA+PC9wPlxuICAgIDxpbWcgc3JjPVwiLi9tZWRpYS9pY29ucy9ub3RpZmljYXRpb24tZXhpdC5zdmdcIiBhbHQ9XCJoaWRlIG5vdGlmaWNhdGlvblwiPlxuPC9kaXY+YFxuXG5cblxuY2xhc3MgdXJnZW50QW5ub3VuY2VtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKClcblxuICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KVxuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdwJykudGV4dENvbnRlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWVzc2FnZScpXG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdpbWcnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgICAgICB0aGlzLnN0b3JlKClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIFsndWlkJ11cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBuZXdWYWx1ZSAmJiBuZXdWYWx1ZSAhPSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCB1aWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgndWlkJylcbiAgICAgICAgICAgIGlmICh1dGlscy5zdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZEhpc3RvcnkgPSB1dGlscy5nZXRMb2NhbFN0b3JhZ2UoJ3JlYWQtaGlzdG9yeScpXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZWRIaXN0b3J5LmluY2x1ZGVzKHVpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZW50KClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDb250ZW50KCkge1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcigncCcpLnRleHRDb250ZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21lc3NhZ2UnKVxuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJylcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbicpLmNsYXNzTGlzdC5hZGQoJ3Nob3dzTm90aWZpY2F0aW9uJylcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZGl2JykuY2xhc3NMaXN0LmFkZCgnaGlkZScpXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4nKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93c05vdGlmaWNhdGlvbicpXG4gICAgfVxuXG4gICAgc3RvcmUoKSB7XG4gICAgICAgIGlmICh1dGlscy5zdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkSGlzdG9yeSA9IHV0aWxzLmdldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JylcbiAgICAgICAgICAgIGNvbnN0IHJlYWRIaXN0b3J5ID0gc3RvcmVkSGlzdG9yeSA/IHN0b3JlZEhpc3RvcnkgOiBbXVxuXG4gICAgICAgICAgICByZWFkSGlzdG9yeS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKCd1aWQnKSlcbiAgICAgICAgICAgIHV0aWxzLnNldExvY2FsU3RvcmFnZSgncmVhZC1oaXN0b3J5JywgcmVhZEhpc3RvcnkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3VyZ2VudC1hbm5vdW5jZW1lbnQnLCB1cmdlbnRBbm5vdW5jZW1lbnQpIl19"}